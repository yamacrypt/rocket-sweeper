using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System.Runtime.InteropServices;
using System;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using UdonObjectPool;

[UdonBehaviourSyncMode(BehaviourSyncMode.Manual)]
public class UnrolledMapGenerator : IMapGenerator
{
    [SerializeField]
    GameObject grassPool_prefab;
    public void grassPool_SetPrefab(GameObject prefab)
    {
        this.grassPool_prefab = grassPool_prefab;
    }

    int[][] grassPool_idToObjDict__keys;
    GameObject[][] grassPool_idToObjDict__values;
    int grassPool_idToObjDict__size;
    public int grassPool_idToObjDict_Count => grassPool_idToObjDict__size;

    public int[] grassPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[grassPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < grassPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = grassPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int grassPool_idToObjDict_bucketCount = 1;
    public int grassPool_idToObjDict_KeyLength => grassPool_idToObjDict__keys.Length;

    public void grassPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / grassPool_idToObjDict_bucketCount;
        grassPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            grassPool_idToObjDict__keys[i] = new int[grassPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < grassPool_idToObjDict_bucketCount; i++)
        {
            grassPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        grassPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            grassPool_idToObjDict__values[i] = new GameObject[grassPool_idToObjDict_bucketCount];
        }
    }

    public bool grassPool_idToObjDict_HasItem(int key)
    {
        var index = grassPool_idToObjDict_Hash(key);
        var hashKeys = grassPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int grassPool_idToObjDict_Hash(int key)
    {
        var len = grassPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool grassPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = grassPool_idToObjDict_Hash(key);
        var hashKeys = grassPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    grassPool_idToObjDict__keys[index][i] = key;
                    grassPool_idToObjDict__values[index][i] = value;
                    grassPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    grassPool_idToObjDict__keys[index][i] = key;
                    grassPool_idToObjDict__values[index][i] = value;
                    grassPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        grassPool_idToObjDict_ExpandList(index);
        grassPool_idToObjDict__keys[index][preLen] = key;
        grassPool_idToObjDict__values[index][preLen] = value;
        grassPool_idToObjDict__size++;
        return true;
    }

    const int grassPool_idToObjDict_expand = 5;
    void grassPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = grassPool_idToObjDict__keys[index];
        var hashValues = grassPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + grassPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        grassPool_idToObjDict__keys[index] = newKeys;
        grassPool_idToObjDict__values[index] = newValues;
    }

    public bool grassPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = grassPool_idToObjDict_Hash(key);
        var hashKeys = grassPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    grassPool_idToObjDict__keys[index][i] = key;
                    grassPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    grassPool_idToObjDict__keys[index][i] = key;
                    grassPool_idToObjDict__values[index][i] = value;
                    grassPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    grassPool_idToObjDict__keys[index][i] = key;
                    grassPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    grassPool_idToObjDict__keys[index][i] = key;
                    grassPool_idToObjDict__values[index][i] = value;
                    grassPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        grassPool_idToObjDict_ExpandList(index);
        grassPool_idToObjDict__keys[index][preLen] = key;
        grassPool_idToObjDict__values[index][preLen] = value;
        grassPool_idToObjDict__size++;
        return true;
    }

    public void grassPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = grassPool_idToObjDict_Hash(key);
        var hashKeys = grassPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    grassPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    grassPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject grassPool_idToObjDict_GetValue(int key)
    {
        int index = grassPool_idToObjDict_Hash(key);
        var hashKeys = grassPool_idToObjDict__keys[index];
        var hashValues = grassPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject grassPool_idToObjDict_TryGetValue(int key)
    {
        int index = grassPool_idToObjDict_Hash(key);
        var hashKeys = grassPool_idToObjDict__keys[index];
        var hashValues = grassPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void grassPool_idToObjDict_Remove(int key)
    {
        int index = grassPool_idToObjDict_Hash(key);
        var hashKeys = grassPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    grassPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    grassPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int grassPool_Capacity = 50021;
    public bool grassPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        grassPool_itemOperator_col.enabled = active;
        grassPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool grassPool_itemOperator_SetColliderActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        grassPool_itemOperator_col.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    //[SerializeField]int capacity=300000;
    void grassPool_itemOperator_Start()
    {
    //idToColDict.SetCapacity(capacity);
    //idToMeshDict.SetCapacity(capacity);
    }

    //[SerializeField,UnrollAttribute]IntToBoxColliderDictionary idToColDict;
    //[SerializeField,UnrollAttribute]IntToMeshRendererDictionary idToMeshDict;
    BoxCollider grassPool_itemOperator_col;
    MeshRenderer grassPool_itemOperator_mesh;
    public bool grassPool_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        grassPool_itemOperator_col = obj.GetComponent<BoxCollider>();
        grassPool_itemOperator_mesh = obj.GetComponent<MeshRenderer>();
        grassPool_itemOperator_col.enabled = active;
        grassPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool grassPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (grassPool_itemOperator_col == null || grassPool_itemOperator_mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return grassPool_itemOperator_col.enabled && grassPool_itemOperator_mesh.enabled;
    }

    int grassPool_poolSize;
    private int[] grassPool_notActiveObjQueue__array;
    private int grassPool_notActiveObjQueue__head; // First valid element in the queue.
    private int grassPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int grassPool_notActiveObjQueue__size; // Number of elements.
    private int grassPool_notActiveObjQueue__version;
    private const int grassPool_notActiveObjQueue_MinimumGrow = 100000;
    public int grassPool_notActiveObjQueue_Count => grassPool_notActiveObjQueue__size;
    public int grassPool_notActiveObjQueue_Version => grassPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int grassPool_notActiveObjQueue_GetCount() => grassPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int grassPool_notActiveObjQueue_GetVersion() => grassPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void grassPool_notActiveObjQueue_Clear()
    {
        grassPool_notActiveObjQueue__size = 0;
        grassPool_notActiveObjQueue__head = 0;
        grassPool_notActiveObjQueue__tail = 0;
        grassPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void grassPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < grassPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = grassPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = grassPool_notActiveObjQueue__array.Length - grassPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(grassPool_notActiveObjQueue__array, grassPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(grassPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void grassPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (grassPool_notActiveObjQueue__array == null)
        {
            grassPool_notActiveObjQueue_SetCapacity(grassPool_notActiveObjQueue_MinimumGrow);
        }
        else if (grassPool_notActiveObjQueue__size == grassPool_notActiveObjQueue__array.Length)
        {
            grassPool_notActiveObjQueue_SetCapacity(grassPool_notActiveObjQueue__array.Length + grassPool_notActiveObjQueue_MinimumGrow);
        }

        grassPool_notActiveObjQueue__array[grassPool_notActiveObjQueue__tail] = obj;
        grassPool_notActiveObjQueue__tail = (grassPool_notActiveObjQueue__tail + 1) % grassPool_notActiveObjQueue__array.Length;
        grassPool_notActiveObjQueue__size++;
        grassPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int grassPool_notActiveObjQueue_Dequeue()
    {
        if (grassPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = grassPool_notActiveObjQueue__array[grassPool_notActiveObjQueue__head];
        grassPool_notActiveObjQueue__array[grassPool_notActiveObjQueue__head] = int.MaxValue;
        grassPool_notActiveObjQueue__head = (grassPool_notActiveObjQueue__head + 1) % grassPool_notActiveObjQueue__array.Length;
        grassPool_notActiveObjQueue__size--;
        grassPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int grassPool_notActiveObjQueue_Peek()
    {
        if (grassPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return grassPool_notActiveObjQueue__array[grassPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] grassPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[grassPool_notActiveObjQueue__size];
        if (grassPool_notActiveObjQueue__size == 0)
        {
        }
        else if (grassPool_notActiveObjQueue__head < grassPool_notActiveObjQueue__tail)
        {
            Array.Copy(grassPool_notActiveObjQueue__array, grassPool_notActiveObjQueue__head, arr, 0, grassPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = grassPool_notActiveObjQueue__array.Length - grassPool_notActiveObjQueue__head;
            Array.Copy(grassPool_notActiveObjQueue__array, grassPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(grassPool_notActiveObjQueue__array, 0, arr, toHead, grassPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void grassPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (grassPool_notActiveObjQueue__size == 0)
        {
        }
        else if (grassPool_notActiveObjQueue__head < grassPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(grassPool_notActiveObjQueue__array, grassPool_notActiveObjQueue__head, newArray, 0, grassPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = grassPool_notActiveObjQueue__array.Length - grassPool_notActiveObjQueue__head;
            Array.Copy(grassPool_notActiveObjQueue__array, grassPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(grassPool_notActiveObjQueue__array, 0, newArray, toHead, grassPool_notActiveObjQueue__tail);
        }

        grassPool_notActiveObjQueue__array = newArray;
        grassPool_notActiveObjQueue__head = 0;
        grassPool_notActiveObjQueue__tail = grassPool_notActiveObjQueue__size == capacity ? 0 : grassPool_notActiveObjQueue__size;
        grassPool_notActiveObjQueue__version++;
    }

    //[SerializeField]Transform parent;
    void grassPool_Start()
    {
        grassPool_itemOperator_Start();
        grassPool_idToObjDict_SetCapacity(grassPool_Capacity);
        grassPool_notActiveObjQueue_SetCapacity(grassPool_Capacity);
    }

    public bool grassPool_PeekIsInstantiated()
    {
        return grassPool_isInstantiated;
    }

    bool grassPool_isInstantiated = false;
    public void grassPool_Store(Transform p = null)
    {
        if (grassPool_idToObjDict_Count > grassPool_idToObjDict_KeyLength)
            return;
        grassPool_isInstantiated = true;
        GameObject instance;
        int id;
        grassPool_instance = GameObject.Instantiate(grassPool_prefab);
        //gc alloc debug only
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        //id = GetInstanceID(instance);/*instance.GetInstanceID();*///.GetHashCode();
        id = grassPool_instance.GetInstanceID();
        grassPool_itemOperator_SetActive(grassPool_instance, id, false);
        grassPool_idToObjDict_Add(id, grassPool_instance);
        grassPool_notActiveObjQueue_Enqueue(id);
    }

    GameObject grassPool_instance;
    // falseで出してmeshcombinerで切り替える
    int grassPool_uniqueId = 0;
    public GameObject grassPool_TryToSpawn()
    {
        int id;
        grassPool_isInstantiated = true;
        if (grassPool_notActiveObjQueue_Count > 0)
        {
            grassPool_isInstantiated = false;
            id = grassPool_notActiveObjQueue_Dequeue();
            if (grassPool_idToObjDict_HasItem(id))
            {
                var obj = grassPool_idToObjDict_GetValue(id);
                //itemOperator.SetActive(obj,id,true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        grassPool_instance = GameObject.Instantiate(grassPool_prefab);
        //gc alloc
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        id = grassPool_instance.GetInstanceID();
        grassPool_idToObjDict_Add(id, grassPool_instance); // gc alloc
        //itemOperator.SetActive(instance,id,true);
        //}while(!idToObjDict.Add(id,instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return grassPool_instance;
    }

    public GameObject grassPool_TryToSpawn(int id)
    {
        grassPool_isInstantiated = false;
        if (grassPool_idToObjDict_HasItem(id))
        {
            var obj = grassPool_idToObjDict_GetValue(id);
            grassPool_itemOperator_SetActive(obj, id, false);
            return obj;
        }
        else
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return null;
        }
    }

    public void grassPool_Return(GameObject obj, bool force = false, bool enqueue = true)
    {
        // gc alloc debug only
        //if(obj==null)return; // gc alloc debug only
        int id = obj.GetInstanceID(); //obj.GetInstanceID();
        if (!grassPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        grassPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            grassPool_notActiveObjQueue_Enqueue(id);
    }

    public void grassPool_Return(GameObject obj, int id, bool force = false, bool enqueue = true)
    {
        //if(obj==null)return; // gc alloc debug only
        if (!grassPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        grassPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            grassPool_notActiveObjQueue_Enqueue(id);
    }

    public bool grassPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(grassPool_prefab.name);
    }

    public void grassPool_Clear()
    {
        grassPool_notActiveObjQueue_Clear();
        foreach (var obj in grassPool_idToObjDict_GenerateKeysArray())
        {
            grassPool_itemOperator_SetActive(grassPool_idToObjDict_GetValue(obj), false);
            grassPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject tundraPool_prefab;
    public void tundraPool_SetPrefab(GameObject prefab)
    {
        this.tundraPool_prefab = tundraPool_prefab;
    }

    int[][] tundraPool_idToObjDict__keys;
    GameObject[][] tundraPool_idToObjDict__values;
    int tundraPool_idToObjDict__size;
    public int tundraPool_idToObjDict_Count => tundraPool_idToObjDict__size;

    public int[] tundraPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[tundraPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < tundraPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = tundraPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int tundraPool_idToObjDict_bucketCount = 1;
    public int tundraPool_idToObjDict_KeyLength => tundraPool_idToObjDict__keys.Length;

    public void tundraPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / tundraPool_idToObjDict_bucketCount;
        tundraPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            tundraPool_idToObjDict__keys[i] = new int[tundraPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < tundraPool_idToObjDict_bucketCount; i++)
        {
            tundraPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        tundraPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            tundraPool_idToObjDict__values[i] = new GameObject[tundraPool_idToObjDict_bucketCount];
        }
    }

    public bool tundraPool_idToObjDict_HasItem(int key)
    {
        var index = tundraPool_idToObjDict_Hash(key);
        var hashKeys = tundraPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int tundraPool_idToObjDict_Hash(int key)
    {
        var len = tundraPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool tundraPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = tundraPool_idToObjDict_Hash(key);
        var hashKeys = tundraPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    tundraPool_idToObjDict__keys[index][i] = key;
                    tundraPool_idToObjDict__values[index][i] = value;
                    tundraPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    tundraPool_idToObjDict__keys[index][i] = key;
                    tundraPool_idToObjDict__values[index][i] = value;
                    tundraPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        tundraPool_idToObjDict_ExpandList(index);
        tundraPool_idToObjDict__keys[index][preLen] = key;
        tundraPool_idToObjDict__values[index][preLen] = value;
        tundraPool_idToObjDict__size++;
        return true;
    }

    const int tundraPool_idToObjDict_expand = 5;
    void tundraPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = tundraPool_idToObjDict__keys[index];
        var hashValues = tundraPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + tundraPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        tundraPool_idToObjDict__keys[index] = newKeys;
        tundraPool_idToObjDict__values[index] = newValues;
    }

    public bool tundraPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = tundraPool_idToObjDict_Hash(key);
        var hashKeys = tundraPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tundraPool_idToObjDict__keys[index][i] = key;
                    tundraPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    tundraPool_idToObjDict__keys[index][i] = key;
                    tundraPool_idToObjDict__values[index][i] = value;
                    tundraPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tundraPool_idToObjDict__keys[index][i] = key;
                    tundraPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    tundraPool_idToObjDict__keys[index][i] = key;
                    tundraPool_idToObjDict__values[index][i] = value;
                    tundraPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        tundraPool_idToObjDict_ExpandList(index);
        tundraPool_idToObjDict__keys[index][preLen] = key;
        tundraPool_idToObjDict__values[index][preLen] = value;
        tundraPool_idToObjDict__size++;
        return true;
    }

    public void tundraPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = tundraPool_idToObjDict_Hash(key);
        var hashKeys = tundraPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tundraPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tundraPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject tundraPool_idToObjDict_GetValue(int key)
    {
        int index = tundraPool_idToObjDict_Hash(key);
        var hashKeys = tundraPool_idToObjDict__keys[index];
        var hashValues = tundraPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject tundraPool_idToObjDict_TryGetValue(int key)
    {
        int index = tundraPool_idToObjDict_Hash(key);
        var hashKeys = tundraPool_idToObjDict__keys[index];
        var hashValues = tundraPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void tundraPool_idToObjDict_Remove(int key)
    {
        int index = tundraPool_idToObjDict_Hash(key);
        var hashKeys = tundraPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    tundraPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    tundraPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int tundraPool_Capacity = 50021;
    public bool tundraPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        tundraPool_itemOperator_col.enabled = active;
        tundraPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool tundraPool_itemOperator_SetColliderActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        tundraPool_itemOperator_col.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    //[SerializeField]int capacity=300000;
    void tundraPool_itemOperator_Start()
    {
    //idToColDict.SetCapacity(capacity);
    //idToMeshDict.SetCapacity(capacity);
    }

    //[SerializeField,UnrollAttribute]IntToBoxColliderDictionary idToColDict;
    //[SerializeField,UnrollAttribute]IntToMeshRendererDictionary idToMeshDict;
    BoxCollider tundraPool_itemOperator_col;
    MeshRenderer tundraPool_itemOperator_mesh;
    public bool tundraPool_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        tundraPool_itemOperator_col = obj.GetComponent<BoxCollider>();
        tundraPool_itemOperator_mesh = obj.GetComponent<MeshRenderer>();
        tundraPool_itemOperator_col.enabled = active;
        tundraPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool tundraPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (tundraPool_itemOperator_col == null || tundraPool_itemOperator_mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return tundraPool_itemOperator_col.enabled && tundraPool_itemOperator_mesh.enabled;
    }

    int tundraPool_poolSize;
    private int[] tundraPool_notActiveObjQueue__array;
    private int tundraPool_notActiveObjQueue__head; // First valid element in the queue.
    private int tundraPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int tundraPool_notActiveObjQueue__size; // Number of elements.
    private int tundraPool_notActiveObjQueue__version;
    private const int tundraPool_notActiveObjQueue_MinimumGrow = 100000;
    public int tundraPool_notActiveObjQueue_Count => tundraPool_notActiveObjQueue__size;
    public int tundraPool_notActiveObjQueue_Version => tundraPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int tundraPool_notActiveObjQueue_GetCount() => tundraPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int tundraPool_notActiveObjQueue_GetVersion() => tundraPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void tundraPool_notActiveObjQueue_Clear()
    {
        tundraPool_notActiveObjQueue__size = 0;
        tundraPool_notActiveObjQueue__head = 0;
        tundraPool_notActiveObjQueue__tail = 0;
        tundraPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void tundraPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < tundraPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = tundraPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = tundraPool_notActiveObjQueue__array.Length - tundraPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(tundraPool_notActiveObjQueue__array, tundraPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(tundraPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void tundraPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (tundraPool_notActiveObjQueue__array == null)
        {
            tundraPool_notActiveObjQueue_SetCapacity(tundraPool_notActiveObjQueue_MinimumGrow);
        }
        else if (tundraPool_notActiveObjQueue__size == tundraPool_notActiveObjQueue__array.Length)
        {
            tundraPool_notActiveObjQueue_SetCapacity(tundraPool_notActiveObjQueue__array.Length + tundraPool_notActiveObjQueue_MinimumGrow);
        }

        tundraPool_notActiveObjQueue__array[tundraPool_notActiveObjQueue__tail] = obj;
        tundraPool_notActiveObjQueue__tail = (tundraPool_notActiveObjQueue__tail + 1) % tundraPool_notActiveObjQueue__array.Length;
        tundraPool_notActiveObjQueue__size++;
        tundraPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int tundraPool_notActiveObjQueue_Dequeue()
    {
        if (tundraPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = tundraPool_notActiveObjQueue__array[tundraPool_notActiveObjQueue__head];
        tundraPool_notActiveObjQueue__array[tundraPool_notActiveObjQueue__head] = int.MaxValue;
        tundraPool_notActiveObjQueue__head = (tundraPool_notActiveObjQueue__head + 1) % tundraPool_notActiveObjQueue__array.Length;
        tundraPool_notActiveObjQueue__size--;
        tundraPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int tundraPool_notActiveObjQueue_Peek()
    {
        if (tundraPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return tundraPool_notActiveObjQueue__array[tundraPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] tundraPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[tundraPool_notActiveObjQueue__size];
        if (tundraPool_notActiveObjQueue__size == 0)
        {
        }
        else if (tundraPool_notActiveObjQueue__head < tundraPool_notActiveObjQueue__tail)
        {
            Array.Copy(tundraPool_notActiveObjQueue__array, tundraPool_notActiveObjQueue__head, arr, 0, tundraPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = tundraPool_notActiveObjQueue__array.Length - tundraPool_notActiveObjQueue__head;
            Array.Copy(tundraPool_notActiveObjQueue__array, tundraPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(tundraPool_notActiveObjQueue__array, 0, arr, toHead, tundraPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void tundraPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (tundraPool_notActiveObjQueue__size == 0)
        {
        }
        else if (tundraPool_notActiveObjQueue__head < tundraPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(tundraPool_notActiveObjQueue__array, tundraPool_notActiveObjQueue__head, newArray, 0, tundraPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = tundraPool_notActiveObjQueue__array.Length - tundraPool_notActiveObjQueue__head;
            Array.Copy(tundraPool_notActiveObjQueue__array, tundraPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(tundraPool_notActiveObjQueue__array, 0, newArray, toHead, tundraPool_notActiveObjQueue__tail);
        }

        tundraPool_notActiveObjQueue__array = newArray;
        tundraPool_notActiveObjQueue__head = 0;
        tundraPool_notActiveObjQueue__tail = tundraPool_notActiveObjQueue__size == capacity ? 0 : tundraPool_notActiveObjQueue__size;
        tundraPool_notActiveObjQueue__version++;
    }

    //[SerializeField]Transform parent;
    void tundraPool_Start()
    {
        tundraPool_itemOperator_Start();
        tundraPool_idToObjDict_SetCapacity(tundraPool_Capacity);
        tundraPool_notActiveObjQueue_SetCapacity(tundraPool_Capacity);
    }

    public bool tundraPool_PeekIsInstantiated()
    {
        return tundraPool_isInstantiated;
    }

    bool tundraPool_isInstantiated = false;
    public void tundraPool_Store(Transform p = null)
    {
        if (tundraPool_idToObjDict_Count > tundraPool_idToObjDict_KeyLength)
            return;
        tundraPool_isInstantiated = true;
        GameObject instance;
        int id;
        tundraPool_instance = GameObject.Instantiate(tundraPool_prefab);
        //gc alloc debug only
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        //id = GetInstanceID(instance);/*instance.GetInstanceID();*///.GetHashCode();
        id = tundraPool_instance.GetInstanceID();
        tundraPool_itemOperator_SetActive(tundraPool_instance, id, false);
        tundraPool_idToObjDict_Add(id, tundraPool_instance);
        tundraPool_notActiveObjQueue_Enqueue(id);
    }

    GameObject tundraPool_instance;
    // falseで出してmeshcombinerで切り替える
    int tundraPool_uniqueId = 0;
    public GameObject tundraPool_TryToSpawn()
    {
        int id;
        tundraPool_isInstantiated = true;
        if (tundraPool_notActiveObjQueue_Count > 0)
        {
            tundraPool_isInstantiated = false;
            id = tundraPool_notActiveObjQueue_Dequeue();
            if (tundraPool_idToObjDict_HasItem(id))
            {
                var obj = tundraPool_idToObjDict_GetValue(id);
                //itemOperator.SetActive(obj,id,true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        tundraPool_instance = GameObject.Instantiate(tundraPool_prefab);
        //gc alloc
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        id = tundraPool_instance.GetInstanceID();
        tundraPool_idToObjDict_Add(id, tundraPool_instance); // gc alloc
        //itemOperator.SetActive(instance,id,true);
        //}while(!idToObjDict.Add(id,instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return tundraPool_instance;
    }

    public GameObject tundraPool_TryToSpawn(int id)
    {
        tundraPool_isInstantiated = false;
        if (tundraPool_idToObjDict_HasItem(id))
        {
            var obj = tundraPool_idToObjDict_GetValue(id);
            tundraPool_itemOperator_SetActive(obj, id, false);
            return obj;
        }
        else
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return null;
        }
    }

    public void tundraPool_Return(GameObject obj, bool force = false, bool enqueue = true)
    {
        // gc alloc debug only
        //if(obj==null)return; // gc alloc debug only
        int id = obj.GetInstanceID(); //obj.GetInstanceID();
        if (!tundraPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        tundraPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            tundraPool_notActiveObjQueue_Enqueue(id);
    }

    public void tundraPool_Return(GameObject obj, int id, bool force = false, bool enqueue = true)
    {
        //if(obj==null)return; // gc alloc debug only
        if (!tundraPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        tundraPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            tundraPool_notActiveObjQueue_Enqueue(id);
    }

    public bool tundraPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(tundraPool_prefab.name);
    }

    public void tundraPool_Clear()
    {
        tundraPool_notActiveObjQueue_Clear();
        foreach (var obj in tundraPool_idToObjDict_GenerateKeysArray())
        {
            tundraPool_itemOperator_SetActive(tundraPool_idToObjDict_GetValue(obj), false);
            tundraPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject desertPool_prefab;
    public void desertPool_SetPrefab(GameObject prefab)
    {
        this.desertPool_prefab = desertPool_prefab;
    }

    int[][] desertPool_idToObjDict__keys;
    GameObject[][] desertPool_idToObjDict__values;
    int desertPool_idToObjDict__size;
    public int desertPool_idToObjDict_Count => desertPool_idToObjDict__size;

    public int[] desertPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[desertPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < desertPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = desertPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int desertPool_idToObjDict_bucketCount = 1;
    public int desertPool_idToObjDict_KeyLength => desertPool_idToObjDict__keys.Length;

    public void desertPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / desertPool_idToObjDict_bucketCount;
        desertPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            desertPool_idToObjDict__keys[i] = new int[desertPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < desertPool_idToObjDict_bucketCount; i++)
        {
            desertPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        desertPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            desertPool_idToObjDict__values[i] = new GameObject[desertPool_idToObjDict_bucketCount];
        }
    }

    public bool desertPool_idToObjDict_HasItem(int key)
    {
        var index = desertPool_idToObjDict_Hash(key);
        var hashKeys = desertPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int desertPool_idToObjDict_Hash(int key)
    {
        var len = desertPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool desertPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = desertPool_idToObjDict_Hash(key);
        var hashKeys = desertPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    desertPool_idToObjDict__keys[index][i] = key;
                    desertPool_idToObjDict__values[index][i] = value;
                    desertPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    desertPool_idToObjDict__keys[index][i] = key;
                    desertPool_idToObjDict__values[index][i] = value;
                    desertPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        desertPool_idToObjDict_ExpandList(index);
        desertPool_idToObjDict__keys[index][preLen] = key;
        desertPool_idToObjDict__values[index][preLen] = value;
        desertPool_idToObjDict__size++;
        return true;
    }

    const int desertPool_idToObjDict_expand = 5;
    void desertPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = desertPool_idToObjDict__keys[index];
        var hashValues = desertPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + desertPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        desertPool_idToObjDict__keys[index] = newKeys;
        desertPool_idToObjDict__values[index] = newValues;
    }

    public bool desertPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = desertPool_idToObjDict_Hash(key);
        var hashKeys = desertPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    desertPool_idToObjDict__keys[index][i] = key;
                    desertPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    desertPool_idToObjDict__keys[index][i] = key;
                    desertPool_idToObjDict__values[index][i] = value;
                    desertPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    desertPool_idToObjDict__keys[index][i] = key;
                    desertPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    desertPool_idToObjDict__keys[index][i] = key;
                    desertPool_idToObjDict__values[index][i] = value;
                    desertPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        desertPool_idToObjDict_ExpandList(index);
        desertPool_idToObjDict__keys[index][preLen] = key;
        desertPool_idToObjDict__values[index][preLen] = value;
        desertPool_idToObjDict__size++;
        return true;
    }

    public void desertPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = desertPool_idToObjDict_Hash(key);
        var hashKeys = desertPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    desertPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    desertPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject desertPool_idToObjDict_GetValue(int key)
    {
        int index = desertPool_idToObjDict_Hash(key);
        var hashKeys = desertPool_idToObjDict__keys[index];
        var hashValues = desertPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject desertPool_idToObjDict_TryGetValue(int key)
    {
        int index = desertPool_idToObjDict_Hash(key);
        var hashKeys = desertPool_idToObjDict__keys[index];
        var hashValues = desertPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void desertPool_idToObjDict_Remove(int key)
    {
        int index = desertPool_idToObjDict_Hash(key);
        var hashKeys = desertPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    desertPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    desertPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int desertPool_Capacity = 50021;
    public bool desertPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        desertPool_itemOperator_col.enabled = active;
        desertPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool desertPool_itemOperator_SetColliderActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        desertPool_itemOperator_col.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    //[SerializeField]int capacity=300000;
    void desertPool_itemOperator_Start()
    {
    //idToColDict.SetCapacity(capacity);
    //idToMeshDict.SetCapacity(capacity);
    }

    //[SerializeField,UnrollAttribute]IntToBoxColliderDictionary idToColDict;
    //[SerializeField,UnrollAttribute]IntToMeshRendererDictionary idToMeshDict;
    BoxCollider desertPool_itemOperator_col;
    MeshRenderer desertPool_itemOperator_mesh;
    public bool desertPool_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        desertPool_itemOperator_col = obj.GetComponent<BoxCollider>();
        desertPool_itemOperator_mesh = obj.GetComponent<MeshRenderer>();
        desertPool_itemOperator_col.enabled = active;
        desertPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool desertPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (desertPool_itemOperator_col == null || desertPool_itemOperator_mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return desertPool_itemOperator_col.enabled && desertPool_itemOperator_mesh.enabled;
    }

    int desertPool_poolSize;
    private int[] desertPool_notActiveObjQueue__array;
    private int desertPool_notActiveObjQueue__head; // First valid element in the queue.
    private int desertPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int desertPool_notActiveObjQueue__size; // Number of elements.
    private int desertPool_notActiveObjQueue__version;
    private const int desertPool_notActiveObjQueue_MinimumGrow = 100000;
    public int desertPool_notActiveObjQueue_Count => desertPool_notActiveObjQueue__size;
    public int desertPool_notActiveObjQueue_Version => desertPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int desertPool_notActiveObjQueue_GetCount() => desertPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int desertPool_notActiveObjQueue_GetVersion() => desertPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void desertPool_notActiveObjQueue_Clear()
    {
        desertPool_notActiveObjQueue__size = 0;
        desertPool_notActiveObjQueue__head = 0;
        desertPool_notActiveObjQueue__tail = 0;
        desertPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void desertPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < desertPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = desertPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = desertPool_notActiveObjQueue__array.Length - desertPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(desertPool_notActiveObjQueue__array, desertPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(desertPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void desertPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (desertPool_notActiveObjQueue__array == null)
        {
            desertPool_notActiveObjQueue_SetCapacity(desertPool_notActiveObjQueue_MinimumGrow);
        }
        else if (desertPool_notActiveObjQueue__size == desertPool_notActiveObjQueue__array.Length)
        {
            desertPool_notActiveObjQueue_SetCapacity(desertPool_notActiveObjQueue__array.Length + desertPool_notActiveObjQueue_MinimumGrow);
        }

        desertPool_notActiveObjQueue__array[desertPool_notActiveObjQueue__tail] = obj;
        desertPool_notActiveObjQueue__tail = (desertPool_notActiveObjQueue__tail + 1) % desertPool_notActiveObjQueue__array.Length;
        desertPool_notActiveObjQueue__size++;
        desertPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int desertPool_notActiveObjQueue_Dequeue()
    {
        if (desertPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = desertPool_notActiveObjQueue__array[desertPool_notActiveObjQueue__head];
        desertPool_notActiveObjQueue__array[desertPool_notActiveObjQueue__head] = int.MaxValue;
        desertPool_notActiveObjQueue__head = (desertPool_notActiveObjQueue__head + 1) % desertPool_notActiveObjQueue__array.Length;
        desertPool_notActiveObjQueue__size--;
        desertPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int desertPool_notActiveObjQueue_Peek()
    {
        if (desertPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return desertPool_notActiveObjQueue__array[desertPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] desertPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[desertPool_notActiveObjQueue__size];
        if (desertPool_notActiveObjQueue__size == 0)
        {
        }
        else if (desertPool_notActiveObjQueue__head < desertPool_notActiveObjQueue__tail)
        {
            Array.Copy(desertPool_notActiveObjQueue__array, desertPool_notActiveObjQueue__head, arr, 0, desertPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = desertPool_notActiveObjQueue__array.Length - desertPool_notActiveObjQueue__head;
            Array.Copy(desertPool_notActiveObjQueue__array, desertPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(desertPool_notActiveObjQueue__array, 0, arr, toHead, desertPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void desertPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (desertPool_notActiveObjQueue__size == 0)
        {
        }
        else if (desertPool_notActiveObjQueue__head < desertPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(desertPool_notActiveObjQueue__array, desertPool_notActiveObjQueue__head, newArray, 0, desertPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = desertPool_notActiveObjQueue__array.Length - desertPool_notActiveObjQueue__head;
            Array.Copy(desertPool_notActiveObjQueue__array, desertPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(desertPool_notActiveObjQueue__array, 0, newArray, toHead, desertPool_notActiveObjQueue__tail);
        }

        desertPool_notActiveObjQueue__array = newArray;
        desertPool_notActiveObjQueue__head = 0;
        desertPool_notActiveObjQueue__tail = desertPool_notActiveObjQueue__size == capacity ? 0 : desertPool_notActiveObjQueue__size;
        desertPool_notActiveObjQueue__version++;
    }

    //[SerializeField]Transform parent;
    void desertPool_Start()
    {
        desertPool_itemOperator_Start();
        desertPool_idToObjDict_SetCapacity(desertPool_Capacity);
        desertPool_notActiveObjQueue_SetCapacity(desertPool_Capacity);
    }

    public bool desertPool_PeekIsInstantiated()
    {
        return desertPool_isInstantiated;
    }

    bool desertPool_isInstantiated = false;
    public void desertPool_Store(Transform p = null)
    {
        if (desertPool_idToObjDict_Count > desertPool_idToObjDict_KeyLength)
            return;
        desertPool_isInstantiated = true;
        GameObject instance;
        int id;
        desertPool_instance = GameObject.Instantiate(desertPool_prefab);
        //gc alloc debug only
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        //id = GetInstanceID(instance);/*instance.GetInstanceID();*///.GetHashCode();
        id = desertPool_instance.GetInstanceID();
        desertPool_itemOperator_SetActive(desertPool_instance, id, false);
        desertPool_idToObjDict_Add(id, desertPool_instance);
        desertPool_notActiveObjQueue_Enqueue(id);
    }

    GameObject desertPool_instance;
    // falseで出してmeshcombinerで切り替える
    int desertPool_uniqueId = 0;
    public GameObject desertPool_TryToSpawn()
    {
        int id;
        desertPool_isInstantiated = true;
        if (desertPool_notActiveObjQueue_Count > 0)
        {
            desertPool_isInstantiated = false;
            id = desertPool_notActiveObjQueue_Dequeue();
            if (desertPool_idToObjDict_HasItem(id))
            {
                var obj = desertPool_idToObjDict_GetValue(id);
                //itemOperator.SetActive(obj,id,true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        desertPool_instance = GameObject.Instantiate(desertPool_prefab);
        //gc alloc
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        id = desertPool_instance.GetInstanceID();
        desertPool_idToObjDict_Add(id, desertPool_instance); // gc alloc
        //itemOperator.SetActive(instance,id,true);
        //}while(!idToObjDict.Add(id,instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return desertPool_instance;
    }

    public GameObject desertPool_TryToSpawn(int id)
    {
        desertPool_isInstantiated = false;
        if (desertPool_idToObjDict_HasItem(id))
        {
            var obj = desertPool_idToObjDict_GetValue(id);
            desertPool_itemOperator_SetActive(obj, id, false);
            return obj;
        }
        else
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return null;
        }
    }

    public void desertPool_Return(GameObject obj, bool force = false, bool enqueue = true)
    {
        // gc alloc debug only
        //if(obj==null)return; // gc alloc debug only
        int id = obj.GetInstanceID(); //obj.GetInstanceID();
        if (!desertPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        desertPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            desertPool_notActiveObjQueue_Enqueue(id);
    }

    public void desertPool_Return(GameObject obj, int id, bool force = false, bool enqueue = true)
    {
        //if(obj==null)return; // gc alloc debug only
        if (!desertPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        desertPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            desertPool_notActiveObjQueue_Enqueue(id);
    }

    public bool desertPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(desertPool_prefab.name);
    }

    public void desertPool_Clear()
    {
        desertPool_notActiveObjQueue_Clear();
        foreach (var obj in desertPool_idToObjDict_GenerateKeysArray())
        {
            desertPool_itemOperator_SetActive(desertPool_idToObjDict_GetValue(obj), false);
            desertPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject dirtPool_prefab;
    public void dirtPool_SetPrefab(GameObject prefab)
    {
        this.dirtPool_prefab = dirtPool_prefab;
    }

    int[][] dirtPool_idToObjDict__keys;
    GameObject[][] dirtPool_idToObjDict__values;
    int dirtPool_idToObjDict__size;
    public int dirtPool_idToObjDict_Count => dirtPool_idToObjDict__size;

    public int[] dirtPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[dirtPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < dirtPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = dirtPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int dirtPool_idToObjDict_bucketCount = 1;
    public int dirtPool_idToObjDict_KeyLength => dirtPool_idToObjDict__keys.Length;

    public void dirtPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / dirtPool_idToObjDict_bucketCount;
        dirtPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            dirtPool_idToObjDict__keys[i] = new int[dirtPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < dirtPool_idToObjDict_bucketCount; i++)
        {
            dirtPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        dirtPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            dirtPool_idToObjDict__values[i] = new GameObject[dirtPool_idToObjDict_bucketCount];
        }
    }

    public bool dirtPool_idToObjDict_HasItem(int key)
    {
        var index = dirtPool_idToObjDict_Hash(key);
        var hashKeys = dirtPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int dirtPool_idToObjDict_Hash(int key)
    {
        var len = dirtPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool dirtPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = dirtPool_idToObjDict_Hash(key);
        var hashKeys = dirtPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    dirtPool_idToObjDict__keys[index][i] = key;
                    dirtPool_idToObjDict__values[index][i] = value;
                    dirtPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    dirtPool_idToObjDict__keys[index][i] = key;
                    dirtPool_idToObjDict__values[index][i] = value;
                    dirtPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        dirtPool_idToObjDict_ExpandList(index);
        dirtPool_idToObjDict__keys[index][preLen] = key;
        dirtPool_idToObjDict__values[index][preLen] = value;
        dirtPool_idToObjDict__size++;
        return true;
    }

    const int dirtPool_idToObjDict_expand = 5;
    void dirtPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = dirtPool_idToObjDict__keys[index];
        var hashValues = dirtPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + dirtPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        dirtPool_idToObjDict__keys[index] = newKeys;
        dirtPool_idToObjDict__values[index] = newValues;
    }

    public bool dirtPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = dirtPool_idToObjDict_Hash(key);
        var hashKeys = dirtPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    dirtPool_idToObjDict__keys[index][i] = key;
                    dirtPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    dirtPool_idToObjDict__keys[index][i] = key;
                    dirtPool_idToObjDict__values[index][i] = value;
                    dirtPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    dirtPool_idToObjDict__keys[index][i] = key;
                    dirtPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    dirtPool_idToObjDict__keys[index][i] = key;
                    dirtPool_idToObjDict__values[index][i] = value;
                    dirtPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        dirtPool_idToObjDict_ExpandList(index);
        dirtPool_idToObjDict__keys[index][preLen] = key;
        dirtPool_idToObjDict__values[index][preLen] = value;
        dirtPool_idToObjDict__size++;
        return true;
    }

    public void dirtPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = dirtPool_idToObjDict_Hash(key);
        var hashKeys = dirtPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    dirtPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    dirtPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject dirtPool_idToObjDict_GetValue(int key)
    {
        int index = dirtPool_idToObjDict_Hash(key);
        var hashKeys = dirtPool_idToObjDict__keys[index];
        var hashValues = dirtPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject dirtPool_idToObjDict_TryGetValue(int key)
    {
        int index = dirtPool_idToObjDict_Hash(key);
        var hashKeys = dirtPool_idToObjDict__keys[index];
        var hashValues = dirtPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void dirtPool_idToObjDict_Remove(int key)
    {
        int index = dirtPool_idToObjDict_Hash(key);
        var hashKeys = dirtPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    dirtPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    dirtPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int dirtPool_Capacity = 50021;
    public bool dirtPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        dirtPool_itemOperator_col.enabled = active;
        dirtPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool dirtPool_itemOperator_SetColliderActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        dirtPool_itemOperator_col.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    //[SerializeField]int capacity=300000;
    void dirtPool_itemOperator_Start()
    {
    //idToColDict.SetCapacity(capacity);
    //idToMeshDict.SetCapacity(capacity);
    }

    //[SerializeField,UnrollAttribute]IntToBoxColliderDictionary idToColDict;
    //[SerializeField,UnrollAttribute]IntToMeshRendererDictionary idToMeshDict;
    BoxCollider dirtPool_itemOperator_col;
    MeshRenderer dirtPool_itemOperator_mesh;
    public bool dirtPool_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        dirtPool_itemOperator_col = obj.GetComponent<BoxCollider>();
        dirtPool_itemOperator_mesh = obj.GetComponent<MeshRenderer>();
        dirtPool_itemOperator_col.enabled = active;
        dirtPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool dirtPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (dirtPool_itemOperator_col == null || dirtPool_itemOperator_mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return dirtPool_itemOperator_col.enabled && dirtPool_itemOperator_mesh.enabled;
    }

    int dirtPool_poolSize;
    private int[] dirtPool_notActiveObjQueue__array;
    private int dirtPool_notActiveObjQueue__head; // First valid element in the queue.
    private int dirtPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int dirtPool_notActiveObjQueue__size; // Number of elements.
    private int dirtPool_notActiveObjQueue__version;
    private const int dirtPool_notActiveObjQueue_MinimumGrow = 100000;
    public int dirtPool_notActiveObjQueue_Count => dirtPool_notActiveObjQueue__size;
    public int dirtPool_notActiveObjQueue_Version => dirtPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int dirtPool_notActiveObjQueue_GetCount() => dirtPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int dirtPool_notActiveObjQueue_GetVersion() => dirtPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void dirtPool_notActiveObjQueue_Clear()
    {
        dirtPool_notActiveObjQueue__size = 0;
        dirtPool_notActiveObjQueue__head = 0;
        dirtPool_notActiveObjQueue__tail = 0;
        dirtPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void dirtPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < dirtPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = dirtPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = dirtPool_notActiveObjQueue__array.Length - dirtPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(dirtPool_notActiveObjQueue__array, dirtPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(dirtPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void dirtPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (dirtPool_notActiveObjQueue__array == null)
        {
            dirtPool_notActiveObjQueue_SetCapacity(dirtPool_notActiveObjQueue_MinimumGrow);
        }
        else if (dirtPool_notActiveObjQueue__size == dirtPool_notActiveObjQueue__array.Length)
        {
            dirtPool_notActiveObjQueue_SetCapacity(dirtPool_notActiveObjQueue__array.Length + dirtPool_notActiveObjQueue_MinimumGrow);
        }

        dirtPool_notActiveObjQueue__array[dirtPool_notActiveObjQueue__tail] = obj;
        dirtPool_notActiveObjQueue__tail = (dirtPool_notActiveObjQueue__tail + 1) % dirtPool_notActiveObjQueue__array.Length;
        dirtPool_notActiveObjQueue__size++;
        dirtPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int dirtPool_notActiveObjQueue_Dequeue()
    {
        if (dirtPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = dirtPool_notActiveObjQueue__array[dirtPool_notActiveObjQueue__head];
        dirtPool_notActiveObjQueue__array[dirtPool_notActiveObjQueue__head] = int.MaxValue;
        dirtPool_notActiveObjQueue__head = (dirtPool_notActiveObjQueue__head + 1) % dirtPool_notActiveObjQueue__array.Length;
        dirtPool_notActiveObjQueue__size--;
        dirtPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int dirtPool_notActiveObjQueue_Peek()
    {
        if (dirtPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return dirtPool_notActiveObjQueue__array[dirtPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] dirtPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[dirtPool_notActiveObjQueue__size];
        if (dirtPool_notActiveObjQueue__size == 0)
        {
        }
        else if (dirtPool_notActiveObjQueue__head < dirtPool_notActiveObjQueue__tail)
        {
            Array.Copy(dirtPool_notActiveObjQueue__array, dirtPool_notActiveObjQueue__head, arr, 0, dirtPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = dirtPool_notActiveObjQueue__array.Length - dirtPool_notActiveObjQueue__head;
            Array.Copy(dirtPool_notActiveObjQueue__array, dirtPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(dirtPool_notActiveObjQueue__array, 0, arr, toHead, dirtPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void dirtPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (dirtPool_notActiveObjQueue__size == 0)
        {
        }
        else if (dirtPool_notActiveObjQueue__head < dirtPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(dirtPool_notActiveObjQueue__array, dirtPool_notActiveObjQueue__head, newArray, 0, dirtPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = dirtPool_notActiveObjQueue__array.Length - dirtPool_notActiveObjQueue__head;
            Array.Copy(dirtPool_notActiveObjQueue__array, dirtPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(dirtPool_notActiveObjQueue__array, 0, newArray, toHead, dirtPool_notActiveObjQueue__tail);
        }

        dirtPool_notActiveObjQueue__array = newArray;
        dirtPool_notActiveObjQueue__head = 0;
        dirtPool_notActiveObjQueue__tail = dirtPool_notActiveObjQueue__size == capacity ? 0 : dirtPool_notActiveObjQueue__size;
        dirtPool_notActiveObjQueue__version++;
    }

    //[SerializeField]Transform parent;
    void dirtPool_Start()
    {
        dirtPool_itemOperator_Start();
        dirtPool_idToObjDict_SetCapacity(dirtPool_Capacity);
        dirtPool_notActiveObjQueue_SetCapacity(dirtPool_Capacity);
    }

    public bool dirtPool_PeekIsInstantiated()
    {
        return dirtPool_isInstantiated;
    }

    bool dirtPool_isInstantiated = false;
    public void dirtPool_Store(Transform p = null)
    {
        if (dirtPool_idToObjDict_Count > dirtPool_idToObjDict_KeyLength)
            return;
        dirtPool_isInstantiated = true;
        GameObject instance;
        int id;
        dirtPool_instance = GameObject.Instantiate(dirtPool_prefab);
        //gc alloc debug only
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        //id = GetInstanceID(instance);/*instance.GetInstanceID();*///.GetHashCode();
        id = dirtPool_instance.GetInstanceID();
        dirtPool_itemOperator_SetActive(dirtPool_instance, id, false);
        dirtPool_idToObjDict_Add(id, dirtPool_instance);
        dirtPool_notActiveObjQueue_Enqueue(id);
    }

    GameObject dirtPool_instance;
    // falseで出してmeshcombinerで切り替える
    int dirtPool_uniqueId = 0;
    public GameObject dirtPool_TryToSpawn()
    {
        int id;
        dirtPool_isInstantiated = true;
        if (dirtPool_notActiveObjQueue_Count > 0)
        {
            dirtPool_isInstantiated = false;
            id = dirtPool_notActiveObjQueue_Dequeue();
            if (dirtPool_idToObjDict_HasItem(id))
            {
                var obj = dirtPool_idToObjDict_GetValue(id);
                //itemOperator.SetActive(obj,id,true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        dirtPool_instance = GameObject.Instantiate(dirtPool_prefab);
        //gc alloc
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        id = dirtPool_instance.GetInstanceID();
        dirtPool_idToObjDict_Add(id, dirtPool_instance); // gc alloc
        //itemOperator.SetActive(instance,id,true);
        //}while(!idToObjDict.Add(id,instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return dirtPool_instance;
    }

    public GameObject dirtPool_TryToSpawn(int id)
    {
        dirtPool_isInstantiated = false;
        if (dirtPool_idToObjDict_HasItem(id))
        {
            var obj = dirtPool_idToObjDict_GetValue(id);
            dirtPool_itemOperator_SetActive(obj, id, false);
            return obj;
        }
        else
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return null;
        }
    }

    public void dirtPool_Return(GameObject obj, bool force = false, bool enqueue = true)
    {
        // gc alloc debug only
        //if(obj==null)return; // gc alloc debug only
        int id = obj.GetInstanceID(); //obj.GetInstanceID();
        if (!dirtPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        dirtPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            dirtPool_notActiveObjQueue_Enqueue(id);
    }

    public void dirtPool_Return(GameObject obj, int id, bool force = false, bool enqueue = true)
    {
        //if(obj==null)return; // gc alloc debug only
        if (!dirtPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        dirtPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            dirtPool_notActiveObjQueue_Enqueue(id);
    }

    public bool dirtPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(dirtPool_prefab.name);
    }

    public void dirtPool_Clear()
    {
        dirtPool_notActiveObjQueue_Clear();
        foreach (var obj in dirtPool_idToObjDict_GenerateKeysArray())
        {
            dirtPool_itemOperator_SetActive(dirtPool_idToObjDict_GetValue(obj), false);
            dirtPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject rockPool_prefab;
    public void rockPool_SetPrefab(GameObject prefab)
    {
        this.rockPool_prefab = rockPool_prefab;
    }

    int[][] rockPool_idToObjDict__keys;
    GameObject[][] rockPool_idToObjDict__values;
    int rockPool_idToObjDict__size;
    public int rockPool_idToObjDict_Count => rockPool_idToObjDict__size;

    public int[] rockPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[rockPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < rockPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = rockPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int rockPool_idToObjDict_bucketCount = 1;
    public int rockPool_idToObjDict_KeyLength => rockPool_idToObjDict__keys.Length;

    public void rockPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / rockPool_idToObjDict_bucketCount;
        rockPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            rockPool_idToObjDict__keys[i] = new int[rockPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < rockPool_idToObjDict_bucketCount; i++)
        {
            rockPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        rockPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            rockPool_idToObjDict__values[i] = new GameObject[rockPool_idToObjDict_bucketCount];
        }
    }

    public bool rockPool_idToObjDict_HasItem(int key)
    {
        var index = rockPool_idToObjDict_Hash(key);
        var hashKeys = rockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int rockPool_idToObjDict_Hash(int key)
    {
        var len = rockPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool rockPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = rockPool_idToObjDict_Hash(key);
        var hashKeys = rockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    rockPool_idToObjDict__keys[index][i] = key;
                    rockPool_idToObjDict__values[index][i] = value;
                    rockPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    rockPool_idToObjDict__keys[index][i] = key;
                    rockPool_idToObjDict__values[index][i] = value;
                    rockPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        rockPool_idToObjDict_ExpandList(index);
        rockPool_idToObjDict__keys[index][preLen] = key;
        rockPool_idToObjDict__values[index][preLen] = value;
        rockPool_idToObjDict__size++;
        return true;
    }

    const int rockPool_idToObjDict_expand = 5;
    void rockPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = rockPool_idToObjDict__keys[index];
        var hashValues = rockPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + rockPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        rockPool_idToObjDict__keys[index] = newKeys;
        rockPool_idToObjDict__values[index] = newValues;
    }

    public bool rockPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = rockPool_idToObjDict_Hash(key);
        var hashKeys = rockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    rockPool_idToObjDict__keys[index][i] = key;
                    rockPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    rockPool_idToObjDict__keys[index][i] = key;
                    rockPool_idToObjDict__values[index][i] = value;
                    rockPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    rockPool_idToObjDict__keys[index][i] = key;
                    rockPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    rockPool_idToObjDict__keys[index][i] = key;
                    rockPool_idToObjDict__values[index][i] = value;
                    rockPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        rockPool_idToObjDict_ExpandList(index);
        rockPool_idToObjDict__keys[index][preLen] = key;
        rockPool_idToObjDict__values[index][preLen] = value;
        rockPool_idToObjDict__size++;
        return true;
    }

    public void rockPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = rockPool_idToObjDict_Hash(key);
        var hashKeys = rockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    rockPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    rockPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject rockPool_idToObjDict_GetValue(int key)
    {
        int index = rockPool_idToObjDict_Hash(key);
        var hashKeys = rockPool_idToObjDict__keys[index];
        var hashValues = rockPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject rockPool_idToObjDict_TryGetValue(int key)
    {
        int index = rockPool_idToObjDict_Hash(key);
        var hashKeys = rockPool_idToObjDict__keys[index];
        var hashValues = rockPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void rockPool_idToObjDict_Remove(int key)
    {
        int index = rockPool_idToObjDict_Hash(key);
        var hashKeys = rockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    rockPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    rockPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int rockPool_Capacity = 50021;
    public bool rockPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        rockPool_itemOperator_col.enabled = active;
        rockPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool rockPool_itemOperator_SetColliderActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        rockPool_itemOperator_col.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    //[SerializeField]int capacity=300000;
    void rockPool_itemOperator_Start()
    {
    //idToColDict.SetCapacity(capacity);
    //idToMeshDict.SetCapacity(capacity);
    }

    //[SerializeField,UnrollAttribute]IntToBoxColliderDictionary idToColDict;
    //[SerializeField,UnrollAttribute]IntToMeshRendererDictionary idToMeshDict;
    BoxCollider rockPool_itemOperator_col;
    MeshRenderer rockPool_itemOperator_mesh;
    public bool rockPool_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        rockPool_itemOperator_col = obj.GetComponent<BoxCollider>();
        rockPool_itemOperator_mesh = obj.GetComponent<MeshRenderer>();
        rockPool_itemOperator_col.enabled = active;
        rockPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool rockPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (rockPool_itemOperator_col == null || rockPool_itemOperator_mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return rockPool_itemOperator_col.enabled && rockPool_itemOperator_mesh.enabled;
    }

    int rockPool_poolSize;
    private int[] rockPool_notActiveObjQueue__array;
    private int rockPool_notActiveObjQueue__head; // First valid element in the queue.
    private int rockPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int rockPool_notActiveObjQueue__size; // Number of elements.
    private int rockPool_notActiveObjQueue__version;
    private const int rockPool_notActiveObjQueue_MinimumGrow = 100000;
    public int rockPool_notActiveObjQueue_Count => rockPool_notActiveObjQueue__size;
    public int rockPool_notActiveObjQueue_Version => rockPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int rockPool_notActiveObjQueue_GetCount() => rockPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int rockPool_notActiveObjQueue_GetVersion() => rockPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void rockPool_notActiveObjQueue_Clear()
    {
        rockPool_notActiveObjQueue__size = 0;
        rockPool_notActiveObjQueue__head = 0;
        rockPool_notActiveObjQueue__tail = 0;
        rockPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void rockPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < rockPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = rockPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = rockPool_notActiveObjQueue__array.Length - rockPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(rockPool_notActiveObjQueue__array, rockPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(rockPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void rockPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (rockPool_notActiveObjQueue__array == null)
        {
            rockPool_notActiveObjQueue_SetCapacity(rockPool_notActiveObjQueue_MinimumGrow);
        }
        else if (rockPool_notActiveObjQueue__size == rockPool_notActiveObjQueue__array.Length)
        {
            rockPool_notActiveObjQueue_SetCapacity(rockPool_notActiveObjQueue__array.Length + rockPool_notActiveObjQueue_MinimumGrow);
        }

        rockPool_notActiveObjQueue__array[rockPool_notActiveObjQueue__tail] = obj;
        rockPool_notActiveObjQueue__tail = (rockPool_notActiveObjQueue__tail + 1) % rockPool_notActiveObjQueue__array.Length;
        rockPool_notActiveObjQueue__size++;
        rockPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int rockPool_notActiveObjQueue_Dequeue()
    {
        if (rockPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = rockPool_notActiveObjQueue__array[rockPool_notActiveObjQueue__head];
        rockPool_notActiveObjQueue__array[rockPool_notActiveObjQueue__head] = int.MaxValue;
        rockPool_notActiveObjQueue__head = (rockPool_notActiveObjQueue__head + 1) % rockPool_notActiveObjQueue__array.Length;
        rockPool_notActiveObjQueue__size--;
        rockPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int rockPool_notActiveObjQueue_Peek()
    {
        if (rockPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return rockPool_notActiveObjQueue__array[rockPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] rockPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[rockPool_notActiveObjQueue__size];
        if (rockPool_notActiveObjQueue__size == 0)
        {
        }
        else if (rockPool_notActiveObjQueue__head < rockPool_notActiveObjQueue__tail)
        {
            Array.Copy(rockPool_notActiveObjQueue__array, rockPool_notActiveObjQueue__head, arr, 0, rockPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = rockPool_notActiveObjQueue__array.Length - rockPool_notActiveObjQueue__head;
            Array.Copy(rockPool_notActiveObjQueue__array, rockPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(rockPool_notActiveObjQueue__array, 0, arr, toHead, rockPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void rockPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (rockPool_notActiveObjQueue__size == 0)
        {
        }
        else if (rockPool_notActiveObjQueue__head < rockPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(rockPool_notActiveObjQueue__array, rockPool_notActiveObjQueue__head, newArray, 0, rockPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = rockPool_notActiveObjQueue__array.Length - rockPool_notActiveObjQueue__head;
            Array.Copy(rockPool_notActiveObjQueue__array, rockPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(rockPool_notActiveObjQueue__array, 0, newArray, toHead, rockPool_notActiveObjQueue__tail);
        }

        rockPool_notActiveObjQueue__array = newArray;
        rockPool_notActiveObjQueue__head = 0;
        rockPool_notActiveObjQueue__tail = rockPool_notActiveObjQueue__size == capacity ? 0 : rockPool_notActiveObjQueue__size;
        rockPool_notActiveObjQueue__version++;
    }

    //[SerializeField]Transform parent;
    void rockPool_Start()
    {
        rockPool_itemOperator_Start();
        rockPool_idToObjDict_SetCapacity(rockPool_Capacity);
        rockPool_notActiveObjQueue_SetCapacity(rockPool_Capacity);
    }

    public bool rockPool_PeekIsInstantiated()
    {
        return rockPool_isInstantiated;
    }

    bool rockPool_isInstantiated = false;
    public void rockPool_Store(Transform p = null)
    {
        if (rockPool_idToObjDict_Count > rockPool_idToObjDict_KeyLength)
            return;
        rockPool_isInstantiated = true;
        GameObject instance;
        int id;
        rockPool_instance = GameObject.Instantiate(rockPool_prefab);
        //gc alloc debug only
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        //id = GetInstanceID(instance);/*instance.GetInstanceID();*///.GetHashCode();
        id = rockPool_instance.GetInstanceID();
        rockPool_itemOperator_SetActive(rockPool_instance, id, false);
        rockPool_idToObjDict_Add(id, rockPool_instance);
        rockPool_notActiveObjQueue_Enqueue(id);
    }

    GameObject rockPool_instance;
    // falseで出してmeshcombinerで切り替える
    int rockPool_uniqueId = 0;
    public GameObject rockPool_TryToSpawn()
    {
        int id;
        rockPool_isInstantiated = true;
        if (rockPool_notActiveObjQueue_Count > 0)
        {
            rockPool_isInstantiated = false;
            id = rockPool_notActiveObjQueue_Dequeue();
            if (rockPool_idToObjDict_HasItem(id))
            {
                var obj = rockPool_idToObjDict_GetValue(id);
                //itemOperator.SetActive(obj,id,true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        rockPool_instance = GameObject.Instantiate(rockPool_prefab);
        //gc alloc
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        id = rockPool_instance.GetInstanceID();
        rockPool_idToObjDict_Add(id, rockPool_instance); // gc alloc
        //itemOperator.SetActive(instance,id,true);
        //}while(!idToObjDict.Add(id,instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return rockPool_instance;
    }

    public GameObject rockPool_TryToSpawn(int id)
    {
        rockPool_isInstantiated = false;
        if (rockPool_idToObjDict_HasItem(id))
        {
            var obj = rockPool_idToObjDict_GetValue(id);
            rockPool_itemOperator_SetActive(obj, id, false);
            return obj;
        }
        else
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return null;
        }
    }

    public void rockPool_Return(GameObject obj, bool force = false, bool enqueue = true)
    {
        // gc alloc debug only
        //if(obj==null)return; // gc alloc debug only
        int id = obj.GetInstanceID(); //obj.GetInstanceID();
        if (!rockPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        rockPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            rockPool_notActiveObjQueue_Enqueue(id);
    }

    public void rockPool_Return(GameObject obj, int id, bool force = false, bool enqueue = true)
    {
        //if(obj==null)return; // gc alloc debug only
        if (!rockPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        rockPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            rockPool_notActiveObjQueue_Enqueue(id);
    }

    public bool rockPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(rockPool_prefab.name);
    }

    public void rockPool_Clear()
    {
        rockPool_notActiveObjQueue_Clear();
        foreach (var obj in rockPool_idToObjDict_GenerateKeysArray())
        {
            rockPool_itemOperator_SetActive(rockPool_idToObjDict_GetValue(obj), false);
            rockPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject sandPool_prefab;
    public void sandPool_SetPrefab(GameObject prefab)
    {
        this.sandPool_prefab = sandPool_prefab;
    }

    int[][] sandPool_idToObjDict__keys;
    GameObject[][] sandPool_idToObjDict__values;
    int sandPool_idToObjDict__size;
    public int sandPool_idToObjDict_Count => sandPool_idToObjDict__size;

    public int[] sandPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[sandPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < sandPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = sandPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int sandPool_idToObjDict_bucketCount = 1;
    public int sandPool_idToObjDict_KeyLength => sandPool_idToObjDict__keys.Length;

    public void sandPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / sandPool_idToObjDict_bucketCount;
        sandPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            sandPool_idToObjDict__keys[i] = new int[sandPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < sandPool_idToObjDict_bucketCount; i++)
        {
            sandPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        sandPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            sandPool_idToObjDict__values[i] = new GameObject[sandPool_idToObjDict_bucketCount];
        }
    }

    public bool sandPool_idToObjDict_HasItem(int key)
    {
        var index = sandPool_idToObjDict_Hash(key);
        var hashKeys = sandPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int sandPool_idToObjDict_Hash(int key)
    {
        var len = sandPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool sandPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = sandPool_idToObjDict_Hash(key);
        var hashKeys = sandPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    sandPool_idToObjDict__keys[index][i] = key;
                    sandPool_idToObjDict__values[index][i] = value;
                    sandPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    sandPool_idToObjDict__keys[index][i] = key;
                    sandPool_idToObjDict__values[index][i] = value;
                    sandPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        sandPool_idToObjDict_ExpandList(index);
        sandPool_idToObjDict__keys[index][preLen] = key;
        sandPool_idToObjDict__values[index][preLen] = value;
        sandPool_idToObjDict__size++;
        return true;
    }

    const int sandPool_idToObjDict_expand = 5;
    void sandPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = sandPool_idToObjDict__keys[index];
        var hashValues = sandPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + sandPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        sandPool_idToObjDict__keys[index] = newKeys;
        sandPool_idToObjDict__values[index] = newValues;
    }

    public bool sandPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = sandPool_idToObjDict_Hash(key);
        var hashKeys = sandPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    sandPool_idToObjDict__keys[index][i] = key;
                    sandPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    sandPool_idToObjDict__keys[index][i] = key;
                    sandPool_idToObjDict__values[index][i] = value;
                    sandPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    sandPool_idToObjDict__keys[index][i] = key;
                    sandPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    sandPool_idToObjDict__keys[index][i] = key;
                    sandPool_idToObjDict__values[index][i] = value;
                    sandPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        sandPool_idToObjDict_ExpandList(index);
        sandPool_idToObjDict__keys[index][preLen] = key;
        sandPool_idToObjDict__values[index][preLen] = value;
        sandPool_idToObjDict__size++;
        return true;
    }

    public void sandPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = sandPool_idToObjDict_Hash(key);
        var hashKeys = sandPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    sandPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    sandPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject sandPool_idToObjDict_GetValue(int key)
    {
        int index = sandPool_idToObjDict_Hash(key);
        var hashKeys = sandPool_idToObjDict__keys[index];
        var hashValues = sandPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject sandPool_idToObjDict_TryGetValue(int key)
    {
        int index = sandPool_idToObjDict_Hash(key);
        var hashKeys = sandPool_idToObjDict__keys[index];
        var hashValues = sandPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void sandPool_idToObjDict_Remove(int key)
    {
        int index = sandPool_idToObjDict_Hash(key);
        var hashKeys = sandPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    sandPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    sandPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int sandPool_Capacity = 50021;
    public bool sandPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        sandPool_itemOperator_col.enabled = active;
        sandPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool sandPool_itemOperator_SetColliderActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        sandPool_itemOperator_col.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    //[SerializeField]int capacity=300000;
    void sandPool_itemOperator_Start()
    {
    //idToColDict.SetCapacity(capacity);
    //idToMeshDict.SetCapacity(capacity);
    }

    //[SerializeField,UnrollAttribute]IntToBoxColliderDictionary idToColDict;
    //[SerializeField,UnrollAttribute]IntToMeshRendererDictionary idToMeshDict;
    BoxCollider sandPool_itemOperator_col;
    MeshRenderer sandPool_itemOperator_mesh;
    public bool sandPool_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        sandPool_itemOperator_col = obj.GetComponent<BoxCollider>();
        sandPool_itemOperator_mesh = obj.GetComponent<MeshRenderer>();
        sandPool_itemOperator_col.enabled = active;
        sandPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool sandPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (sandPool_itemOperator_col == null || sandPool_itemOperator_mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return sandPool_itemOperator_col.enabled && sandPool_itemOperator_mesh.enabled;
    }

    int sandPool_poolSize;
    private int[] sandPool_notActiveObjQueue__array;
    private int sandPool_notActiveObjQueue__head; // First valid element in the queue.
    private int sandPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int sandPool_notActiveObjQueue__size; // Number of elements.
    private int sandPool_notActiveObjQueue__version;
    private const int sandPool_notActiveObjQueue_MinimumGrow = 100000;
    public int sandPool_notActiveObjQueue_Count => sandPool_notActiveObjQueue__size;
    public int sandPool_notActiveObjQueue_Version => sandPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int sandPool_notActiveObjQueue_GetCount() => sandPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int sandPool_notActiveObjQueue_GetVersion() => sandPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void sandPool_notActiveObjQueue_Clear()
    {
        sandPool_notActiveObjQueue__size = 0;
        sandPool_notActiveObjQueue__head = 0;
        sandPool_notActiveObjQueue__tail = 0;
        sandPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void sandPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < sandPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = sandPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = sandPool_notActiveObjQueue__array.Length - sandPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(sandPool_notActiveObjQueue__array, sandPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(sandPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void sandPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (sandPool_notActiveObjQueue__array == null)
        {
            sandPool_notActiveObjQueue_SetCapacity(sandPool_notActiveObjQueue_MinimumGrow);
        }
        else if (sandPool_notActiveObjQueue__size == sandPool_notActiveObjQueue__array.Length)
        {
            sandPool_notActiveObjQueue_SetCapacity(sandPool_notActiveObjQueue__array.Length + sandPool_notActiveObjQueue_MinimumGrow);
        }

        sandPool_notActiveObjQueue__array[sandPool_notActiveObjQueue__tail] = obj;
        sandPool_notActiveObjQueue__tail = (sandPool_notActiveObjQueue__tail + 1) % sandPool_notActiveObjQueue__array.Length;
        sandPool_notActiveObjQueue__size++;
        sandPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int sandPool_notActiveObjQueue_Dequeue()
    {
        if (sandPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = sandPool_notActiveObjQueue__array[sandPool_notActiveObjQueue__head];
        sandPool_notActiveObjQueue__array[sandPool_notActiveObjQueue__head] = int.MaxValue;
        sandPool_notActiveObjQueue__head = (sandPool_notActiveObjQueue__head + 1) % sandPool_notActiveObjQueue__array.Length;
        sandPool_notActiveObjQueue__size--;
        sandPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int sandPool_notActiveObjQueue_Peek()
    {
        if (sandPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return sandPool_notActiveObjQueue__array[sandPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] sandPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[sandPool_notActiveObjQueue__size];
        if (sandPool_notActiveObjQueue__size == 0)
        {
        }
        else if (sandPool_notActiveObjQueue__head < sandPool_notActiveObjQueue__tail)
        {
            Array.Copy(sandPool_notActiveObjQueue__array, sandPool_notActiveObjQueue__head, arr, 0, sandPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = sandPool_notActiveObjQueue__array.Length - sandPool_notActiveObjQueue__head;
            Array.Copy(sandPool_notActiveObjQueue__array, sandPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(sandPool_notActiveObjQueue__array, 0, arr, toHead, sandPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void sandPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (sandPool_notActiveObjQueue__size == 0)
        {
        }
        else if (sandPool_notActiveObjQueue__head < sandPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(sandPool_notActiveObjQueue__array, sandPool_notActiveObjQueue__head, newArray, 0, sandPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = sandPool_notActiveObjQueue__array.Length - sandPool_notActiveObjQueue__head;
            Array.Copy(sandPool_notActiveObjQueue__array, sandPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(sandPool_notActiveObjQueue__array, 0, newArray, toHead, sandPool_notActiveObjQueue__tail);
        }

        sandPool_notActiveObjQueue__array = newArray;
        sandPool_notActiveObjQueue__head = 0;
        sandPool_notActiveObjQueue__tail = sandPool_notActiveObjQueue__size == capacity ? 0 : sandPool_notActiveObjQueue__size;
        sandPool_notActiveObjQueue__version++;
    }

    //[SerializeField]Transform parent;
    void sandPool_Start()
    {
        sandPool_itemOperator_Start();
        sandPool_idToObjDict_SetCapacity(sandPool_Capacity);
        sandPool_notActiveObjQueue_SetCapacity(sandPool_Capacity);
    }

    public bool sandPool_PeekIsInstantiated()
    {
        return sandPool_isInstantiated;
    }

    bool sandPool_isInstantiated = false;
    public void sandPool_Store(Transform p = null)
    {
        if (sandPool_idToObjDict_Count > sandPool_idToObjDict_KeyLength)
            return;
        sandPool_isInstantiated = true;
        GameObject instance;
        int id;
        sandPool_instance = GameObject.Instantiate(sandPool_prefab);
        //gc alloc debug only
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        //id = GetInstanceID(instance);/*instance.GetInstanceID();*///.GetHashCode();
        id = sandPool_instance.GetInstanceID();
        sandPool_itemOperator_SetActive(sandPool_instance, id, false);
        sandPool_idToObjDict_Add(id, sandPool_instance);
        sandPool_notActiveObjQueue_Enqueue(id);
    }

    GameObject sandPool_instance;
    // falseで出してmeshcombinerで切り替える
    int sandPool_uniqueId = 0;
    public GameObject sandPool_TryToSpawn()
    {
        int id;
        sandPool_isInstantiated = true;
        if (sandPool_notActiveObjQueue_Count > 0)
        {
            sandPool_isInstantiated = false;
            id = sandPool_notActiveObjQueue_Dequeue();
            if (sandPool_idToObjDict_HasItem(id))
            {
                var obj = sandPool_idToObjDict_GetValue(id);
                //itemOperator.SetActive(obj,id,true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        sandPool_instance = GameObject.Instantiate(sandPool_prefab);
        //gc alloc
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        id = sandPool_instance.GetInstanceID();
        sandPool_idToObjDict_Add(id, sandPool_instance); // gc alloc
        //itemOperator.SetActive(instance,id,true);
        //}while(!idToObjDict.Add(id,instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return sandPool_instance;
    }

    public GameObject sandPool_TryToSpawn(int id)
    {
        sandPool_isInstantiated = false;
        if (sandPool_idToObjDict_HasItem(id))
        {
            var obj = sandPool_idToObjDict_GetValue(id);
            sandPool_itemOperator_SetActive(obj, id, false);
            return obj;
        }
        else
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return null;
        }
    }

    public void sandPool_Return(GameObject obj, bool force = false, bool enqueue = true)
    {
        // gc alloc debug only
        //if(obj==null)return; // gc alloc debug only
        int id = obj.GetInstanceID(); //obj.GetInstanceID();
        if (!sandPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        sandPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            sandPool_notActiveObjQueue_Enqueue(id);
    }

    public void sandPool_Return(GameObject obj, int id, bool force = false, bool enqueue = true)
    {
        //if(obj==null)return; // gc alloc debug only
        if (!sandPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        sandPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            sandPool_notActiveObjQueue_Enqueue(id);
    }

    public bool sandPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(sandPool_prefab.name);
    }

    public void sandPool_Clear()
    {
        sandPool_notActiveObjQueue_Clear();
        foreach (var obj in sandPool_idToObjDict_GenerateKeysArray())
        {
            sandPool_itemOperator_SetActive(sandPool_idToObjDict_GetValue(obj), false);
            sandPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject waterPool_prefab;
    public void waterPool_SetPrefab(GameObject prefab)
    {
        this.waterPool_prefab = waterPool_prefab;
    }

    int[][] waterPool_idToObjDict__keys;
    GameObject[][] waterPool_idToObjDict__values;
    int waterPool_idToObjDict__size;
    public int waterPool_idToObjDict_Count => waterPool_idToObjDict__size;

    public int[] waterPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[waterPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < waterPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = waterPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int waterPool_idToObjDict_bucketCount = 1;
    public int waterPool_idToObjDict_KeyLength => waterPool_idToObjDict__keys.Length;

    public void waterPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / waterPool_idToObjDict_bucketCount;
        waterPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            waterPool_idToObjDict__keys[i] = new int[waterPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < waterPool_idToObjDict_bucketCount; i++)
        {
            waterPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        waterPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            waterPool_idToObjDict__values[i] = new GameObject[waterPool_idToObjDict_bucketCount];
        }
    }

    public bool waterPool_idToObjDict_HasItem(int key)
    {
        var index = waterPool_idToObjDict_Hash(key);
        var hashKeys = waterPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int waterPool_idToObjDict_Hash(int key)
    {
        var len = waterPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool waterPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = waterPool_idToObjDict_Hash(key);
        var hashKeys = waterPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    waterPool_idToObjDict__keys[index][i] = key;
                    waterPool_idToObjDict__values[index][i] = value;
                    waterPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    waterPool_idToObjDict__keys[index][i] = key;
                    waterPool_idToObjDict__values[index][i] = value;
                    waterPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        waterPool_idToObjDict_ExpandList(index);
        waterPool_idToObjDict__keys[index][preLen] = key;
        waterPool_idToObjDict__values[index][preLen] = value;
        waterPool_idToObjDict__size++;
        return true;
    }

    const int waterPool_idToObjDict_expand = 5;
    void waterPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = waterPool_idToObjDict__keys[index];
        var hashValues = waterPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + waterPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        waterPool_idToObjDict__keys[index] = newKeys;
        waterPool_idToObjDict__values[index] = newValues;
    }

    public bool waterPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = waterPool_idToObjDict_Hash(key);
        var hashKeys = waterPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    waterPool_idToObjDict__keys[index][i] = key;
                    waterPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    waterPool_idToObjDict__keys[index][i] = key;
                    waterPool_idToObjDict__values[index][i] = value;
                    waterPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    waterPool_idToObjDict__keys[index][i] = key;
                    waterPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    waterPool_idToObjDict__keys[index][i] = key;
                    waterPool_idToObjDict__values[index][i] = value;
                    waterPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        waterPool_idToObjDict_ExpandList(index);
        waterPool_idToObjDict__keys[index][preLen] = key;
        waterPool_idToObjDict__values[index][preLen] = value;
        waterPool_idToObjDict__size++;
        return true;
    }

    public void waterPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = waterPool_idToObjDict_Hash(key);
        var hashKeys = waterPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    waterPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    waterPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject waterPool_idToObjDict_GetValue(int key)
    {
        int index = waterPool_idToObjDict_Hash(key);
        var hashKeys = waterPool_idToObjDict__keys[index];
        var hashValues = waterPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject waterPool_idToObjDict_TryGetValue(int key)
    {
        int index = waterPool_idToObjDict_Hash(key);
        var hashKeys = waterPool_idToObjDict__keys[index];
        var hashValues = waterPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void waterPool_idToObjDict_Remove(int key)
    {
        int index = waterPool_idToObjDict_Hash(key);
        var hashKeys = waterPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    waterPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    waterPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int waterPool_Capacity = 50021;
    public bool waterPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        waterPool_itemOperator_col.enabled = active;
        waterPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool waterPool_itemOperator_SetColliderActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        waterPool_itemOperator_col.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    //[SerializeField]int capacity=300000;
    void waterPool_itemOperator_Start()
    {
    //idToColDict.SetCapacity(capacity);
    //idToMeshDict.SetCapacity(capacity);
    }

    //[SerializeField,UnrollAttribute]IntToBoxColliderDictionary idToColDict;
    //[SerializeField,UnrollAttribute]IntToMeshRendererDictionary idToMeshDict;
    BoxCollider waterPool_itemOperator_col;
    MeshRenderer waterPool_itemOperator_mesh;
    public bool waterPool_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        waterPool_itemOperator_col = obj.GetComponent<BoxCollider>();
        waterPool_itemOperator_mesh = obj.GetComponent<MeshRenderer>();
        waterPool_itemOperator_col.enabled = active;
        waterPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool waterPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (waterPool_itemOperator_col == null || waterPool_itemOperator_mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return waterPool_itemOperator_col.enabled && waterPool_itemOperator_mesh.enabled;
    }

    int waterPool_poolSize;
    private int[] waterPool_notActiveObjQueue__array;
    private int waterPool_notActiveObjQueue__head; // First valid element in the queue.
    private int waterPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int waterPool_notActiveObjQueue__size; // Number of elements.
    private int waterPool_notActiveObjQueue__version;
    private const int waterPool_notActiveObjQueue_MinimumGrow = 100000;
    public int waterPool_notActiveObjQueue_Count => waterPool_notActiveObjQueue__size;
    public int waterPool_notActiveObjQueue_Version => waterPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int waterPool_notActiveObjQueue_GetCount() => waterPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int waterPool_notActiveObjQueue_GetVersion() => waterPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void waterPool_notActiveObjQueue_Clear()
    {
        waterPool_notActiveObjQueue__size = 0;
        waterPool_notActiveObjQueue__head = 0;
        waterPool_notActiveObjQueue__tail = 0;
        waterPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void waterPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < waterPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = waterPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = waterPool_notActiveObjQueue__array.Length - waterPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(waterPool_notActiveObjQueue__array, waterPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(waterPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void waterPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (waterPool_notActiveObjQueue__array == null)
        {
            waterPool_notActiveObjQueue_SetCapacity(waterPool_notActiveObjQueue_MinimumGrow);
        }
        else if (waterPool_notActiveObjQueue__size == waterPool_notActiveObjQueue__array.Length)
        {
            waterPool_notActiveObjQueue_SetCapacity(waterPool_notActiveObjQueue__array.Length + waterPool_notActiveObjQueue_MinimumGrow);
        }

        waterPool_notActiveObjQueue__array[waterPool_notActiveObjQueue__tail] = obj;
        waterPool_notActiveObjQueue__tail = (waterPool_notActiveObjQueue__tail + 1) % waterPool_notActiveObjQueue__array.Length;
        waterPool_notActiveObjQueue__size++;
        waterPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int waterPool_notActiveObjQueue_Dequeue()
    {
        if (waterPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = waterPool_notActiveObjQueue__array[waterPool_notActiveObjQueue__head];
        waterPool_notActiveObjQueue__array[waterPool_notActiveObjQueue__head] = int.MaxValue;
        waterPool_notActiveObjQueue__head = (waterPool_notActiveObjQueue__head + 1) % waterPool_notActiveObjQueue__array.Length;
        waterPool_notActiveObjQueue__size--;
        waterPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int waterPool_notActiveObjQueue_Peek()
    {
        if (waterPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return waterPool_notActiveObjQueue__array[waterPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] waterPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[waterPool_notActiveObjQueue__size];
        if (waterPool_notActiveObjQueue__size == 0)
        {
        }
        else if (waterPool_notActiveObjQueue__head < waterPool_notActiveObjQueue__tail)
        {
            Array.Copy(waterPool_notActiveObjQueue__array, waterPool_notActiveObjQueue__head, arr, 0, waterPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = waterPool_notActiveObjQueue__array.Length - waterPool_notActiveObjQueue__head;
            Array.Copy(waterPool_notActiveObjQueue__array, waterPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(waterPool_notActiveObjQueue__array, 0, arr, toHead, waterPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void waterPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (waterPool_notActiveObjQueue__size == 0)
        {
        }
        else if (waterPool_notActiveObjQueue__head < waterPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(waterPool_notActiveObjQueue__array, waterPool_notActiveObjQueue__head, newArray, 0, waterPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = waterPool_notActiveObjQueue__array.Length - waterPool_notActiveObjQueue__head;
            Array.Copy(waterPool_notActiveObjQueue__array, waterPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(waterPool_notActiveObjQueue__array, 0, newArray, toHead, waterPool_notActiveObjQueue__tail);
        }

        waterPool_notActiveObjQueue__array = newArray;
        waterPool_notActiveObjQueue__head = 0;
        waterPool_notActiveObjQueue__tail = waterPool_notActiveObjQueue__size == capacity ? 0 : waterPool_notActiveObjQueue__size;
        waterPool_notActiveObjQueue__version++;
    }

    //[SerializeField]Transform parent;
    void waterPool_Start()
    {
        waterPool_itemOperator_Start();
        waterPool_idToObjDict_SetCapacity(waterPool_Capacity);
        waterPool_notActiveObjQueue_SetCapacity(waterPool_Capacity);
    }

    public bool waterPool_PeekIsInstantiated()
    {
        return waterPool_isInstantiated;
    }

    bool waterPool_isInstantiated = false;
    public void waterPool_Store(Transform p = null)
    {
        if (waterPool_idToObjDict_Count > waterPool_idToObjDict_KeyLength)
            return;
        waterPool_isInstantiated = true;
        GameObject instance;
        int id;
        waterPool_instance = GameObject.Instantiate(waterPool_prefab);
        //gc alloc debug only
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        //id = GetInstanceID(instance);/*instance.GetInstanceID();*///.GetHashCode();
        id = waterPool_instance.GetInstanceID();
        waterPool_itemOperator_SetActive(waterPool_instance, id, false);
        waterPool_idToObjDict_Add(id, waterPool_instance);
        waterPool_notActiveObjQueue_Enqueue(id);
    }

    GameObject waterPool_instance;
    // falseで出してmeshcombinerで切り替える
    int waterPool_uniqueId = 0;
    public GameObject waterPool_TryToSpawn()
    {
        int id;
        waterPool_isInstantiated = true;
        if (waterPool_notActiveObjQueue_Count > 0)
        {
            waterPool_isInstantiated = false;
            id = waterPool_notActiveObjQueue_Dequeue();
            if (waterPool_idToObjDict_HasItem(id))
            {
                var obj = waterPool_idToObjDict_GetValue(id);
                //itemOperator.SetActive(obj,id,true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        waterPool_instance = GameObject.Instantiate(waterPool_prefab);
        //gc alloc
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        id = waterPool_instance.GetInstanceID();
        waterPool_idToObjDict_Add(id, waterPool_instance); // gc alloc
        //itemOperator.SetActive(instance,id,true);
        //}while(!idToObjDict.Add(id,instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return waterPool_instance;
    }

    public GameObject waterPool_TryToSpawn(int id)
    {
        waterPool_isInstantiated = false;
        if (waterPool_idToObjDict_HasItem(id))
        {
            var obj = waterPool_idToObjDict_GetValue(id);
            waterPool_itemOperator_SetActive(obj, id, false);
            return obj;
        }
        else
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return null;
        }
    }

    public void waterPool_Return(GameObject obj, bool force = false, bool enqueue = true)
    {
        // gc alloc debug only
        //if(obj==null)return; // gc alloc debug only
        int id = obj.GetInstanceID(); //obj.GetInstanceID();
        if (!waterPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        waterPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            waterPool_notActiveObjQueue_Enqueue(id);
    }

    public void waterPool_Return(GameObject obj, int id, bool force = false, bool enqueue = true)
    {
        //if(obj==null)return; // gc alloc debug only
        if (!waterPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        waterPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            waterPool_notActiveObjQueue_Enqueue(id);
    }

    public bool waterPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(waterPool_prefab.name);
    }

    public void waterPool_Clear()
    {
        waterPool_notActiveObjQueue_Clear();
        foreach (var obj in waterPool_idToObjDict_GenerateKeysArray())
        {
            waterPool_itemOperator_SetActive(waterPool_idToObjDict_GetValue(obj), false);
            waterPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject darkPool_prefab;
    public void darkPool_SetPrefab(GameObject prefab)
    {
        this.darkPool_prefab = darkPool_prefab;
    }

    int[][] darkPool_idToObjDict__keys;
    GameObject[][] darkPool_idToObjDict__values;
    int darkPool_idToObjDict__size;
    public int darkPool_idToObjDict_Count => darkPool_idToObjDict__size;

    public int[] darkPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[darkPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < darkPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = darkPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int darkPool_idToObjDict_bucketCount = 1;
    public int darkPool_idToObjDict_KeyLength => darkPool_idToObjDict__keys.Length;

    public void darkPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / darkPool_idToObjDict_bucketCount;
        darkPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            darkPool_idToObjDict__keys[i] = new int[darkPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < darkPool_idToObjDict_bucketCount; i++)
        {
            darkPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        darkPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            darkPool_idToObjDict__values[i] = new GameObject[darkPool_idToObjDict_bucketCount];
        }
    }

    public bool darkPool_idToObjDict_HasItem(int key)
    {
        var index = darkPool_idToObjDict_Hash(key);
        var hashKeys = darkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int darkPool_idToObjDict_Hash(int key)
    {
        var len = darkPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool darkPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = darkPool_idToObjDict_Hash(key);
        var hashKeys = darkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    darkPool_idToObjDict__keys[index][i] = key;
                    darkPool_idToObjDict__values[index][i] = value;
                    darkPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    darkPool_idToObjDict__keys[index][i] = key;
                    darkPool_idToObjDict__values[index][i] = value;
                    darkPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        darkPool_idToObjDict_ExpandList(index);
        darkPool_idToObjDict__keys[index][preLen] = key;
        darkPool_idToObjDict__values[index][preLen] = value;
        darkPool_idToObjDict__size++;
        return true;
    }

    const int darkPool_idToObjDict_expand = 5;
    void darkPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = darkPool_idToObjDict__keys[index];
        var hashValues = darkPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + darkPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        darkPool_idToObjDict__keys[index] = newKeys;
        darkPool_idToObjDict__values[index] = newValues;
    }

    public bool darkPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = darkPool_idToObjDict_Hash(key);
        var hashKeys = darkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    darkPool_idToObjDict__keys[index][i] = key;
                    darkPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    darkPool_idToObjDict__keys[index][i] = key;
                    darkPool_idToObjDict__values[index][i] = value;
                    darkPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    darkPool_idToObjDict__keys[index][i] = key;
                    darkPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    darkPool_idToObjDict__keys[index][i] = key;
                    darkPool_idToObjDict__values[index][i] = value;
                    darkPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        darkPool_idToObjDict_ExpandList(index);
        darkPool_idToObjDict__keys[index][preLen] = key;
        darkPool_idToObjDict__values[index][preLen] = value;
        darkPool_idToObjDict__size++;
        return true;
    }

    public void darkPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = darkPool_idToObjDict_Hash(key);
        var hashKeys = darkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    darkPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    darkPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject darkPool_idToObjDict_GetValue(int key)
    {
        int index = darkPool_idToObjDict_Hash(key);
        var hashKeys = darkPool_idToObjDict__keys[index];
        var hashValues = darkPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject darkPool_idToObjDict_TryGetValue(int key)
    {
        int index = darkPool_idToObjDict_Hash(key);
        var hashKeys = darkPool_idToObjDict__keys[index];
        var hashValues = darkPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void darkPool_idToObjDict_Remove(int key)
    {
        int index = darkPool_idToObjDict_Hash(key);
        var hashKeys = darkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    darkPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    darkPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int darkPool_Capacity = 50021;
    public bool darkPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        darkPool_itemOperator_col.enabled = active;
        darkPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool darkPool_itemOperator_SetColliderActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        darkPool_itemOperator_col.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    //[SerializeField]int capacity=300000;
    void darkPool_itemOperator_Start()
    {
    //idToColDict.SetCapacity(capacity);
    //idToMeshDict.SetCapacity(capacity);
    }

    //[SerializeField,UnrollAttribute]IntToBoxColliderDictionary idToColDict;
    //[SerializeField,UnrollAttribute]IntToMeshRendererDictionary idToMeshDict;
    BoxCollider darkPool_itemOperator_col;
    MeshRenderer darkPool_itemOperator_mesh;
    public bool darkPool_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        darkPool_itemOperator_col = obj.GetComponent<BoxCollider>();
        darkPool_itemOperator_mesh = obj.GetComponent<MeshRenderer>();
        darkPool_itemOperator_col.enabled = active;
        darkPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool darkPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (darkPool_itemOperator_col == null || darkPool_itemOperator_mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return darkPool_itemOperator_col.enabled && darkPool_itemOperator_mesh.enabled;
    }

    int darkPool_poolSize;
    private int[] darkPool_notActiveObjQueue__array;
    private int darkPool_notActiveObjQueue__head; // First valid element in the queue.
    private int darkPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int darkPool_notActiveObjQueue__size; // Number of elements.
    private int darkPool_notActiveObjQueue__version;
    private const int darkPool_notActiveObjQueue_MinimumGrow = 100000;
    public int darkPool_notActiveObjQueue_Count => darkPool_notActiveObjQueue__size;
    public int darkPool_notActiveObjQueue_Version => darkPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int darkPool_notActiveObjQueue_GetCount() => darkPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int darkPool_notActiveObjQueue_GetVersion() => darkPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void darkPool_notActiveObjQueue_Clear()
    {
        darkPool_notActiveObjQueue__size = 0;
        darkPool_notActiveObjQueue__head = 0;
        darkPool_notActiveObjQueue__tail = 0;
        darkPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void darkPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < darkPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = darkPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = darkPool_notActiveObjQueue__array.Length - darkPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(darkPool_notActiveObjQueue__array, darkPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(darkPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void darkPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (darkPool_notActiveObjQueue__array == null)
        {
            darkPool_notActiveObjQueue_SetCapacity(darkPool_notActiveObjQueue_MinimumGrow);
        }
        else if (darkPool_notActiveObjQueue__size == darkPool_notActiveObjQueue__array.Length)
        {
            darkPool_notActiveObjQueue_SetCapacity(darkPool_notActiveObjQueue__array.Length + darkPool_notActiveObjQueue_MinimumGrow);
        }

        darkPool_notActiveObjQueue__array[darkPool_notActiveObjQueue__tail] = obj;
        darkPool_notActiveObjQueue__tail = (darkPool_notActiveObjQueue__tail + 1) % darkPool_notActiveObjQueue__array.Length;
        darkPool_notActiveObjQueue__size++;
        darkPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int darkPool_notActiveObjQueue_Dequeue()
    {
        if (darkPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = darkPool_notActiveObjQueue__array[darkPool_notActiveObjQueue__head];
        darkPool_notActiveObjQueue__array[darkPool_notActiveObjQueue__head] = int.MaxValue;
        darkPool_notActiveObjQueue__head = (darkPool_notActiveObjQueue__head + 1) % darkPool_notActiveObjQueue__array.Length;
        darkPool_notActiveObjQueue__size--;
        darkPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int darkPool_notActiveObjQueue_Peek()
    {
        if (darkPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return darkPool_notActiveObjQueue__array[darkPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] darkPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[darkPool_notActiveObjQueue__size];
        if (darkPool_notActiveObjQueue__size == 0)
        {
        }
        else if (darkPool_notActiveObjQueue__head < darkPool_notActiveObjQueue__tail)
        {
            Array.Copy(darkPool_notActiveObjQueue__array, darkPool_notActiveObjQueue__head, arr, 0, darkPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = darkPool_notActiveObjQueue__array.Length - darkPool_notActiveObjQueue__head;
            Array.Copy(darkPool_notActiveObjQueue__array, darkPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(darkPool_notActiveObjQueue__array, 0, arr, toHead, darkPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void darkPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (darkPool_notActiveObjQueue__size == 0)
        {
        }
        else if (darkPool_notActiveObjQueue__head < darkPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(darkPool_notActiveObjQueue__array, darkPool_notActiveObjQueue__head, newArray, 0, darkPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = darkPool_notActiveObjQueue__array.Length - darkPool_notActiveObjQueue__head;
            Array.Copy(darkPool_notActiveObjQueue__array, darkPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(darkPool_notActiveObjQueue__array, 0, newArray, toHead, darkPool_notActiveObjQueue__tail);
        }

        darkPool_notActiveObjQueue__array = newArray;
        darkPool_notActiveObjQueue__head = 0;
        darkPool_notActiveObjQueue__tail = darkPool_notActiveObjQueue__size == capacity ? 0 : darkPool_notActiveObjQueue__size;
        darkPool_notActiveObjQueue__version++;
    }

    //[SerializeField]Transform parent;
    void darkPool_Start()
    {
        darkPool_itemOperator_Start();
        darkPool_idToObjDict_SetCapacity(darkPool_Capacity);
        darkPool_notActiveObjQueue_SetCapacity(darkPool_Capacity);
    }

    public bool darkPool_PeekIsInstantiated()
    {
        return darkPool_isInstantiated;
    }

    bool darkPool_isInstantiated = false;
    public void darkPool_Store(Transform p = null)
    {
        if (darkPool_idToObjDict_Count > darkPool_idToObjDict_KeyLength)
            return;
        darkPool_isInstantiated = true;
        GameObject instance;
        int id;
        darkPool_instance = GameObject.Instantiate(darkPool_prefab);
        //gc alloc debug only
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        //id = GetInstanceID(instance);/*instance.GetInstanceID();*///.GetHashCode();
        id = darkPool_instance.GetInstanceID();
        darkPool_itemOperator_SetActive(darkPool_instance, id, false);
        darkPool_idToObjDict_Add(id, darkPool_instance);
        darkPool_notActiveObjQueue_Enqueue(id);
    }

    GameObject darkPool_instance;
    // falseで出してmeshcombinerで切り替える
    int darkPool_uniqueId = 0;
    public GameObject darkPool_TryToSpawn()
    {
        int id;
        darkPool_isInstantiated = true;
        if (darkPool_notActiveObjQueue_Count > 0)
        {
            darkPool_isInstantiated = false;
            id = darkPool_notActiveObjQueue_Dequeue();
            if (darkPool_idToObjDict_HasItem(id))
            {
                var obj = darkPool_idToObjDict_GetValue(id);
                //itemOperator.SetActive(obj,id,true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        darkPool_instance = GameObject.Instantiate(darkPool_prefab);
        //gc alloc
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        id = darkPool_instance.GetInstanceID();
        darkPool_idToObjDict_Add(id, darkPool_instance); // gc alloc
        //itemOperator.SetActive(instance,id,true);
        //}while(!idToObjDict.Add(id,instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return darkPool_instance;
    }

    public GameObject darkPool_TryToSpawn(int id)
    {
        darkPool_isInstantiated = false;
        if (darkPool_idToObjDict_HasItem(id))
        {
            var obj = darkPool_idToObjDict_GetValue(id);
            darkPool_itemOperator_SetActive(obj, id, false);
            return obj;
        }
        else
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return null;
        }
    }

    public void darkPool_Return(GameObject obj, bool force = false, bool enqueue = true)
    {
        // gc alloc debug only
        //if(obj==null)return; // gc alloc debug only
        int id = obj.GetInstanceID(); //obj.GetInstanceID();
        if (!darkPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        darkPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            darkPool_notActiveObjQueue_Enqueue(id);
    }

    public void darkPool_Return(GameObject obj, int id, bool force = false, bool enqueue = true)
    {
        //if(obj==null)return; // gc alloc debug only
        if (!darkPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        darkPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            darkPool_notActiveObjQueue_Enqueue(id);
    }

    public bool darkPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(darkPool_prefab.name);
    }

    public void darkPool_Clear()
    {
        darkPool_notActiveObjQueue_Clear();
        foreach (var obj in darkPool_idToObjDict_GenerateKeysArray())
        {
            darkPool_itemOperator_SetActive(darkPool_idToObjDict_GetValue(obj), false);
            darkPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject orangeRockPool_prefab;
    public void orangeRockPool_SetPrefab(GameObject prefab)
    {
        this.orangeRockPool_prefab = orangeRockPool_prefab;
    }

    int[][] orangeRockPool_idToObjDict__keys;
    GameObject[][] orangeRockPool_idToObjDict__values;
    int orangeRockPool_idToObjDict__size;
    public int orangeRockPool_idToObjDict_Count => orangeRockPool_idToObjDict__size;

    public int[] orangeRockPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[orangeRockPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < orangeRockPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = orangeRockPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int orangeRockPool_idToObjDict_bucketCount = 1;
    public int orangeRockPool_idToObjDict_KeyLength => orangeRockPool_idToObjDict__keys.Length;

    public void orangeRockPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / orangeRockPool_idToObjDict_bucketCount;
        orangeRockPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            orangeRockPool_idToObjDict__keys[i] = new int[orangeRockPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < orangeRockPool_idToObjDict_bucketCount; i++)
        {
            orangeRockPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        orangeRockPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            orangeRockPool_idToObjDict__values[i] = new GameObject[orangeRockPool_idToObjDict_bucketCount];
        }
    }

    public bool orangeRockPool_idToObjDict_HasItem(int key)
    {
        var index = orangeRockPool_idToObjDict_Hash(key);
        var hashKeys = orangeRockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int orangeRockPool_idToObjDict_Hash(int key)
    {
        var len = orangeRockPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool orangeRockPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = orangeRockPool_idToObjDict_Hash(key);
        var hashKeys = orangeRockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    orangeRockPool_idToObjDict__keys[index][i] = key;
                    orangeRockPool_idToObjDict__values[index][i] = value;
                    orangeRockPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    orangeRockPool_idToObjDict__keys[index][i] = key;
                    orangeRockPool_idToObjDict__values[index][i] = value;
                    orangeRockPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        orangeRockPool_idToObjDict_ExpandList(index);
        orangeRockPool_idToObjDict__keys[index][preLen] = key;
        orangeRockPool_idToObjDict__values[index][preLen] = value;
        orangeRockPool_idToObjDict__size++;
        return true;
    }

    const int orangeRockPool_idToObjDict_expand = 5;
    void orangeRockPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = orangeRockPool_idToObjDict__keys[index];
        var hashValues = orangeRockPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + orangeRockPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        orangeRockPool_idToObjDict__keys[index] = newKeys;
        orangeRockPool_idToObjDict__values[index] = newValues;
    }

    public bool orangeRockPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = orangeRockPool_idToObjDict_Hash(key);
        var hashKeys = orangeRockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    orangeRockPool_idToObjDict__keys[index][i] = key;
                    orangeRockPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    orangeRockPool_idToObjDict__keys[index][i] = key;
                    orangeRockPool_idToObjDict__values[index][i] = value;
                    orangeRockPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    orangeRockPool_idToObjDict__keys[index][i] = key;
                    orangeRockPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    orangeRockPool_idToObjDict__keys[index][i] = key;
                    orangeRockPool_idToObjDict__values[index][i] = value;
                    orangeRockPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        orangeRockPool_idToObjDict_ExpandList(index);
        orangeRockPool_idToObjDict__keys[index][preLen] = key;
        orangeRockPool_idToObjDict__values[index][preLen] = value;
        orangeRockPool_idToObjDict__size++;
        return true;
    }

    public void orangeRockPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = orangeRockPool_idToObjDict_Hash(key);
        var hashKeys = orangeRockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    orangeRockPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    orangeRockPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject orangeRockPool_idToObjDict_GetValue(int key)
    {
        int index = orangeRockPool_idToObjDict_Hash(key);
        var hashKeys = orangeRockPool_idToObjDict__keys[index];
        var hashValues = orangeRockPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject orangeRockPool_idToObjDict_TryGetValue(int key)
    {
        int index = orangeRockPool_idToObjDict_Hash(key);
        var hashKeys = orangeRockPool_idToObjDict__keys[index];
        var hashValues = orangeRockPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void orangeRockPool_idToObjDict_Remove(int key)
    {
        int index = orangeRockPool_idToObjDict_Hash(key);
        var hashKeys = orangeRockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    orangeRockPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    orangeRockPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int orangeRockPool_Capacity = 50021;
    public bool orangeRockPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        orangeRockPool_itemOperator_col.enabled = active;
        orangeRockPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool orangeRockPool_itemOperator_SetColliderActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        orangeRockPool_itemOperator_col.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    //[SerializeField]int capacity=300000;
    void orangeRockPool_itemOperator_Start()
    {
    //idToColDict.SetCapacity(capacity);
    //idToMeshDict.SetCapacity(capacity);
    }

    //[SerializeField,UnrollAttribute]IntToBoxColliderDictionary idToColDict;
    //[SerializeField,UnrollAttribute]IntToMeshRendererDictionary idToMeshDict;
    BoxCollider orangeRockPool_itemOperator_col;
    MeshRenderer orangeRockPool_itemOperator_mesh;
    public bool orangeRockPool_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        orangeRockPool_itemOperator_col = obj.GetComponent<BoxCollider>();
        orangeRockPool_itemOperator_mesh = obj.GetComponent<MeshRenderer>();
        orangeRockPool_itemOperator_col.enabled = active;
        orangeRockPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool orangeRockPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (orangeRockPool_itemOperator_col == null || orangeRockPool_itemOperator_mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return orangeRockPool_itemOperator_col.enabled && orangeRockPool_itemOperator_mesh.enabled;
    }

    int orangeRockPool_poolSize;
    private int[] orangeRockPool_notActiveObjQueue__array;
    private int orangeRockPool_notActiveObjQueue__head; // First valid element in the queue.
    private int orangeRockPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int orangeRockPool_notActiveObjQueue__size; // Number of elements.
    private int orangeRockPool_notActiveObjQueue__version;
    private const int orangeRockPool_notActiveObjQueue_MinimumGrow = 100000;
    public int orangeRockPool_notActiveObjQueue_Count => orangeRockPool_notActiveObjQueue__size;
    public int orangeRockPool_notActiveObjQueue_Version => orangeRockPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int orangeRockPool_notActiveObjQueue_GetCount() => orangeRockPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int orangeRockPool_notActiveObjQueue_GetVersion() => orangeRockPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void orangeRockPool_notActiveObjQueue_Clear()
    {
        orangeRockPool_notActiveObjQueue__size = 0;
        orangeRockPool_notActiveObjQueue__head = 0;
        orangeRockPool_notActiveObjQueue__tail = 0;
        orangeRockPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void orangeRockPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < orangeRockPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = orangeRockPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = orangeRockPool_notActiveObjQueue__array.Length - orangeRockPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(orangeRockPool_notActiveObjQueue__array, orangeRockPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(orangeRockPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void orangeRockPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (orangeRockPool_notActiveObjQueue__array == null)
        {
            orangeRockPool_notActiveObjQueue_SetCapacity(orangeRockPool_notActiveObjQueue_MinimumGrow);
        }
        else if (orangeRockPool_notActiveObjQueue__size == orangeRockPool_notActiveObjQueue__array.Length)
        {
            orangeRockPool_notActiveObjQueue_SetCapacity(orangeRockPool_notActiveObjQueue__array.Length + orangeRockPool_notActiveObjQueue_MinimumGrow);
        }

        orangeRockPool_notActiveObjQueue__array[orangeRockPool_notActiveObjQueue__tail] = obj;
        orangeRockPool_notActiveObjQueue__tail = (orangeRockPool_notActiveObjQueue__tail + 1) % orangeRockPool_notActiveObjQueue__array.Length;
        orangeRockPool_notActiveObjQueue__size++;
        orangeRockPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int orangeRockPool_notActiveObjQueue_Dequeue()
    {
        if (orangeRockPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = orangeRockPool_notActiveObjQueue__array[orangeRockPool_notActiveObjQueue__head];
        orangeRockPool_notActiveObjQueue__array[orangeRockPool_notActiveObjQueue__head] = int.MaxValue;
        orangeRockPool_notActiveObjQueue__head = (orangeRockPool_notActiveObjQueue__head + 1) % orangeRockPool_notActiveObjQueue__array.Length;
        orangeRockPool_notActiveObjQueue__size--;
        orangeRockPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int orangeRockPool_notActiveObjQueue_Peek()
    {
        if (orangeRockPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return orangeRockPool_notActiveObjQueue__array[orangeRockPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] orangeRockPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[orangeRockPool_notActiveObjQueue__size];
        if (orangeRockPool_notActiveObjQueue__size == 0)
        {
        }
        else if (orangeRockPool_notActiveObjQueue__head < orangeRockPool_notActiveObjQueue__tail)
        {
            Array.Copy(orangeRockPool_notActiveObjQueue__array, orangeRockPool_notActiveObjQueue__head, arr, 0, orangeRockPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = orangeRockPool_notActiveObjQueue__array.Length - orangeRockPool_notActiveObjQueue__head;
            Array.Copy(orangeRockPool_notActiveObjQueue__array, orangeRockPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(orangeRockPool_notActiveObjQueue__array, 0, arr, toHead, orangeRockPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void orangeRockPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (orangeRockPool_notActiveObjQueue__size == 0)
        {
        }
        else if (orangeRockPool_notActiveObjQueue__head < orangeRockPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(orangeRockPool_notActiveObjQueue__array, orangeRockPool_notActiveObjQueue__head, newArray, 0, orangeRockPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = orangeRockPool_notActiveObjQueue__array.Length - orangeRockPool_notActiveObjQueue__head;
            Array.Copy(orangeRockPool_notActiveObjQueue__array, orangeRockPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(orangeRockPool_notActiveObjQueue__array, 0, newArray, toHead, orangeRockPool_notActiveObjQueue__tail);
        }

        orangeRockPool_notActiveObjQueue__array = newArray;
        orangeRockPool_notActiveObjQueue__head = 0;
        orangeRockPool_notActiveObjQueue__tail = orangeRockPool_notActiveObjQueue__size == capacity ? 0 : orangeRockPool_notActiveObjQueue__size;
        orangeRockPool_notActiveObjQueue__version++;
    }

    //[SerializeField]Transform parent;
    void orangeRockPool_Start()
    {
        orangeRockPool_itemOperator_Start();
        orangeRockPool_idToObjDict_SetCapacity(orangeRockPool_Capacity);
        orangeRockPool_notActiveObjQueue_SetCapacity(orangeRockPool_Capacity);
    }

    public bool orangeRockPool_PeekIsInstantiated()
    {
        return orangeRockPool_isInstantiated;
    }

    bool orangeRockPool_isInstantiated = false;
    public void orangeRockPool_Store(Transform p = null)
    {
        if (orangeRockPool_idToObjDict_Count > orangeRockPool_idToObjDict_KeyLength)
            return;
        orangeRockPool_isInstantiated = true;
        GameObject instance;
        int id;
        orangeRockPool_instance = GameObject.Instantiate(orangeRockPool_prefab);
        //gc alloc debug only
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        //id = GetInstanceID(instance);/*instance.GetInstanceID();*///.GetHashCode();
        id = orangeRockPool_instance.GetInstanceID();
        orangeRockPool_itemOperator_SetActive(orangeRockPool_instance, id, false);
        orangeRockPool_idToObjDict_Add(id, orangeRockPool_instance);
        orangeRockPool_notActiveObjQueue_Enqueue(id);
    }

    GameObject orangeRockPool_instance;
    // falseで出してmeshcombinerで切り替える
    int orangeRockPool_uniqueId = 0;
    public GameObject orangeRockPool_TryToSpawn()
    {
        int id;
        orangeRockPool_isInstantiated = true;
        if (orangeRockPool_notActiveObjQueue_Count > 0)
        {
            orangeRockPool_isInstantiated = false;
            id = orangeRockPool_notActiveObjQueue_Dequeue();
            if (orangeRockPool_idToObjDict_HasItem(id))
            {
                var obj = orangeRockPool_idToObjDict_GetValue(id);
                //itemOperator.SetActive(obj,id,true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        orangeRockPool_instance = GameObject.Instantiate(orangeRockPool_prefab);
        //gc alloc
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        id = orangeRockPool_instance.GetInstanceID();
        orangeRockPool_idToObjDict_Add(id, orangeRockPool_instance); // gc alloc
        //itemOperator.SetActive(instance,id,true);
        //}while(!idToObjDict.Add(id,instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return orangeRockPool_instance;
    }

    public GameObject orangeRockPool_TryToSpawn(int id)
    {
        orangeRockPool_isInstantiated = false;
        if (orangeRockPool_idToObjDict_HasItem(id))
        {
            var obj = orangeRockPool_idToObjDict_GetValue(id);
            orangeRockPool_itemOperator_SetActive(obj, id, false);
            return obj;
        }
        else
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return null;
        }
    }

    public void orangeRockPool_Return(GameObject obj, bool force = false, bool enqueue = true)
    {
        // gc alloc debug only
        //if(obj==null)return; // gc alloc debug only
        int id = obj.GetInstanceID(); //obj.GetInstanceID();
        if (!orangeRockPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        orangeRockPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            orangeRockPool_notActiveObjQueue_Enqueue(id);
    }

    public void orangeRockPool_Return(GameObject obj, int id, bool force = false, bool enqueue = true)
    {
        //if(obj==null)return; // gc alloc debug only
        if (!orangeRockPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        orangeRockPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            orangeRockPool_notActiveObjQueue_Enqueue(id);
    }

    public bool orangeRockPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(orangeRockPool_prefab.name);
    }

    public void orangeRockPool_Clear()
    {
        orangeRockPool_notActiveObjQueue_Clear();
        foreach (var obj in orangeRockPool_idToObjDict_GenerateKeysArray())
        {
            orangeRockPool_itemOperator_SetActive(orangeRockPool_idToObjDict_GetValue(obj), false);
            orangeRockPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject redRockPool_prefab;
    public void redRockPool_SetPrefab(GameObject prefab)
    {
        this.redRockPool_prefab = redRockPool_prefab;
    }

    int[][] redRockPool_idToObjDict__keys;
    GameObject[][] redRockPool_idToObjDict__values;
    int redRockPool_idToObjDict__size;
    public int redRockPool_idToObjDict_Count => redRockPool_idToObjDict__size;

    public int[] redRockPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[redRockPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < redRockPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = redRockPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int redRockPool_idToObjDict_bucketCount = 1;
    public int redRockPool_idToObjDict_KeyLength => redRockPool_idToObjDict__keys.Length;

    public void redRockPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / redRockPool_idToObjDict_bucketCount;
        redRockPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            redRockPool_idToObjDict__keys[i] = new int[redRockPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < redRockPool_idToObjDict_bucketCount; i++)
        {
            redRockPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        redRockPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            redRockPool_idToObjDict__values[i] = new GameObject[redRockPool_idToObjDict_bucketCount];
        }
    }

    public bool redRockPool_idToObjDict_HasItem(int key)
    {
        var index = redRockPool_idToObjDict_Hash(key);
        var hashKeys = redRockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int redRockPool_idToObjDict_Hash(int key)
    {
        var len = redRockPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool redRockPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = redRockPool_idToObjDict_Hash(key);
        var hashKeys = redRockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    redRockPool_idToObjDict__keys[index][i] = key;
                    redRockPool_idToObjDict__values[index][i] = value;
                    redRockPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    redRockPool_idToObjDict__keys[index][i] = key;
                    redRockPool_idToObjDict__values[index][i] = value;
                    redRockPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        redRockPool_idToObjDict_ExpandList(index);
        redRockPool_idToObjDict__keys[index][preLen] = key;
        redRockPool_idToObjDict__values[index][preLen] = value;
        redRockPool_idToObjDict__size++;
        return true;
    }

    const int redRockPool_idToObjDict_expand = 5;
    void redRockPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = redRockPool_idToObjDict__keys[index];
        var hashValues = redRockPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + redRockPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        redRockPool_idToObjDict__keys[index] = newKeys;
        redRockPool_idToObjDict__values[index] = newValues;
    }

    public bool redRockPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = redRockPool_idToObjDict_Hash(key);
        var hashKeys = redRockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    redRockPool_idToObjDict__keys[index][i] = key;
                    redRockPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    redRockPool_idToObjDict__keys[index][i] = key;
                    redRockPool_idToObjDict__values[index][i] = value;
                    redRockPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    redRockPool_idToObjDict__keys[index][i] = key;
                    redRockPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    redRockPool_idToObjDict__keys[index][i] = key;
                    redRockPool_idToObjDict__values[index][i] = value;
                    redRockPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        redRockPool_idToObjDict_ExpandList(index);
        redRockPool_idToObjDict__keys[index][preLen] = key;
        redRockPool_idToObjDict__values[index][preLen] = value;
        redRockPool_idToObjDict__size++;
        return true;
    }

    public void redRockPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = redRockPool_idToObjDict_Hash(key);
        var hashKeys = redRockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    redRockPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    redRockPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject redRockPool_idToObjDict_GetValue(int key)
    {
        int index = redRockPool_idToObjDict_Hash(key);
        var hashKeys = redRockPool_idToObjDict__keys[index];
        var hashValues = redRockPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject redRockPool_idToObjDict_TryGetValue(int key)
    {
        int index = redRockPool_idToObjDict_Hash(key);
        var hashKeys = redRockPool_idToObjDict__keys[index];
        var hashValues = redRockPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void redRockPool_idToObjDict_Remove(int key)
    {
        int index = redRockPool_idToObjDict_Hash(key);
        var hashKeys = redRockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    redRockPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    redRockPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int redRockPool_Capacity = 50021;
    public bool redRockPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        redRockPool_itemOperator_col.enabled = active;
        redRockPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool redRockPool_itemOperator_SetColliderActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        redRockPool_itemOperator_col.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    //[SerializeField]int capacity=300000;
    void redRockPool_itemOperator_Start()
    {
    //idToColDict.SetCapacity(capacity);
    //idToMeshDict.SetCapacity(capacity);
    }

    //[SerializeField,UnrollAttribute]IntToBoxColliderDictionary idToColDict;
    //[SerializeField,UnrollAttribute]IntToMeshRendererDictionary idToMeshDict;
    BoxCollider redRockPool_itemOperator_col;
    MeshRenderer redRockPool_itemOperator_mesh;
    public bool redRockPool_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        redRockPool_itemOperator_col = obj.GetComponent<BoxCollider>();
        redRockPool_itemOperator_mesh = obj.GetComponent<MeshRenderer>();
        redRockPool_itemOperator_col.enabled = active;
        redRockPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool redRockPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (redRockPool_itemOperator_col == null || redRockPool_itemOperator_mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return redRockPool_itemOperator_col.enabled && redRockPool_itemOperator_mesh.enabled;
    }

    int redRockPool_poolSize;
    private int[] redRockPool_notActiveObjQueue__array;
    private int redRockPool_notActiveObjQueue__head; // First valid element in the queue.
    private int redRockPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int redRockPool_notActiveObjQueue__size; // Number of elements.
    private int redRockPool_notActiveObjQueue__version;
    private const int redRockPool_notActiveObjQueue_MinimumGrow = 100000;
    public int redRockPool_notActiveObjQueue_Count => redRockPool_notActiveObjQueue__size;
    public int redRockPool_notActiveObjQueue_Version => redRockPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int redRockPool_notActiveObjQueue_GetCount() => redRockPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int redRockPool_notActiveObjQueue_GetVersion() => redRockPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void redRockPool_notActiveObjQueue_Clear()
    {
        redRockPool_notActiveObjQueue__size = 0;
        redRockPool_notActiveObjQueue__head = 0;
        redRockPool_notActiveObjQueue__tail = 0;
        redRockPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void redRockPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < redRockPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = redRockPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = redRockPool_notActiveObjQueue__array.Length - redRockPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(redRockPool_notActiveObjQueue__array, redRockPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(redRockPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void redRockPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (redRockPool_notActiveObjQueue__array == null)
        {
            redRockPool_notActiveObjQueue_SetCapacity(redRockPool_notActiveObjQueue_MinimumGrow);
        }
        else if (redRockPool_notActiveObjQueue__size == redRockPool_notActiveObjQueue__array.Length)
        {
            redRockPool_notActiveObjQueue_SetCapacity(redRockPool_notActiveObjQueue__array.Length + redRockPool_notActiveObjQueue_MinimumGrow);
        }

        redRockPool_notActiveObjQueue__array[redRockPool_notActiveObjQueue__tail] = obj;
        redRockPool_notActiveObjQueue__tail = (redRockPool_notActiveObjQueue__tail + 1) % redRockPool_notActiveObjQueue__array.Length;
        redRockPool_notActiveObjQueue__size++;
        redRockPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int redRockPool_notActiveObjQueue_Dequeue()
    {
        if (redRockPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = redRockPool_notActiveObjQueue__array[redRockPool_notActiveObjQueue__head];
        redRockPool_notActiveObjQueue__array[redRockPool_notActiveObjQueue__head] = int.MaxValue;
        redRockPool_notActiveObjQueue__head = (redRockPool_notActiveObjQueue__head + 1) % redRockPool_notActiveObjQueue__array.Length;
        redRockPool_notActiveObjQueue__size--;
        redRockPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int redRockPool_notActiveObjQueue_Peek()
    {
        if (redRockPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return redRockPool_notActiveObjQueue__array[redRockPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] redRockPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[redRockPool_notActiveObjQueue__size];
        if (redRockPool_notActiveObjQueue__size == 0)
        {
        }
        else if (redRockPool_notActiveObjQueue__head < redRockPool_notActiveObjQueue__tail)
        {
            Array.Copy(redRockPool_notActiveObjQueue__array, redRockPool_notActiveObjQueue__head, arr, 0, redRockPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = redRockPool_notActiveObjQueue__array.Length - redRockPool_notActiveObjQueue__head;
            Array.Copy(redRockPool_notActiveObjQueue__array, redRockPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(redRockPool_notActiveObjQueue__array, 0, arr, toHead, redRockPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void redRockPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (redRockPool_notActiveObjQueue__size == 0)
        {
        }
        else if (redRockPool_notActiveObjQueue__head < redRockPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(redRockPool_notActiveObjQueue__array, redRockPool_notActiveObjQueue__head, newArray, 0, redRockPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = redRockPool_notActiveObjQueue__array.Length - redRockPool_notActiveObjQueue__head;
            Array.Copy(redRockPool_notActiveObjQueue__array, redRockPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(redRockPool_notActiveObjQueue__array, 0, newArray, toHead, redRockPool_notActiveObjQueue__tail);
        }

        redRockPool_notActiveObjQueue__array = newArray;
        redRockPool_notActiveObjQueue__head = 0;
        redRockPool_notActiveObjQueue__tail = redRockPool_notActiveObjQueue__size == capacity ? 0 : redRockPool_notActiveObjQueue__size;
        redRockPool_notActiveObjQueue__version++;
    }

    //[SerializeField]Transform parent;
    void redRockPool_Start()
    {
        redRockPool_itemOperator_Start();
        redRockPool_idToObjDict_SetCapacity(redRockPool_Capacity);
        redRockPool_notActiveObjQueue_SetCapacity(redRockPool_Capacity);
    }

    public bool redRockPool_PeekIsInstantiated()
    {
        return redRockPool_isInstantiated;
    }

    bool redRockPool_isInstantiated = false;
    public void redRockPool_Store(Transform p = null)
    {
        if (redRockPool_idToObjDict_Count > redRockPool_idToObjDict_KeyLength)
            return;
        redRockPool_isInstantiated = true;
        GameObject instance;
        int id;
        redRockPool_instance = GameObject.Instantiate(redRockPool_prefab);
        //gc alloc debug only
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        //id = GetInstanceID(instance);/*instance.GetInstanceID();*///.GetHashCode();
        id = redRockPool_instance.GetInstanceID();
        redRockPool_itemOperator_SetActive(redRockPool_instance, id, false);
        redRockPool_idToObjDict_Add(id, redRockPool_instance);
        redRockPool_notActiveObjQueue_Enqueue(id);
    }

    GameObject redRockPool_instance;
    // falseで出してmeshcombinerで切り替える
    int redRockPool_uniqueId = 0;
    public GameObject redRockPool_TryToSpawn()
    {
        int id;
        redRockPool_isInstantiated = true;
        if (redRockPool_notActiveObjQueue_Count > 0)
        {
            redRockPool_isInstantiated = false;
            id = redRockPool_notActiveObjQueue_Dequeue();
            if (redRockPool_idToObjDict_HasItem(id))
            {
                var obj = redRockPool_idToObjDict_GetValue(id);
                //itemOperator.SetActive(obj,id,true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        redRockPool_instance = GameObject.Instantiate(redRockPool_prefab);
        //gc alloc
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        id = redRockPool_instance.GetInstanceID();
        redRockPool_idToObjDict_Add(id, redRockPool_instance); // gc alloc
        //itemOperator.SetActive(instance,id,true);
        //}while(!idToObjDict.Add(id,instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return redRockPool_instance;
    }

    public GameObject redRockPool_TryToSpawn(int id)
    {
        redRockPool_isInstantiated = false;
        if (redRockPool_idToObjDict_HasItem(id))
        {
            var obj = redRockPool_idToObjDict_GetValue(id);
            redRockPool_itemOperator_SetActive(obj, id, false);
            return obj;
        }
        else
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return null;
        }
    }

    public void redRockPool_Return(GameObject obj, bool force = false, bool enqueue = true)
    {
        // gc alloc debug only
        //if(obj==null)return; // gc alloc debug only
        int id = obj.GetInstanceID(); //obj.GetInstanceID();
        if (!redRockPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        redRockPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            redRockPool_notActiveObjQueue_Enqueue(id);
    }

    public void redRockPool_Return(GameObject obj, int id, bool force = false, bool enqueue = true)
    {
        //if(obj==null)return; // gc alloc debug only
        if (!redRockPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        redRockPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            redRockPool_notActiveObjQueue_Enqueue(id);
    }

    public bool redRockPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(redRockPool_prefab.name);
    }

    public void redRockPool_Clear()
    {
        redRockPool_notActiveObjQueue_Clear();
        foreach (var obj in redRockPool_idToObjDict_GenerateKeysArray())
        {
            redRockPool_itemOperator_SetActive(redRockPool_idToObjDict_GetValue(obj), false);
            redRockPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    public int settings_chunkSize = 3;
    public int settings_chunkSizeY = 3;
    public int settings_batchCount = 1000;
    public int settings_chunkWidth = 100;
    public int settings_chunkDepth = 100;
    public int settings_fieldHeight = 3;
    public float settings_scale = 0.015f;
    public float settings_scaleT = 0.003f;
    public float settings_scaleH = 0.003f;
    public float settings_cellAnimationTime = 1f;
    public float settings_TileScale = 1.5f;
    public float settings_chunkLoadRange = 6f;
    public float settings_chunkUnLoadRange = 12f;
    public float settings_chunkDetailRange = 1f;
    public float settings_generateAdditionalInterval = 5f;
    public float settings_searchAdditionalInterval = 3f;
    public float settings_removeBatchCount = 100;
    public float settings_removeInterval = 0.1f;
    public float settings_waterPercentage = 0.2f;
    public int settings_operationBatchCount = 1;
    public int settings_searchBatchCount = 30;
    public bool settings_removeOn = true;
    public bool settings_searchOn = true;
    Biome[][] biomeEarthMap = new Biome[][]
    {
        new Biome[]
        {
            Biome.Dirt,
            Biome.Dirt,
            Biome.Dark,
            Biome.Dark,
            Biome.Rock
        },
        new Biome[]
        {
            Biome.Dirt,
            Biome.Dirt,
            Biome.Dark,
            Biome.Grass,
            Biome.Rock
        },
        new Biome[]
        {
            Biome.Tundra,
            Biome.Dark,
            Biome.Grass,
            Biome.Rock,
            Biome.Sand
        },
        new Biome[]
        {
            Biome.Tundra,
            Biome.Grass,
            Biome.Rock,
            Biome.Desert,
            Biome.Sand
        },
        new Biome[]
        {
            Biome.Tundra,
            Biome.Grass,
            Biome.Desert,
            Biome.Desert,
            Biome.Sand
        },
    };
    Biome[][] biomeMoonMap = new Biome[][]
    {
        new Biome[]
        {
            Biome.Dark,
            Biome.Dark,
            Biome.Dark,
            Biome.Dark,
            Biome.Rock
        },
        new Biome[]
        {
            Biome.Dark,
            Biome.Rock,
            Biome.Rock,
            Biome.Rock,
            Biome.OrangeRock
        },
        new Biome[]
        {
            Biome.Rock,
            Biome.OrangeRock,
            Biome.OrangeRock,
            Biome.OrangeRock,
            Biome.Rock
        },
        new Biome[]
        {
            Biome.OrangeRock,
            Biome.Rock,
            Biome.Rock,
            Biome.Rock,
            Biome.Sand
        },
        new Biome[]
        {
            Biome.Rock,
            Biome.Sand,
            Biome.Sand,
            Biome.Sand,
            Biome.Sand
        },
    };
    Biome[][] biomeMarsMap = new Biome[][]
    {
        new Biome[]
        {
            Biome.Rock,
            Biome.Rock,
            Biome.Rock,
            Biome.RedRock,
            Biome.RedRock
        },
        new Biome[]
        {
            Biome.Rock,
            Biome.RedRock,
            Biome.RedRock,
            Biome.RedRock,
            Biome.OrangeRock
        },
        new Biome[]
        {
            Biome.RedRock,
            Biome.RedRock,
            Biome.RedRock,
            Biome.OrangeRock,
            Biome.OrangeRock
        },
        new Biome[]
        {
            Biome.RedRock,
            Biome.RedRock,
            Biome.OrangeRock,
            Biome.OrangeRock,
            Biome.Sand
        },
        new Biome[]
        {
            Biome.OrangeRock,
            Biome.OrangeRock,
            Biome.Sand,
            Biome.Sand,
            Biome.Sand
        },
    };
    bool BiomePeekIsInstantiated(Biome biome)
    {
        switch (biome)
        {
            case Biome.Grass:
                return grassPool_PeekIsInstantiated();
            case Biome.Tundra:
                return tundraPool_PeekIsInstantiated();
            case Biome.Desert:
                return desertPool_PeekIsInstantiated();
            case Biome.Rock:
                return rockPool_PeekIsInstantiated();
            case Biome.Sand:
                return sandPool_PeekIsInstantiated();
            case Biome.Water:
                return waterPool_PeekIsInstantiated();
            case Biome.Dirt:
                return dirtPool_PeekIsInstantiated();
            case Biome.Dark:
                return darkPool_PeekIsInstantiated();
            case Biome.OrangeRock:
                return orangeRockPool_PeekIsInstantiated();
            case Biome.RedRock:
                return redRockPool_PeekIsInstantiated();
            default:
                Debug.LogError("Invalid biome: " + biome);
                return false;
        }
    }

    GameObject BiomeTryToSpawn(Biome biome)
    {
        switch (biome)
        {
            case Biome.Grass:
                return grassPool_TryToSpawn();
            case Biome.Tundra:
                return tundraPool_TryToSpawn();
            case Biome.Desert:
                return desertPool_TryToSpawn();
            case Biome.Rock:
                return rockPool_TryToSpawn();
            case Biome.Sand:
                return sandPool_TryToSpawn();
            case Biome.Water:
                return waterPool_TryToSpawn();
            case Biome.Dirt:
                return dirtPool_TryToSpawn();
            case Biome.Dark:
                return darkPool_TryToSpawn();
            case Biome.OrangeRock:
                return orangeRockPool_TryToSpawn();
            case Biome.RedRock:
                return redRockPool_TryToSpawn();
            default:
                Debug.LogError("Invalid biome: " + biome);
                return null;
        }
    }

    void BiomeReturn(Biome biome, GameObject cell, int id)
    {
        switch (biome)
        {
            case Biome.Grass:
                grassPool_Return(cell, id);
                return;
            case Biome.Tundra:
                tundraPool_Return(cell, id);
                return;
            case Biome.Desert:
                desertPool_Return(cell, id);
                return;
            case Biome.Rock:
                rockPool_Return(cell, id);
                return;
            case Biome.Sand:
                sandPool_Return(cell, id);
                return;
            case Biome.Water:
                waterPool_Return(cell, id);
                return;
            case Biome.Dirt:
                dirtPool_Return(cell, id);
                return;
            case Biome.Dark:
                darkPool_Return(cell, id);
                return;
            case Biome.OrangeRock:
                orangeRockPool_Return(cell, id);
                return;
            case Biome.RedRock:
                redRockPool_Return(cell, id);
                return;
            default:
                Debug.LogError("Invalid biome: " + biome);
                return;
        }
    }

    void BiomeStore(int biomeIndex)
    {
        switch (biomeIndex)
        {
            case (int)Biome.Grass:
                grassPool_Store();
                return;
            case (int)Biome.Tundra:
                tundraPool_Store();
                return;
            case (int)Biome.Desert:
                desertPool_Store();
                return;
            case (int)Biome.Rock:
                rockPool_Store();
                return;
            case (int)Biome.Sand:
                sandPool_Store();
                return;
            case (int)Biome.Water:
                waterPool_Store();
                return;
            case (int)Biome.Dirt:
                dirtPool_Store();
                return;
            case (int)Biome.Dark:
                darkPool_Store();
                return;
            case (int)Biome.OrangeRock:
                orangeRockPool_Store();
                return;
            case (int)Biome.RedRock:
                redRockPool_Store();
                return;
            default:
                Debug.LogError("Invalid biome: " + biomeIndex);
                return;
        }
    }

    bool BiomePeekIsInstantiated(int biomeIndex)
    {
        switch (biomeIndex)
        {
            case (int)Biome.Grass:
                return grassPool_PeekIsInstantiated();
            case (int)Biome.Tundra:
                return tundraPool_PeekIsInstantiated();
            case (int)Biome.Desert:
                return desertPool_PeekIsInstantiated();
            case (int)Biome.Rock:
                return rockPool_PeekIsInstantiated();
            case (int)Biome.Sand:
                return sandPool_PeekIsInstantiated();
            case (int)Biome.Water:
                return waterPool_PeekIsInstantiated();
            case (int)Biome.Dirt:
                return dirtPool_PeekIsInstantiated();
            case (int)Biome.Dark:
                return darkPool_PeekIsInstantiated();
            case (int)Biome.OrangeRock:
                return orangeRockPool_PeekIsInstantiated();
            case (int)Biome.RedRock:
                return redRockPool_PeekIsInstantiated();
            default:
                Debug.LogError("Invalid biome: " + biomeIndex);
                return false;
        }
    }

    int chunkSize => settings_chunkSize;

    int chunkSizeY => settings_chunkSizeY;

    int chunkWidth => settings_chunkWidth;

    int chunkDepth => settings_chunkDepth;

    int fieldHeight => settings_fieldHeight;

    int xStartChunkIndex, zStartChunkIndex;
    int xEndChunkIndex, zEndChunkIndex;
    int xSearchStartChunkIndex, zSearchStartChunkIndex;
    int xSearchEndChunkIndex, zSearchEndChunkIndex;
    int xQuickSearchStartChunkIndex, zQuickSearchStartChunkIndex;
    int xQuickSearchEndChunkIndex, zQuickSearchEndChunkIndex;
    int batchCount => settings_batchCount;

    float chunkLoadRange => settings_chunkLoadRange;

    float generateAdditionalInterval => settings_generateAdditionalInterval * 2.5f / Networking.LocalPlayer.GetWalkSpeed();

    float cellAnimationTime => settings_cellAnimationTime;

    float removeBatchCount => settings_removeBatchCount;

    float removeInterval => settings_removeInterval;

    float waterPercentage;
    float chunkUnLoadRange => settings_chunkUnLoadRange;

    float chunkDetailRange => settings_chunkDetailRange;

    float operationBatchCount => settings_operationBatchCount;

    [SerializeField]
    int chunkCapacity = 15000;
    public override void OnDeserialization()
    {
        Debug.Log("OnDeserialization: MapGenerator");
        isSyncedLocal = true;
    }

    bool isSyncedLocal = false;
    [UdonSynced]
    bool isSynced = false;
    void Assert(bool b)
    {
        if (!b)
        {
            Debug.LogError("Assertion failed!");
        }
    }

    int[] detailChunkCellInstanceIds;
    int[][] chunkOperationDictionary__keys;
    ChunkOperation[][] chunkOperationDictionary__values;
    int chunkOperationDictionary__size;
    public int chunkOperationDictionary_Count => chunkOperationDictionary__size;

    const int chunkOperationDictionary_bucketCount = 1;
    public void chunkOperationDictionary_SetCapacity(int capacity)
    {
        int len = capacity / chunkOperationDictionary_bucketCount;
        chunkOperationDictionary__keys = new int[len][];
        for (int i = 0; i < chunkOperationDictionary__keys.Length; i++)
        {
            chunkOperationDictionary__keys[i] = new int[chunkOperationDictionary_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < chunkOperationDictionary_bucketCount; i++)
        {
            chunkOperationDictionary__keys[0][i] = int.MaxValue;
        }

        chunkOperationDictionary__values = new ChunkOperation[len][];
        for (int i = 0; i < chunkOperationDictionary__values.Length; i++)
        {
            chunkOperationDictionary__values[i] = new ChunkOperation[chunkOperationDictionary_bucketCount];
        }
    }

    public bool chunkOperationDictionary_HasItem(int key)
    {
        var index = chunkOperationDictionary_Hash(key);
        var hashKeys = chunkOperationDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int chunkOperationDictionary_Hash(int key)
    {
        var len = chunkOperationDictionary__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public int[] chunkOperationDictionary_GenerateKeysArray()
    {
        int[] keys = new int[chunkOperationDictionary__size];
        int index = 0;
        for (int i = 0; i < chunkOperationDictionary__keys.Length; i++)
        {
            var hashKeys = chunkOperationDictionary__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    public bool chunkOperationDictionary_Add(int key, ChunkOperation value)
    {
        int index = chunkOperationDictionary_Hash(key);
        var hashKeys = chunkOperationDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyChunkOperationArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkOperationDictionary__keys[index][i] = key;
                    chunkOperationDictionary__values[index][i] = value;
                    chunkOperationDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyChunkOperationArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    chunkOperationDictionary__keys[index][i] = key;
                    chunkOperationDictionary__values[index][i] = value;
                    chunkOperationDictionary__size++;
                    return true;
                }
            }
        }

        var preLen = hashKeys.Length;
        chunkOperationDictionary_ExpandList(index);
        chunkOperationDictionary__keys[index][preLen] = key;
        chunkOperationDictionary__values[index][preLen] = value;
        chunkOperationDictionary__size++;
        return true;
    }

    const int chunkOperationDictionary_expand = 5;
    void chunkOperationDictionary_ExpandList(int index)
    {
        var hashKeys = chunkOperationDictionary__keys[index];
        var hashValues = chunkOperationDictionary__values[index];
        var len = chunkOperationDictionary__keys[index].Length + chunkOperationDictionary_expand;
        var newKeys = new int[len];
        var newValues = new ChunkOperation[len];
        for (int i = 0; i < chunkOperationDictionary__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = chunkOperationDictionary__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        chunkOperationDictionary__keys[index] = newKeys;
        chunkOperationDictionary__values[index] = newValues;
    }

    public void chunkOperationDictionary_AddOrSetValue(int key, ChunkOperation value)
    {
        int index = chunkOperationDictionary_Hash(key);
        var hashKeys = chunkOperationDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkOperationDictionary__keys[index][i] = key;
                    chunkOperationDictionary__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkOperationDictionary__keys[index][i] = key;
                    chunkOperationDictionary__values[index][i] = value;
                    chunkOperationDictionary__size++;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkOperationDictionary__keys[index][i] = key;
                    chunkOperationDictionary__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == default)
                {
                    chunkOperationDictionary__keys[index][i] = key;
                    chunkOperationDictionary__values[index][i] = value;
                    chunkOperationDictionary__size++;
                    return;
                }
            }
        }

        var preLen = hashKeys.Length;
        chunkOperationDictionary_ExpandList(index);
        chunkOperationDictionary__keys[index][preLen] = key;
        chunkOperationDictionary__values[index][preLen] = value;
        chunkOperationDictionary__size++;
    }

    public void chunkOperationDictionary_SetValue(int key, ChunkOperation value)
    {
        int index = chunkOperationDictionary_Hash(key);
        var hashKeys = chunkOperationDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkOperationDictionary__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkOperationDictionary__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public ChunkOperation chunkOperationDictionary_GetValueOrDefault(int key, ChunkOperation defaultValue)
    {
        int index = chunkOperationDictionary_Hash(key);
        var hashKeys = chunkOperationDictionary__keys[index];
        var hashValues = chunkOperationDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return defaultValue;
    }

    public ChunkOperation chunkOperationDictionary_GetValue(int key)
    {
        int index = chunkOperationDictionary_Hash(key);
        var hashKeys = chunkOperationDictionary__keys[index];
        var hashValues = chunkOperationDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void chunkOperationDictionary_Remove(int key)
    {
        int index = chunkOperationDictionary_Hash(key);
        var hashKeys = chunkOperationDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    chunkOperationDictionary__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    chunkOperationDictionary__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    int[][] chunkIndexToInstanceIdDictionary__keys;
    int[][] chunkIndexToInstanceIdDictionary__values;
    int chunkIndexToInstanceIdDictionary__size;
    public int chunkIndexToInstanceIdDictionary_Count => chunkIndexToInstanceIdDictionary__size;

    const int chunkIndexToInstanceIdDictionary_bucketCount = 1;
    public void chunkIndexToInstanceIdDictionary_SetCapacity(int capacity)
    {
        int len = capacity / chunkIndexToInstanceIdDictionary_bucketCount;
        chunkIndexToInstanceIdDictionary__keys = new int[len][];
        for (int i = 0; i < chunkIndexToInstanceIdDictionary__keys.Length; i++)
        {
            chunkIndexToInstanceIdDictionary__keys[i] = new int[chunkIndexToInstanceIdDictionary_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < chunkIndexToInstanceIdDictionary_bucketCount; i++)
        {
            chunkIndexToInstanceIdDictionary__keys[0][i] = int.MaxValue;
        }

        chunkIndexToInstanceIdDictionary__values = new int[len][];
        for (int i = 0; i < chunkIndexToInstanceIdDictionary__values.Length; i++)
        {
            chunkIndexToInstanceIdDictionary__values[i] = new int[chunkIndexToInstanceIdDictionary_bucketCount];
        }
    }

    public bool chunkIndexToInstanceIdDictionary_HasItem(int key)
    {
        var index = chunkIndexToInstanceIdDictionary_Hash(key);
        var hashKeys = chunkIndexToInstanceIdDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int chunkIndexToInstanceIdDictionary_Hash(int key)
    {
        var len = chunkIndexToInstanceIdDictionary__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public int[] chunkIndexToInstanceIdDictionary_GenerateKeysArray()
    {
        int[] keys = new int[chunkIndexToInstanceIdDictionary__size];
        int index = 0;
        for (int i = 0; i < chunkIndexToInstanceIdDictionary__keys.Length; i++)
        {
            var hashKeys = chunkIndexToInstanceIdDictionary__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    public bool chunkIndexToInstanceIdDictionary_Add(int key, int value)
    {
        int index = chunkIndexToInstanceIdDictionary_Hash(key);
        var hashKeys = chunkIndexToInstanceIdDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyintDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkIndexToInstanceIdDictionary__keys[index][i] = key;
                    chunkIndexToInstanceIdDictionary__values[index][i] = value;
                    chunkIndexToInstanceIdDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyintDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    chunkIndexToInstanceIdDictionary__keys[index][i] = key;
                    chunkIndexToInstanceIdDictionary__values[index][i] = value;
                    chunkIndexToInstanceIdDictionary__size++;
                    return true;
                }
            }
        }

        var preLen = hashKeys.Length;
        chunkIndexToInstanceIdDictionary_ExpandList(index);
        chunkIndexToInstanceIdDictionary__keys[index][preLen] = key;
        chunkIndexToInstanceIdDictionary__values[index][preLen] = value;
        chunkIndexToInstanceIdDictionary__size++;
        return true;
    }

    const int chunkIndexToInstanceIdDictionary_expand = 5;
    void chunkIndexToInstanceIdDictionary_ExpandList(int index)
    {
        var hashKeys = chunkIndexToInstanceIdDictionary__keys[index];
        var hashValues = chunkIndexToInstanceIdDictionary__values[index];
        var len = chunkIndexToInstanceIdDictionary__keys[index].Length + chunkIndexToInstanceIdDictionary_expand;
        var newKeys = new int[len];
        var newValues = new int[len];
        for (int i = 0; i < chunkIndexToInstanceIdDictionary__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = chunkIndexToInstanceIdDictionary__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        chunkIndexToInstanceIdDictionary__keys[index] = newKeys;
        chunkIndexToInstanceIdDictionary__values[index] = newValues;
    }

    public void chunkIndexToInstanceIdDictionary_AddOrSetValue(int key, int value)
    {
        int index = chunkIndexToInstanceIdDictionary_Hash(key);
        var hashKeys = chunkIndexToInstanceIdDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkIndexToInstanceIdDictionary__keys[index][i] = key;
                    chunkIndexToInstanceIdDictionary__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkIndexToInstanceIdDictionary__keys[index][i] = key;
                    chunkIndexToInstanceIdDictionary__values[index][i] = value;
                    chunkIndexToInstanceIdDictionary__size++;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkIndexToInstanceIdDictionary__keys[index][i] = key;
                    chunkIndexToInstanceIdDictionary__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == default)
                {
                    chunkIndexToInstanceIdDictionary__keys[index][i] = key;
                    chunkIndexToInstanceIdDictionary__values[index][i] = value;
                    chunkIndexToInstanceIdDictionary__size++;
                    return;
                }
            }
        }

        var preLen = hashKeys.Length;
        chunkIndexToInstanceIdDictionary_ExpandList(index);
        chunkIndexToInstanceIdDictionary__keys[index][preLen] = key;
        chunkIndexToInstanceIdDictionary__values[index][preLen] = value;
        chunkIndexToInstanceIdDictionary__size++;
    }

    public void chunkIndexToInstanceIdDictionary_SetValue(int key, int value)
    {
        int index = chunkIndexToInstanceIdDictionary_Hash(key);
        var hashKeys = chunkIndexToInstanceIdDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkIndexToInstanceIdDictionary__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkIndexToInstanceIdDictionary__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public int chunkIndexToInstanceIdDictionary_GetValue(int key)
    {
        int index = chunkIndexToInstanceIdDictionary_Hash(key);
        var hashKeys = chunkIndexToInstanceIdDictionary__keys[index];
        var hashValues = chunkIndexToInstanceIdDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public int chunkIndexToInstanceIdDictionary_GetValueOrDefault(int key, int defaultValue)
    {
        int index = chunkIndexToInstanceIdDictionary_Hash(key);
        var hashKeys = chunkIndexToInstanceIdDictionary__keys[index];
        var hashValues = chunkIndexToInstanceIdDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return defaultValue;
    }

    public void chunkIndexToInstanceIdDictionary_Remove(int key)
    {
        if (chunkIndexToInstanceIdDictionary_TryRemove(key))
            return;
        Debug.LogError("Key not found");
    }

    public bool chunkIndexToInstanceIdDictionary_TryRemove(int key)
    {
        int index = chunkIndexToInstanceIdDictionary_Hash(key);
        var hashKeys = chunkIndexToInstanceIdDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    chunkIndexToInstanceIdDictionary__size--;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    chunkIndexToInstanceIdDictionary__size--;
                    return true;
                }
            }
        }

        return false;
    }

    int[] permanentBreakCellArr;
    void Start()
    {
        chunkPool_Start();
        meshCombiner_Start();
        redRockPool_Start();
        orangeRockPool_Start();
        darkPool_Start();
        waterPool_Start();
        sandPool_Start();
        rockPool_Start();
        dirtPool_Start();
        desertPool_Start();
        tundraPool_Start();
        grassPool_Start();
        waterPercentage = settings_waterPercentage;
        outlineDict_SetCapacity(chunkCapacity);
        chunkToCellsDict_SetCapacity(chunkCapacity);
        chunkStateDict_SetCapacity(chunkCapacity);
        instanceIDToGlobalCellIndexDictionary_SetCapacity(20011);
        undetailQueue_SetCapacity(chunkCapacity);
        detailQueue_SetCapacity(chunkCapacity);
        priorityDetailQueue_SetCapacity(chunkCapacity);
        unloadQueue_SetCapacity(chunkCapacity);
        chunkIndexToCellBiomesDictionary_SetCapacity(chunkCapacity);
        chunkToCellInstanceIdsDictionary_SetCapacity(chunkCapacity);
        permanentBreakCellDictionary_SetCapacity(chunkCapacity);
        permanentBreakCellArr = new int[20011];
        chunkIndexToInstanceIdDictionary_SetCapacity(chunkCapacity);
        chunkOperationDictionary_SetCapacity(chunkCapacity);
        instanceIDToBiomeDictionary_SetCapacity(20011);
        brokenArr = new bool[chunkSize * chunkSize * chunkSizeY];
        colOnlyArr = new bool[chunkSize * chunkSize * chunkSizeY];
        MapSync();
        SendCustomEventDelayedSeconds(nameof(ReqSync), 5f);
        SendCustomEventDelayedSeconds(nameof(ReqSync), 10f);
        /*chunkWidth=settings.chunkWidth;
        chunkDepth=settings.chunkDepth;
        chunkSize=settings.chunkSize;
        batchCount=settings.batchCount;
        generateInterval=settings.generateInterval;
        chunkLoadRange=settings.chunkLoadRange;
        generateAdditionalInterval=settings.generateAdditionalInterval *2.5f / Networking.LocalPlayer.GetWalkSpeed();
        cellAnimationTime=settings.cellAnimationTime;*/
        meshFilters = new MeshFilter[chunkSize * chunkSize * chunkSizeY];
        detailChunkCellInstanceIds = new int[chunkSize * chunkSize * chunkSizeY];
        XSTARTINDEX = -chunkWidth / 2;
        XENDINDEX = chunkWidth - 1 - chunkWidth / 2;
        ZSTARTINDEX = 0;
        ZENDINDEX = chunkDepth;
        QuickSearchInterval();
    }

    [SerializeField]
    float quickSearchInterval = 0.5f;
    public void QuickSearchInterval()
    {
        if (IsStart)
        {
            QuickSearch();
        }

        SendCustomEventDelayedSeconds(nameof(QuickSearchInterval), quickSearchInterval);
    }

    int[][] chunkToCellInstanceIdsDictionary__keys;
    int[][][] chunkToCellInstanceIdsDictionary__values;
    int chunkToCellInstanceIdsDictionary__size;
    public int chunkToCellInstanceIdsDictionary_Count => chunkToCellInstanceIdsDictionary__size;

    const int chunkToCellInstanceIdsDictionary_bucketCount = 1;
    public void chunkToCellInstanceIdsDictionary_SetCapacity(int capacity)
    {
        int len = capacity / chunkToCellInstanceIdsDictionary_bucketCount;
        chunkToCellInstanceIdsDictionary__keys = new int[len][];
        for (int i = 0; i < chunkToCellInstanceIdsDictionary__keys.Length; i++)
        {
            chunkToCellInstanceIdsDictionary__keys[i] = new int[chunkToCellInstanceIdsDictionary_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < chunkToCellInstanceIdsDictionary_bucketCount; i++)
        {
            chunkToCellInstanceIdsDictionary__keys[0][i] = int.MaxValue;
        }

        chunkToCellInstanceIdsDictionary__values = new int[len][][];
        for (int i = 0; i < chunkToCellInstanceIdsDictionary__values.Length; i++)
        {
            chunkToCellInstanceIdsDictionary__values[i] = new int[chunkToCellInstanceIdsDictionary_bucketCount][];
        }
    }

    public bool chunkToCellInstanceIdsDictionary_HasItem(int key)
    {
        var index = chunkToCellInstanceIdsDictionary_Hash(key);
        var hashKeys = chunkToCellInstanceIdsDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int chunkToCellInstanceIdsDictionary_Hash(int key)
    {
        var len = chunkToCellInstanceIdsDictionary__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public int[] chunkToCellInstanceIdsDictionary_GenerateKeysArray()
    {
        int[] keys = new int[chunkToCellInstanceIdsDictionary__size];
        int index = 0;
        for (int i = 0; i < chunkToCellInstanceIdsDictionary__keys.Length; i++)
        {
            var hashKeys = chunkToCellInstanceIdsDictionary__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    public bool chunkToCellInstanceIdsDictionary_Add(int key, int[] value)
    {
        int index = chunkToCellInstanceIdsDictionary_Hash(key);
        var hashKeys = chunkToCellInstanceIdsDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyintArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkToCellInstanceIdsDictionary__keys[index][i] = key;
                    chunkToCellInstanceIdsDictionary__values[index][i] = value;
                    chunkToCellInstanceIdsDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyintArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    chunkToCellInstanceIdsDictionary__keys[index][i] = key;
                    chunkToCellInstanceIdsDictionary__values[index][i] = value;
                    chunkToCellInstanceIdsDictionary__size++;
                    return true;
                }
            }
        }

        var preLen = hashKeys.Length;
        chunkToCellInstanceIdsDictionary_ExpandList(index);
        chunkToCellInstanceIdsDictionary__keys[index][preLen] = key;
        chunkToCellInstanceIdsDictionary__values[index][preLen] = value;
        chunkToCellInstanceIdsDictionary__size++;
        return true;
    }

    const int chunkToCellInstanceIdsDictionary_expand = 5;
    void chunkToCellInstanceIdsDictionary_ExpandList(int index)
    {
        var hashKeys = chunkToCellInstanceIdsDictionary__keys[index];
        var hashValues = chunkToCellInstanceIdsDictionary__values[index];
        var len = chunkToCellInstanceIdsDictionary__keys[index].Length + chunkToCellInstanceIdsDictionary_expand;
        var newKeys = new int[len];
        var newValues = new int[len][];
        for (int i = 0; i < chunkToCellInstanceIdsDictionary__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = chunkToCellInstanceIdsDictionary__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        chunkToCellInstanceIdsDictionary__keys[index] = newKeys;
        chunkToCellInstanceIdsDictionary__values[index] = newValues;
    }

    public void chunkToCellInstanceIdsDictionary_AddOrSetValue(int key, int[] value)
    {
        int index = chunkToCellInstanceIdsDictionary_Hash(key);
        var hashKeys = chunkToCellInstanceIdsDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkToCellInstanceIdsDictionary__keys[index][i] = key;
                    chunkToCellInstanceIdsDictionary__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkToCellInstanceIdsDictionary__keys[index][i] = key;
                    chunkToCellInstanceIdsDictionary__values[index][i] = value;
                    chunkToCellInstanceIdsDictionary__size++;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkToCellInstanceIdsDictionary__keys[index][i] = key;
                    chunkToCellInstanceIdsDictionary__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == default)
                {
                    chunkToCellInstanceIdsDictionary__keys[index][i] = key;
                    chunkToCellInstanceIdsDictionary__values[index][i] = value;
                    chunkToCellInstanceIdsDictionary__size++;
                    return;
                }
            }
        }

        var preLen = hashKeys.Length;
        chunkToCellInstanceIdsDictionary_ExpandList(index);
        chunkToCellInstanceIdsDictionary__keys[index][preLen] = key;
        chunkToCellInstanceIdsDictionary__values[index][preLen] = value;
        chunkToCellInstanceIdsDictionary__size++;
    }

    public void chunkToCellInstanceIdsDictionary_SetValue(int key, int[] value)
    {
        int index = chunkToCellInstanceIdsDictionary_Hash(key);
        var hashKeys = chunkToCellInstanceIdsDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkToCellInstanceIdsDictionary__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkToCellInstanceIdsDictionary__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public int[] chunkToCellInstanceIdsDictionary_GetValue(int key)
    {
        int index = chunkToCellInstanceIdsDictionary_Hash(key);
        var hashKeys = chunkToCellInstanceIdsDictionary__keys[index];
        var hashValues = chunkToCellInstanceIdsDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void chunkToCellInstanceIdsDictionary_Remove(int key)
    {
        int index = chunkToCellInstanceIdsDictionary_Hash(key);
        var hashKeys = chunkToCellInstanceIdsDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    chunkToCellInstanceIdsDictionary__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    chunkToCellInstanceIdsDictionary__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    int XSTARTINDEX, XENDINDEX, ZSTARTINDEX, ZENDINDEX;
    public void MapSync()
    {
        if (Networking.LocalPlayer.IsOwner(this.gameObject))
        {
            isSyncedLocal=true;
            isSynced = true;
            _seedX = UnityEngine.Random.value * (float)Int16.MaxValue;
            _seedZ = UnityEngine.Random.value * (float)Int16.MaxValue;
            _seedTX = UnityEngine.Random.value * (float)Int16.MaxValue;
            _seedTZ = UnityEngine.Random.value * (float)Int16.MaxValue;
            _seedHX = UnityEngine.Random.value * (float)Int16.MaxValue;
            _seedHZ = UnityEngine.Random.value * (float)Int16.MaxValue;
            RequestSerialization();
        } else {
            SendCustomEventDelayedSeconds(nameof(MakeSynced), 10);
        }
    }
    public void MakeSynced(){
        isSyncedLocal=true;
    }

    public void MakeNotSynced(){
        isSyncedLocal=false;
    }

    public void ReqSync(){
        RequestSerialization();
    }

    int[] unloadIndexes;
    int unloadIndexStart;
    public override void GameOver()
    {
        base.GameOver();
        gameOverPos = GetPlayerPosition();
        zClearStartChunkIndex = GetInRangeStartZChunkIndex(gameOverPos, chunkUnLoadRange + clearMargin);
        zClearEndChunkIndex = GetInRangeEndZChunkIndex(gameOverPos, chunkUnLoadRange + clearMargin);
        xClearStartChunkIndex = GetInRangeStartXChunkIndex(gameOverPos, zClearStartChunkIndex, chunkUnLoadRange + clearMargin);
        xClearEndChunkIndex = GetInRangeEndXChunkIndex(gameOverPos, zClearStartChunkIndex, chunkUnLoadRange + clearMargin);
        unloadIndexes = chunkIndexToInstanceIdDictionary_GenerateKeysArray();
        unloadIndexStart = 0;
        isClearing = true;
        isPermanentCellsClearing = false;
        unloadQueue_Clear();
        detailQueue_Clear();
        undetailQueue_Clear();
        priorityDetailQueue_Clear();
        isGenerating = false;
        isSearching = false;
        SetGravity(9.8f);
        MapSync();
    }

    public override bool IsReadyToGameStart()
    {
        //Debug.Log("IsReadyToGameStart: "+base.IsReadyToGameStart() + " isSyncedLocal: "+isSyncedLocal+" isSynced: "+isSynced+" isSearching: "+isSearching+"_seedX: "+_seedX);
        return base.IsReadyToGameStart() && !isClearing && !isPermanentCellsClearing && !isGenerating && isSyncedLocal && !isSearching;
        ;
    }

    Vector3 gameOverPos;
    bool isClearing = false;
    Mission mission;
    public override void GameStart(Mission mission)
    {
        base.GameStart(mission);
        this.mission = mission;
        isSyncedLocal=false;
        SendCustomEventDelayedSeconds(nameof(MakeNotSynced), 20);
        waterPercentage = mission.WaterPercentage;
        SetGravity(mission.Gravity);
        //GenerateInitCellInterval();
        GenerateAdditional();
        SearchAdditional();
    //RemoveChunkInterval();
    }

    float searchAdditionalInterval => settings_searchAdditionalInterval;

    Vector3 posCorrection = Vector3.zero;
    Vector3 GetPlayerPosition()
    {
        return Networking.LocalPlayer.GetPosition() / (chunkSize * TileScale);
    }

    float baseGravity;
    public override float Gravity => baseGravity;

    public override void SetGravity(float gravity)
    {
        Physics.gravity = Vector3.down * gravity;
        baseGravity = gravity;
    }

    void CalcPosCorrection()
    {
        playerRot = Networking.LocalPlayer.GetTrackingData(VRCPlayerApi.TrackingDataType.Head).rotation;
        // 極座標へ変換
        float r = 2.5f; // 半径は通常1とするか、必要に応じて変更
        var rad = Mathf.PI / 2 - playerRot.eulerAngles.y * Mathf.Deg2Rad;
        posCorrection.x = Mathf.Cos(rad) * r;
        posCorrection.z = Mathf.Sin(rad) * r;
    //Debug.Log("posCorrection: "+posCorrection);
    }

    void GenerateAdditional()
    {
        if (isGenerating || !IsStart)
            return;
        prePlayerPos = playerPos;
        playerPos = GetPlayerPosition(); //Networking.LocalPlayer.GetPosition() / (chunkSize*TileScale);
        CalcPosCorrection();
        chunkXIndex = 0;
        chunkZIndex = 0;
        chunkYIndex = 0;
        //Debug.Log("GenerateAdditional");
        //Debug.Log("player pos: "+playerPos);
        zStartChunkIndex = GetInRangeStartZChunkIndex(playerPos + posCorrection, chunkLoadRange);
        zEndChunkIndex = GetInRangeEndZChunkIndex(playerPos + posCorrection, chunkLoadRange);
        xStartChunkIndex = GetInRangeStartXChunkIndex(playerPos + posCorrection, zStartChunkIndex, chunkLoadRange); //-1;
        xEndChunkIndex = GetInRangeEndXChunkIndex(playerPos + posCorrection, zStartChunkIndex, chunkLoadRange); //-1;
        //exceptXStartChunkIndex=GetInRangeStartXChunkIndex(prePlayerPos+posCorrection,zStartChunkIndex,chunkLoadRange);
        //exceptXEndChunkIndex=GetInRangeEndXChunkIndex(prePlayerPos+posCorrection,zStartChunkIndex,chunkLoadRange);
        isGenerating = true;
    //GenerateCellInterval();
    }

    public override void GenerateOnSpawn()
    {
        if (!IsStart)
            return;
        prePlayerPos = playerPos;
        playerPos = playerSpawnPos.position / (chunkSize * TileScale); //Networking.LocalPlayer.GetPosition() / (chunkSize*TileScale);
        CalcPosCorrection();
        chunkXIndex = 0;
        chunkZIndex = 0;
        chunkYIndex = 0;
        //Debug.Log("GenerateAdditional");
        //Debug.Log("player pos: "+playerPos);
        zStartChunkIndex = GetInRangeStartZChunkIndex(playerPos + posCorrection, chunkLoadRange);
        zEndChunkIndex = GetInRangeEndZChunkIndex(playerPos + posCorrection, chunkLoadRange);
        xStartChunkIndex = GetInRangeStartXChunkIndex(playerPos + posCorrection, zStartChunkIndex, chunkLoadRange); //-1;
        xEndChunkIndex = GetInRangeEndXChunkIndex(playerPos + posCorrection, zStartChunkIndex, chunkLoadRange); //-1;
        //exceptXStartChunkIndex=GetInRangeStartXChunkIndex(prePlayerPos+posCorrection,zStartChunkIndex,chunkLoadRange);
        //exceptXEndChunkIndex=GetInRangeEndXChunkIndex(prePlayerPos+posCorrection,zStartChunkIndex,chunkLoadRange);
        isGenerating = true;
    }

    void SearchAdditional()
    {
        if (searchOn)
        {
            if (!IsStart)
                return;
            if (isSearching)
            {
                Debug.LogWarning("already searching");
                return;
            }

            zSearchStartChunkIndex = GetInRangeStartZChunkIndex(playerPos, chunkUnLoadRange + searchMargin);
            ;
            zSearchEndChunkIndex = GetInRangeEndZChunkIndex(playerPos, chunkUnLoadRange + searchMargin);
            ;
            xSearchStartChunkIndex = GetInRangeStartXChunkIndex(playerPos, zSearchStartChunkIndex, chunkUnLoadRange + searchMargin);
            xSearchEndChunkIndex = GetInRangeEndXChunkIndex(playerPos, zSearchStartChunkIndex, chunkUnLoadRange + searchMargin);
            isSearching = true;
            researchFlag = false;
        }
    }

    Vector3 playerPos;
    Quaternion playerRot;
    Vector3 prePlayerPos;
    int GetInRangeStartXChunkIndex(Vector3 pos, float z, float range)
    {
        float diff = range * range - (pos.z - z) * (pos.z - z);
        if (diff <= 0)
            return chunkWidth / 2;
        return Math.Max(XSTARTINDEX, (int)(pos.x - Mathf.Sqrt(diff)));
    }

    int GetInRangeEndXChunkIndex(Vector3 pos, float z, float range)
    {
        float diff = Math.Max(0, range * range - (pos.z - z) * (pos.z - z));
        if (diff == 0)
            return -chunkWidth / 2;
        return Math.Min(XENDINDEX, (int)(pos.x + Mathf.Sqrt(diff)));
    }

    int GetInRangeStartZChunkIndex(Vector3 pos, float range)
    {
        return Math.Max(ZSTARTINDEX, (int)(pos.z - range));
    }

    int GetInRangeEndZChunkIndex(Vector3 pos, float range)
    {
        return Math.Min(ZENDINDEX, (int)(pos.z + range));
    }

    bool IsInDetailRange(Vector3 pPos, int x, int z)
    {
        return ((pPos.x - x) * (pPos.x - x) + (pPos.z - z) * (pPos.z - z)) < chunkDetailRange * chunkDetailRange;
    }

    int exceptXStartChunkIndex;
    int exceptXEndChunkIndex;
    int exceptZStartChunkIndex;
    int exceptZEndChunkIndex;
    bool isGenerating = false;
    int[][] outlineDict__keys;
    GameObject[][] outlineDict__values;
    int outlineDict__size;
    public int outlineDict_Count => outlineDict__size;

    public int[] outlineDict_GenerateKeysArray()
    {
        int[] keys = new int[outlineDict__size];
        int index = 0;
        for (int i = 0; i < outlineDict__keys.Length; i++)
        {
            var hashKeys = outlineDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int outlineDict_bucketCount = 1;
    public int outlineDict_KeyLength => outlineDict__keys.Length;

    public void outlineDict_SetCapacity(int capacity)
    {
        int len = capacity / outlineDict_bucketCount;
        outlineDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            outlineDict__keys[i] = new int[outlineDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < outlineDict_bucketCount; i++)
        {
            outlineDict__keys[0][i] = int.MaxValue;
        }

        outlineDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            outlineDict__values[i] = new GameObject[outlineDict_bucketCount];
        }
    }

    public bool outlineDict_HasItem(int key)
    {
        var index = outlineDict_Hash(key);
        var hashKeys = outlineDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int outlineDict_Hash(int key)
    {
        var len = outlineDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool outlineDict_Add(int key, GameObject value)
    {
        int index = outlineDict_Hash(key);
        var hashKeys = outlineDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    outlineDict__keys[index][i] = key;
                    outlineDict__values[index][i] = value;
                    outlineDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    outlineDict__keys[index][i] = key;
                    outlineDict__values[index][i] = value;
                    outlineDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        outlineDict_ExpandList(index);
        outlineDict__keys[index][preLen] = key;
        outlineDict__values[index][preLen] = value;
        outlineDict__size++;
        return true;
    }

    const int outlineDict_expand = 5;
    void outlineDict_ExpandList(int index)
    {
        var hashKeys = outlineDict__keys[index];
        var hashValues = outlineDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + outlineDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        outlineDict__keys[index] = newKeys;
        outlineDict__values[index] = newValues;
    }

    public bool outlineDict_AddOrSetValue(int key, GameObject value)
    {
        int index = outlineDict_Hash(key);
        var hashKeys = outlineDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    outlineDict__keys[index][i] = key;
                    outlineDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    outlineDict__keys[index][i] = key;
                    outlineDict__values[index][i] = value;
                    outlineDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    outlineDict__keys[index][i] = key;
                    outlineDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    outlineDict__keys[index][i] = key;
                    outlineDict__values[index][i] = value;
                    outlineDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        outlineDict_ExpandList(index);
        outlineDict__keys[index][preLen] = key;
        outlineDict__values[index][preLen] = value;
        outlineDict__size++;
        return true;
    }

    public void outlineDict_SetValue(int key, GameObject value)
    {
        int index = outlineDict_Hash(key);
        var hashKeys = outlineDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    outlineDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    outlineDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject outlineDict_GetValue(int key)
    {
        int index = outlineDict_Hash(key);
        var hashKeys = outlineDict__keys[index];
        var hashValues = outlineDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject outlineDict_TryGetValue(int key)
    {
        int index = outlineDict_Hash(key);
        var hashKeys = outlineDict__keys[index];
        var hashValues = outlineDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void outlineDict_Remove(int key)
    {
        int index = outlineDict_Hash(key);
        var hashKeys = outlineDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    outlineDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    outlineDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    float generateAdditionalDelta = -1f;
    float searchAdditionalDelta = -1f;
    [SerializeField]
    int isInstantiatedCost = 10;
    [SerializeField]
    int poolCost = 4;
    [SerializeField]
    int unloadCost = 6;
    int storeCount = 0;
    int storeMax = 3;
    int biomeIndex = 0;
    UdonSavingObjectPool storeBiomePool;
    void StoreCell()
    {
        BiomeStore(biomeIndex);
        isInstantiated = BiomePeekIsInstantiated(biomeIndex); //storeBiomePool.PeekIsInstantiated();
        biomeIndex++;
        biomeIndex %= (int)Biome.Dark;
    }

    int costIndex;
    GenerateChunkMode mode;
    bool researchFlag = false;
    public void RequestResearch()
    {
        researchFlag = true;
        QuickSearch();
    }

    [SerializeField]
    bool detailFlag = false;
    [SerializeField]
    bool undetailFlag = false;
    [SerializeField]
    bool unloadFlag = false;
    void QuickSearch()
    {
        if (searchOn)
        {
            var ppos = GetPlayerPosition();
            zQuickSearchStartChunkIndex = GetInRangeStartZChunkIndex(ppos, quickSearchRange);
            zQuickSearchEndChunkIndex = GetInRangeEndZChunkIndex(ppos, quickSearchRange);
            xQuickSearchStartChunkIndex = GetInRangeStartXChunkIndex(ppos, zQuickSearchStartChunkIndex, quickSearchRange);
            xQuickSearchEndChunkIndex = GetInRangeEndXChunkIndex(ppos, zQuickSearchStartChunkIndex, quickSearchRange);
            while (true)
            {
                if (!IsStart)
                    break;
                var x = xQuickSearchStartChunkIndex;
                var z = zQuickSearchStartChunkIndex;
                var chunkIndex = ToChunkIndex(x, z);
                if (chunkStateDict_IsUnDetailed(chunkIndex))
                {
                    var diffx = x - ppos.x;
                    var diffz = z - ppos.z;
                    var distance = diffx * diffx + diffz * diffz;
                    if (distance <= chunkDetailRange * chunkDetailRange)
                    {
                        chunkOperationDictionary_AddOrSetValue(chunkIndex, ChunkOperation.Detail);
                        priorityDetailQueue_Enqueue(chunkIndex);
                    }
                }

                xQuickSearchStartChunkIndex++;
                if (xQuickSearchStartChunkIndex > xQuickSearchEndChunkIndex)
                {
                    zQuickSearchStartChunkIndex++;
                    xQuickSearchStartChunkIndex = GetInRangeStartXChunkIndex(ppos, zQuickSearchStartChunkIndex, quickSearchRange);
                    xQuickSearchEndChunkIndex = GetInRangeEndXChunkIndex(ppos, zQuickSearchStartChunkIndex, quickSearchRange);
                    if (zQuickSearchStartChunkIndex >= zQuickSearchEndChunkIndex)
                    {
                        break;
                    }
                }
            }
        }
    }

    int xClearStartChunkIndex, zClearStartChunkIndex;
    int xClearEndChunkIndex, zClearEndChunkIndex;
    bool isPermanentCellsClearing = false;
    void Update()
    {
        if (!IsStart)
        {
            if (isClearing)
            {
                costIndex = 0;
                for (int i = 0; i < operationBatchCount; i++)
                {
                    UnLoadChunk(unloadIndexes[unloadIndexStart], true);
                    unloadIndexStart++;
                    if (unloadIndexStart == unloadIndexes.Length)
                    {
                        isClearing = false;
                        isPermanentCellsClearing = true;
                        break;
                    }
                /*var x=xClearStartChunkIndex;
                    var z=zClearStartChunkIndex;
                    var chunkIndex=ToChunkIndex(x,z);
                    if(chunkStateDict.IsLoaded(chunkIndex)){
                        UnLoadChunk(chunkIndex,true);
                        costIndex++;
                    }
                    xClearStartChunkIndex++;
                    if(xClearStartChunkIndex>xClearEndChunkIndex){
                        zClearStartChunkIndex++;
                        xClearStartChunkIndex=GetInRangeStartXChunkIndex(gameOverPos,zClearStartChunkIndex,chunkUnLoadRange+clearMargin);
                        xClearEndChunkIndex=GetInRangeEndXChunkIndex(gameOverPos,zClearStartChunkIndex,chunkUnLoadRange+clearMargin);
                        if(zClearStartChunkIndex>=zClearEndChunkIndex){
                            isClearing=false;
                            isPermanentCellsClearing=true;
                            break;
                        }
                    }*/
                }
            }

            if (isPermanentCellsClearing)
            {
                for (int i = 0; i < batchCount * 2; i++)
                {
                    permanentBreakCellArrLength--;
                    if (permanentBreakCellArrLength >= 0)
                    {
                        var cellIndex = permanentBreakCellArr[permanentBreakCellArrLength];
                        permanentBreakCellDictionary_Remove(cellIndex);
                    }
                    else
                    {
                        permanentBreakCellArrLength = 0;
                        isPermanentCellsClearing = false;
                        unloadQueue_Clear();
                        detailQueue_Clear();
                        undetailQueue_Clear();
                        priorityDetailQueue_Clear();
                        isGenerating = false;
                        isSearching = false;
                    }
                }
            }

            return;
        }

        if (isSearching)
        {
            //if(isUnLoading)return;
            for (costIndex = 0; costIndex < searchBatchCount; costIndex++)
            {
                var x = xSearchStartChunkIndex;
                var z = zSearchStartChunkIndex;
                var chunkIndex = ToChunkIndex(x, z);
                if (chunkStateDict_IsLoaded(chunkIndex))
                {
                    var diffx = x - playerPos.x;
                    var diffz = z - playerPos.z;
                    var distance = diffx * diffx + diffz * diffz;
                    var detailMargin = 1;
                    if (distance >= chunkUnLoadRange * chunkUnLoadRange)
                    {
                        chunkOperationDictionary_AddOrSetValue(chunkIndex, ChunkOperation.UnLoad);
                        unloadQueue_Enqueue(chunkIndex);
                    //UnLoadChunk((int)x,(int)z,true);
                    }
                    else if (distance >= (chunkDetailRange + detailMargin) * (chunkDetailRange + detailMargin))
                    {
                        if (chunkStateDict_IsDetailed(chunkIndex))
                        {
                            chunkOperationDictionary_AddOrSetValue(chunkIndex, ChunkOperation.UnDetail);
                            undetailQueue_Enqueue(chunkIndex);
                        }
                    //UnDetailChunk((int)x,(int)z);
                    }
                    else if (distance <= chunkDetailRange * chunkDetailRange)
                    {
                        if (chunkStateDict_IsUnDetailed(chunkIndex))
                        {
                            chunkOperationDictionary_AddOrSetValue(chunkIndex, ChunkOperation.Detail);
                            detailQueue_Enqueue(chunkIndex);
                        }
                    //DetailChunk((int)x,(int)z);
                    }
                }

                xSearchStartChunkIndex++;
                if (xSearchStartChunkIndex > xSearchEndChunkIndex)
                {
                    zSearchStartChunkIndex++;
                    xSearchStartChunkIndex = GetInRangeStartXChunkIndex(playerPos, zSearchStartChunkIndex, chunkUnLoadRange + searchMargin);
                    xSearchEndChunkIndex = GetInRangeEndXChunkIndex(playerPos, zSearchStartChunkIndex, chunkUnLoadRange + searchMargin);
                    if (zSearchStartChunkIndex >= zSearchEndChunkIndex)
                    {
                        isSearching = false;
                        break;
                    }
                }
            //if(taskFlag)break;
            }
        }
        else
        {
            if (searchAdditionalDelta >= 0)
            {
                searchAdditionalDelta -= Time.deltaTime;
                if (searchAdditionalDelta < 0 || researchFlag)
                {
                    SearchAdditional();
                }
            }
            else
            {
                //if(unloadQueue.Count==0&&detailQueue.Count==0){
                searchAdditionalDelta = searchAdditionalInterval; // search処理で最後に一回だけ呼ばれる
            //;
            }
        }

        // detail
        costIndex = 0;
        if (detailFlag)
        {
            while (costIndex < operationBatchCount)
            {
                if (priorityDetailQueue_Count == 0)
                    break;
                var chunkIndex = priorityDetailQueue_Dequeue();
                var shouldOperate = chunkOperationDictionary_GetValueOrDefault(chunkIndex, ChunkOperation.None) == ChunkOperation.Detail;
                chunkOperationDictionary_SetValue(chunkIndex, ChunkOperation.None);
                if (shouldOperate && DetailChunk(chunkIndex))
                    costIndex++;
            }

            while (costIndex < operationBatchCount)
            {
                if (detailQueue_Count == 0)
                    break;
                var chunkIndex = detailQueue_Dequeue();
                var shouldOperate = chunkOperationDictionary_GetValueOrDefault(chunkIndex, ChunkOperation.None) == ChunkOperation.Detail;
                chunkOperationDictionary_SetValue(chunkIndex, ChunkOperation.None);
                if (shouldOperate && DetailChunk(chunkIndex))
                    costIndex++;
            }
        }

        if (unloadFlag)
        {
            while (costIndex < operationBatchCount)
            {
                if (unloadQueue_Count == 0)
                    break;
                var chunkIndex = unloadQueue_Dequeue();
                var shouldOperate = chunkOperationDictionary_GetValueOrDefault(chunkIndex, ChunkOperation.None) == ChunkOperation.UnLoad;
                chunkOperationDictionary_SetValue(chunkIndex, ChunkOperation.None);
                if (shouldOperate && UnLoadChunk(chunkIndex, true))
                    costIndex++;
            }
        }

        if (undetailFlag)
        {
            while (costIndex < operationBatchCount)
            {
                if (undetailQueue_Count == 0)
                    break;
                var chunkIndex = undetailQueue_Dequeue();
                var shouldOperate = chunkOperationDictionary_GetValueOrDefault(chunkIndex, ChunkOperation.None) == ChunkOperation.UnDetail;
                chunkOperationDictionary_SetValue(chunkIndex, ChunkOperation.None);
                if (shouldOperate && UnDetailChunk(chunkIndex))
                    costIndex++;
            }
        }

        if (costIndex == operationBatchCount)
            return;
        if (isGenerating)
        {
            //if(isUnLoading)return;
            for (costIndex = 0; costIndex < batchCount * isInstantiatedCost;)
            {
                //delay=generateInterval * count / batchCount;
                mode = GenerateChunk();
                if (isInstantiated)
                {
                    costIndex += isInstantiatedCost;
                    isInstantiated = false;
                }
                else if (mode == GenerateChunkMode.Pass)
                {
                    storeCount++;
                    costIndex += isInstantiatedCost / 2;
                /*if(storeCount==storeMax){
                        StoreCell();
                        storeCount=0;
                    }
                    if(isInstantiated){
                        costIndex+=isInstantiatedCost;
                        isInstantiated=false;
                    }else{
                        costIndex++;
                    }*/
                }
                else
                {
                    costIndex += poolCost;
                }

                if (mode == GenerateChunkMode.Complete || mode == GenerateChunkMode.Pass)
                {
                    chunkXIndex = 0;
                    chunkZIndex = 0;
                    chunkYIndex = 0;
                    xStartChunkIndex++;
                    if (xStartChunkIndex > xEndChunkIndex)
                    {
                        zStartChunkIndex++;
                        xStartChunkIndex = GetInRangeStartXChunkIndex(playerPos + posCorrection, zStartChunkIndex, chunkLoadRange);
                        xEndChunkIndex = GetInRangeEndXChunkIndex(playerPos + posCorrection, zStartChunkIndex, chunkLoadRange);
                        if (zStartChunkIndex >= zEndChunkIndex)
                        {
                            isGenerating = false;
                            //GenerateAdditional();
                            if (generateAdditionalInterval == 0)
                            {
                                GenerateAdditional();
                            }
                            else
                            {
                                generateAdditionalDelta = generateAdditionalInterval;
                            }

                            break;
                        }
                    }
                }

                if (mode == GenerateChunkMode.Complete)
                {
                    break;
                }
            }
        }
        else
        {
            if (generateAdditionalDelta >= 0)
            {
                generateAdditionalDelta -= Time.deltaTime;
                if (generateAdditionalDelta < 0)
                {
                    GenerateAdditional();
                }
            }
        }
    }

    float searchMargin => chunkDetailRange * 2;

    float clearMargin => chunkDetailRange * 6;

    bool isSearching = false;
    int searchBatchCount => settings_searchBatchCount;

    bool searchOn => settings_searchOn;

    public const float AnimHeight = 10f;
    private int[] unloadQueue__array;
    private int unloadQueue__head; // First valid element in the queue.
    private int unloadQueue__tail; // Last valid element in the queue.
    private int unloadQueue__size; // Number of elements.
    private int unloadQueue__version;
    private const int unloadQueue_MinimumGrow = 100000;
    public int unloadQueue_Count => unloadQueue__size;
    public int unloadQueue_Version => unloadQueue__version;

    [Obsolete("Use Count Property.")]
    public int unloadQueue_GetCount() => unloadQueue__size;
    [Obsolete("Use Version Property.")]
    public int unloadQueue_GetVersion() => unloadQueue__version;
    // Removes all Objects from the queue.
    public void unloadQueue_Clear()
    {
        unloadQueue__size = 0;
        unloadQueue__head = 0;
        unloadQueue__tail = 0;
        unloadQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void unloadQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < unloadQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = unloadQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = unloadQueue__array.Length - unloadQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(unloadQueue__array, unloadQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(unloadQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void unloadQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (unloadQueue__array == null)
        {
            unloadQueue_SetCapacity(unloadQueue_MinimumGrow);
        }
        else if (unloadQueue__size == unloadQueue__array.Length)
        {
            unloadQueue_SetCapacity(unloadQueue__array.Length + unloadQueue_MinimumGrow);
        }

        unloadQueue__array[unloadQueue__tail] = obj;
        unloadQueue__tail = (unloadQueue__tail + 1) % unloadQueue__array.Length;
        unloadQueue__size++;
        unloadQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int unloadQueue_Dequeue()
    {
        if (unloadQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = unloadQueue__array[unloadQueue__head];
        unloadQueue__array[unloadQueue__head] = int.MaxValue;
        unloadQueue__head = (unloadQueue__head + 1) % unloadQueue__array.Length;
        unloadQueue__size--;
        unloadQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int unloadQueue_Peek()
    {
        if (unloadQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return unloadQueue__array[unloadQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] unloadQueue_ToArray()
    {
        int[] arr = new int[unloadQueue__size];
        if (unloadQueue__size == 0)
        {
        }
        else if (unloadQueue__head < unloadQueue__tail)
        {
            Array.Copy(unloadQueue__array, unloadQueue__head, arr, 0, unloadQueue__size);
        }
        else
        {
            int toHead = unloadQueue__array.Length - unloadQueue__head;
            Array.Copy(unloadQueue__array, unloadQueue__head, arr, 0, toHead);
            Array.Copy(unloadQueue__array, 0, arr, toHead, unloadQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void unloadQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (unloadQueue__size == 0)
        {
        }
        else if (unloadQueue__head < unloadQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(unloadQueue__array, unloadQueue__head, newArray, 0, unloadQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = unloadQueue__array.Length - unloadQueue__head;
            Array.Copy(unloadQueue__array, unloadQueue__head, newArray, 0, toHead);
            Array.Copy(unloadQueue__array, 0, newArray, toHead, unloadQueue__tail);
        }

        unloadQueue__array = newArray;
        unloadQueue__head = 0;
        unloadQueue__tail = unloadQueue__size == capacity ? 0 : unloadQueue__size;
        unloadQueue__version++;
    }

    private int[] undetailQueue__array;
    private int undetailQueue__head; // First valid element in the queue.
    private int undetailQueue__tail; // Last valid element in the queue.
    private int undetailQueue__size; // Number of elements.
    private int undetailQueue__version;
    private const int undetailQueue_MinimumGrow = 100000;
    public int undetailQueue_Count => undetailQueue__size;
    public int undetailQueue_Version => undetailQueue__version;

    [Obsolete("Use Count Property.")]
    public int undetailQueue_GetCount() => undetailQueue__size;
    [Obsolete("Use Version Property.")]
    public int undetailQueue_GetVersion() => undetailQueue__version;
    // Removes all Objects from the queue.
    public void undetailQueue_Clear()
    {
        undetailQueue__size = 0;
        undetailQueue__head = 0;
        undetailQueue__tail = 0;
        undetailQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void undetailQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < undetailQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = undetailQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = undetailQueue__array.Length - undetailQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(undetailQueue__array, undetailQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(undetailQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void undetailQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (undetailQueue__array == null)
        {
            undetailQueue_SetCapacity(undetailQueue_MinimumGrow);
        }
        else if (undetailQueue__size == undetailQueue__array.Length)
        {
            undetailQueue_SetCapacity(undetailQueue__array.Length + undetailQueue_MinimumGrow);
        }

        undetailQueue__array[undetailQueue__tail] = obj;
        undetailQueue__tail = (undetailQueue__tail + 1) % undetailQueue__array.Length;
        undetailQueue__size++;
        undetailQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int undetailQueue_Dequeue()
    {
        if (undetailQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = undetailQueue__array[undetailQueue__head];
        undetailQueue__array[undetailQueue__head] = int.MaxValue;
        undetailQueue__head = (undetailQueue__head + 1) % undetailQueue__array.Length;
        undetailQueue__size--;
        undetailQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int undetailQueue_Peek()
    {
        if (undetailQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return undetailQueue__array[undetailQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] undetailQueue_ToArray()
    {
        int[] arr = new int[undetailQueue__size];
        if (undetailQueue__size == 0)
        {
        }
        else if (undetailQueue__head < undetailQueue__tail)
        {
            Array.Copy(undetailQueue__array, undetailQueue__head, arr, 0, undetailQueue__size);
        }
        else
        {
            int toHead = undetailQueue__array.Length - undetailQueue__head;
            Array.Copy(undetailQueue__array, undetailQueue__head, arr, 0, toHead);
            Array.Copy(undetailQueue__array, 0, arr, toHead, undetailQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void undetailQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (undetailQueue__size == 0)
        {
        }
        else if (undetailQueue__head < undetailQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(undetailQueue__array, undetailQueue__head, newArray, 0, undetailQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = undetailQueue__array.Length - undetailQueue__head;
            Array.Copy(undetailQueue__array, undetailQueue__head, newArray, 0, toHead);
            Array.Copy(undetailQueue__array, 0, newArray, toHead, undetailQueue__tail);
        }

        undetailQueue__array = newArray;
        undetailQueue__head = 0;
        undetailQueue__tail = undetailQueue__size == capacity ? 0 : undetailQueue__size;
        undetailQueue__version++;
    }

    private int[] detailQueue__array;
    private int detailQueue__head; // First valid element in the queue.
    private int detailQueue__tail; // Last valid element in the queue.
    private int detailQueue__size; // Number of elements.
    private int detailQueue__version;
    private const int detailQueue_MinimumGrow = 100000;
    public int detailQueue_Count => detailQueue__size;
    public int detailQueue_Version => detailQueue__version;

    [Obsolete("Use Count Property.")]
    public int detailQueue_GetCount() => detailQueue__size;
    [Obsolete("Use Version Property.")]
    public int detailQueue_GetVersion() => detailQueue__version;
    // Removes all Objects from the queue.
    public void detailQueue_Clear()
    {
        detailQueue__size = 0;
        detailQueue__head = 0;
        detailQueue__tail = 0;
        detailQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void detailQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < detailQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = detailQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = detailQueue__array.Length - detailQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(detailQueue__array, detailQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(detailQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void detailQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (detailQueue__array == null)
        {
            detailQueue_SetCapacity(detailQueue_MinimumGrow);
        }
        else if (detailQueue__size == detailQueue__array.Length)
        {
            detailQueue_SetCapacity(detailQueue__array.Length + detailQueue_MinimumGrow);
        }

        detailQueue__array[detailQueue__tail] = obj;
        detailQueue__tail = (detailQueue__tail + 1) % detailQueue__array.Length;
        detailQueue__size++;
        detailQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int detailQueue_Dequeue()
    {
        if (detailQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = detailQueue__array[detailQueue__head];
        detailQueue__array[detailQueue__head] = int.MaxValue;
        detailQueue__head = (detailQueue__head + 1) % detailQueue__array.Length;
        detailQueue__size--;
        detailQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int detailQueue_Peek()
    {
        if (detailQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return detailQueue__array[detailQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] detailQueue_ToArray()
    {
        int[] arr = new int[detailQueue__size];
        if (detailQueue__size == 0)
        {
        }
        else if (detailQueue__head < detailQueue__tail)
        {
            Array.Copy(detailQueue__array, detailQueue__head, arr, 0, detailQueue__size);
        }
        else
        {
            int toHead = detailQueue__array.Length - detailQueue__head;
            Array.Copy(detailQueue__array, detailQueue__head, arr, 0, toHead);
            Array.Copy(detailQueue__array, 0, arr, toHead, detailQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void detailQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (detailQueue__size == 0)
        {
        }
        else if (detailQueue__head < detailQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(detailQueue__array, detailQueue__head, newArray, 0, detailQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = detailQueue__array.Length - detailQueue__head;
            Array.Copy(detailQueue__array, detailQueue__head, newArray, 0, toHead);
            Array.Copy(detailQueue__array, 0, newArray, toHead, detailQueue__tail);
        }

        detailQueue__array = newArray;
        detailQueue__head = 0;
        detailQueue__tail = detailQueue__size == capacity ? 0 : detailQueue__size;
        detailQueue__version++;
    }

    private int[] priorityDetailQueue__array;
    private int priorityDetailQueue__head; // First valid element in the queue.
    private int priorityDetailQueue__tail; // Last valid element in the queue.
    private int priorityDetailQueue__size; // Number of elements.
    private int priorityDetailQueue__version;
    private const int priorityDetailQueue_MinimumGrow = 100000;
    public int priorityDetailQueue_Count => priorityDetailQueue__size;
    public int priorityDetailQueue_Version => priorityDetailQueue__version;

    [Obsolete("Use Count Property.")]
    public int priorityDetailQueue_GetCount() => priorityDetailQueue__size;
    [Obsolete("Use Version Property.")]
    public int priorityDetailQueue_GetVersion() => priorityDetailQueue__version;
    // Removes all Objects from the queue.
    public void priorityDetailQueue_Clear()
    {
        priorityDetailQueue__size = 0;
        priorityDetailQueue__head = 0;
        priorityDetailQueue__tail = 0;
        priorityDetailQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void priorityDetailQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < priorityDetailQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = priorityDetailQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = priorityDetailQueue__array.Length - priorityDetailQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(priorityDetailQueue__array, priorityDetailQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(priorityDetailQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void priorityDetailQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (priorityDetailQueue__array == null)
        {
            priorityDetailQueue_SetCapacity(priorityDetailQueue_MinimumGrow);
        }
        else if (priorityDetailQueue__size == priorityDetailQueue__array.Length)
        {
            priorityDetailQueue_SetCapacity(priorityDetailQueue__array.Length + priorityDetailQueue_MinimumGrow);
        }

        priorityDetailQueue__array[priorityDetailQueue__tail] = obj;
        priorityDetailQueue__tail = (priorityDetailQueue__tail + 1) % priorityDetailQueue__array.Length;
        priorityDetailQueue__size++;
        priorityDetailQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int priorityDetailQueue_Dequeue()
    {
        if (priorityDetailQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = priorityDetailQueue__array[priorityDetailQueue__head];
        priorityDetailQueue__array[priorityDetailQueue__head] = int.MaxValue;
        priorityDetailQueue__head = (priorityDetailQueue__head + 1) % priorityDetailQueue__array.Length;
        priorityDetailQueue__size--;
        priorityDetailQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int priorityDetailQueue_Peek()
    {
        if (priorityDetailQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return priorityDetailQueue__array[priorityDetailQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] priorityDetailQueue_ToArray()
    {
        int[] arr = new int[priorityDetailQueue__size];
        if (priorityDetailQueue__size == 0)
        {
        }
        else if (priorityDetailQueue__head < priorityDetailQueue__tail)
        {
            Array.Copy(priorityDetailQueue__array, priorityDetailQueue__head, arr, 0, priorityDetailQueue__size);
        }
        else
        {
            int toHead = priorityDetailQueue__array.Length - priorityDetailQueue__head;
            Array.Copy(priorityDetailQueue__array, priorityDetailQueue__head, arr, 0, toHead);
            Array.Copy(priorityDetailQueue__array, 0, arr, toHead, priorityDetailQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void priorityDetailQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (priorityDetailQueue__size == 0)
        {
        }
        else if (priorityDetailQueue__head < priorityDetailQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(priorityDetailQueue__array, priorityDetailQueue__head, newArray, 0, priorityDetailQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = priorityDetailQueue__array.Length - priorityDetailQueue__head;
            Array.Copy(priorityDetailQueue__array, priorityDetailQueue__head, newArray, 0, toHead);
            Array.Copy(priorityDetailQueue__array, 0, newArray, toHead, priorityDetailQueue__tail);
        }

        priorityDetailQueue__array = newArray;
        priorityDetailQueue__head = 0;
        priorityDetailQueue__tail = priorityDetailQueue__size == capacity ? 0 : priorityDetailQueue__size;
        priorityDetailQueue__version++;
    }

    int[][] chunkStateDict__keys;
    ChunkState[][] chunkStateDict__values;
    int chunkStateDict__size;
    public int chunkStateDict_Count => chunkStateDict__size;

    const int chunkStateDict_bucketCount = 1;
    public void chunkStateDict_SetCapacity(int capacity)
    {
        int len = capacity / chunkStateDict_bucketCount;
        chunkStateDict__keys = new int[len][];
        for (int i = 0; i < chunkStateDict__keys.Length; i++)
        {
            chunkStateDict__keys[i] = new int[chunkStateDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < chunkStateDict_bucketCount; i++)
        {
            chunkStateDict__keys[0][i] = int.MaxValue;
        }

        chunkStateDict__values = new ChunkState[len][];
        for (int i = 0; i < chunkStateDict__values.Length; i++)
        {
            chunkStateDict__values[i] = new ChunkState[chunkStateDict_bucketCount];
        }
    }

    public bool chunkStateDict_HasItem(int key)
    {
        var index = chunkStateDict_Hash(key);
        var hashKeys = chunkStateDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int chunkStateDict_Hash(int key)
    {
        var len = chunkStateDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public int[] chunkStateDict_GenerateKeysArray()
    {
        int[] keys = new int[chunkStateDict__size];
        int index = 0;
        for (int i = 0; i < chunkStateDict__keys.Length; i++)
        {
            var hashKeys = chunkStateDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    public bool chunkStateDict_Add(int key, ChunkState value)
    {
        int index = chunkStateDict_Hash(key);
        var hashKeys = chunkStateDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyChunkStateArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkStateDict__keys[index][i] = key;
                    chunkStateDict__values[index][i] = value;
                    chunkStateDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyChunkStateArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    chunkStateDict__keys[index][i] = key;
                    chunkStateDict__values[index][i] = value;
                    chunkStateDict__size++;
                    return true;
                }
            }
        }

        var preLen = hashKeys.Length;
        chunkStateDict_ExpandList(index);
        chunkStateDict__keys[index][preLen] = key;
        chunkStateDict__values[index][preLen] = value;
        chunkStateDict__size++;
        return true;
    }

    const int chunkStateDict_expand = 5;
    void chunkStateDict_ExpandList(int index)
    {
        var hashKeys = chunkStateDict__keys[index];
        var hashValues = chunkStateDict__values[index];
        var len = chunkStateDict__keys[index].Length + chunkStateDict_expand;
        var newKeys = new int[len];
        var newValues = new ChunkState[len];
        for (int i = 0; i < chunkStateDict__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = chunkStateDict__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        chunkStateDict__keys[index] = newKeys;
        chunkStateDict__values[index] = newValues;
    }

    public void chunkStateDict_AddOrSetValue(int key, ChunkState value)
    {
        int index = chunkStateDict_Hash(key);
        var hashKeys = chunkStateDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkStateDict__keys[index][i] = key;
                    chunkStateDict__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkStateDict__keys[index][i] = key;
                    chunkStateDict__values[index][i] = value;
                    chunkStateDict__size++;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkStateDict__keys[index][i] = key;
                    chunkStateDict__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == default)
                {
                    chunkStateDict__keys[index][i] = key;
                    chunkStateDict__values[index][i] = value;
                    chunkStateDict__size++;
                    return;
                }
            }
        }

        var preLen = hashKeys.Length;
        chunkStateDict_ExpandList(index);
        chunkStateDict__keys[index][preLen] = key;
        chunkStateDict__values[index][preLen] = value;
        chunkStateDict__size++;
    }

    public void chunkStateDict_SetValue(int key, ChunkState value)
    {
        int index = chunkStateDict_Hash(key);
        var hashKeys = chunkStateDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkStateDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkStateDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public bool chunkStateDict_IsLoaded(int key)
    {
        var state = chunkStateDict_GetValueOrDefault(key, ChunkState.None);
        return state == ChunkState.Detailed || state == ChunkState.UnDetailed;
    }

    public bool chunkStateDict_IsDetailed(int key)
    {
        var state = chunkStateDict_GetValueOrDefault(key, ChunkState.None);
        return state == ChunkState.Detailed;
    }

    public bool chunkStateDict_IsUnDetailed(int key)
    {
        var state = chunkStateDict_GetValueOrDefault(key, ChunkState.None);
        return state == ChunkState.UnDetailed;
    }

    public bool chunkStateDict_IsUnLoaded(int key)
    {
        var state = chunkStateDict_GetValueOrDefault(key, ChunkState.None);
        return state == ChunkState.UnLoaded;
    }

    public ChunkState chunkStateDict_GetValueOrDefault(int key, ChunkState defaultValue)
    {
        int index = chunkStateDict_Hash(key);
        var hashKeys = chunkStateDict__keys[index];
        var hashValues = chunkStateDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return defaultValue;
    }

    public ChunkState chunkStateDict_GetValue(int key)
    {
        int index = chunkStateDict_Hash(key);
        var hashKeys = chunkStateDict__keys[index];
        var hashValues = chunkStateDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void chunkStateDict_Remove(int key)
    {
        int index = chunkStateDict_Hash(key);
        var hashKeys = chunkStateDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    chunkStateDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    chunkStateDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    bool DetailChunk(int chunkIndex)
    {
        //int chunkIndex=ToChunkIndex(xIndex,zIndex);
        if (chunkStateDict_IsUnDetailed(chunkIndex))
        {
            if (outlineDict_HasItem(chunkIndex))
            {
                //Debug.Log("DetailChunk: "+chunkIndex);
                var outline = outlineDict_GetValue(chunkIndex);
                chunkToCells = chunkToCellsDict_GetValue(chunkIndex);
                cellInstanceIds = chunkToCellInstanceIdsDictionary_GetValue(chunkIndex);
                for (int i = 0; i < chunkToCells.Length; i++)
                {
                    brokenArr[i] = permanentBreakCellDictionary_GetValueOrDefault(ToGlobalCellIndex(i, chunkIndex), false);
                }

                var outlineId = chunkIndexToInstanceIdDictionary_GetValue(chunkIndex);
                meshCombiner_SwitchCombineMesh(false, outline, outlineId, chunkToCells, cellInstanceIds, brokenArr);
                chunkStateDict_SetValue(chunkIndex, ChunkState.Detailed);
                return true;
            }
            else
            {
                Debug.LogWarning("DetailChunk: chunkIndexDict not has item");
            }
        }

        return false;
    }

    bool[] brokenArr;
    bool[] colOnlyArr;
    bool UnDetailChunk(int chunkIndex)
    {
        //int chunkIndex=ToChunkIndex(xIndex,zIndex);
        if (chunkStateDict_IsDetailed(chunkIndex))
        {
            if (outlineDict_HasItem(chunkIndex))
            {
                //Debug.Log("UnDetailChunk: "+chunkIndex);
                var outline = outlineDict_GetValue(chunkIndex);
                chunkToCells = chunkToCellsDict_GetValue(chunkIndex);
                cellInstanceIds = chunkToCellInstanceIdsDictionary_GetValue(chunkIndex);
                var outlineId = chunkIndexToInstanceIdDictionary_GetValue(chunkIndex);
                meshCombiner_SwitchCombineMesh(true, outline, outlineId, chunkToCells, cellInstanceIds, brokenArr);
                chunkStateDict_SetValue(chunkIndex, ChunkState.UnDetailed);
                return true;
            }
            else
            {
                Debug.LogWarning("UnDetailChunk: chunkIndexDict not has item");
            }
        }

        return false;
    }

    GameObject[] chunkToCells;
    int[] cellInstanceIds;
    [SerializeField]
    float quickSearchRange = 6;
    public bool UnLoadChunk(int chunkIndex, bool setOnly = false)
    {
        //int chunkIndex=ToChunkIndex(xIndex,zIndex);
        if (!chunkStateDict_IsLoaded(chunkIndex))
        {
            //Debug.Log("UnLoadChunk: not yet loaded");
            //遅延実行の関係上このケースは起こりえる
            return false;
        }

        if (outlineDict_HasItem(chunkIndex))
        {
            //Debug.Log("UnLoadChunk:"+chunkIndex);
            //chunkIndexDict.Remove(chunkIndex);
            var chunkMesh = outlineDict_GetValue(chunkIndex);
            //var id=chunkMesh.GetInstanceID();
            //Debug.Log("unload chunkID: "+id);
            if (!chunkToCellsDict_HasItem(chunkIndex))
            {
                Debug.LogWarning("unload chunk id not exists");
            }

            chunkToCells = chunkToCellsDict_GetValue(chunkIndex);
            cellInstanceIds = chunkToCellInstanceIdsDictionary_GetValue(chunkIndex);
            var chunkId = chunkIndexToInstanceIdDictionary_GetValue(chunkIndex);
            chunkPool_Return(chunkMesh, chunkId, true, false);
            // gc alloc debug only
            /*if(chunkMesh!=null){
                var id=chunkIndexToInstanceIdDictionary.GetValue(chunkIndex);
                chunkPool.Return(chunkMesh,id,true,false);
            } else {
                Debug.LogWarning("Chunk pool is empty!");
            }*/
            var biomeTypes = chunkIndexToCellBiomesDictionary_GetValue(chunkIndex);
            for (int i = 0; i < chunkToCells.Length; i++)
            {
                var cell = chunkToCells[i];
                // gc alloc debug only
                /*if(cell!=null){
                    var id = cellInstanceIds[i];
                    UnloadCell(cell,id,biomeTypes[i]);
                } else {
                    Debug.LogError("Cell pool is empty!");
                }*/
                var id = cellInstanceIds[i];
                if (!permanentBreakCellDictionary_GetValueOrDefault(ToGlobalCellIndex(i, chunkIndex), false))
                {
                    UnloadCell(cell, id, biomeTypes[i]);
                }
            }

            chunkStateDict_SetValue(chunkIndex, ChunkState.UnLoaded); //AddOrSetValue(chunkIndex,false );
            return true;
        }

        return false;
    }

    int[][] permanentBreakCellDictionary__keys;
    bool[][] permanentBreakCellDictionary__values;
    int permanentBreakCellDictionary__size;
    public int permanentBreakCellDictionary_Count => permanentBreakCellDictionary__size;

    public int[] permanentBreakCellDictionary_GenerateKeysArray()
    {
        int[] keys = new int[permanentBreakCellDictionary__size];
        int index = 0;
        for (int i = 0; i < permanentBreakCellDictionary__keys.Length; i++)
        {
            var hashKeys = permanentBreakCellDictionary__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int permanentBreakCellDictionary_bucketCount = 1;
    public void permanentBreakCellDictionary_SetCapacity(int capacity)
    {
        int len = capacity / permanentBreakCellDictionary_bucketCount;
        permanentBreakCellDictionary__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            permanentBreakCellDictionary__keys[i] = new int[permanentBreakCellDictionary_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < permanentBreakCellDictionary_bucketCount; i++)
        {
            permanentBreakCellDictionary__keys[0][i] = int.MaxValue;
        }

        permanentBreakCellDictionary__values = new bool[len][];
        for (int i = 0; i < len; i++)
        {
            permanentBreakCellDictionary__values[i] = new bool[permanentBreakCellDictionary_bucketCount];
        }
    }

    public bool permanentBreakCellDictionary_HasItem(int key)
    {
        var index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int permanentBreakCellDictionary_Hash(int key)
    {
        var len = permanentBreakCellDictionary__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool permanentBreakCellDictionary_Add(int key, bool value)
    {
        int index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        if (key == int.MaxValue)
        {
            Debug.LogError("not allowed key value");
        }

        if (index == 0)
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    permanentBreakCellDictionary__keys[index][i] = key;
                    permanentBreakCellDictionary__values[index][i] = value;
                    permanentBreakCellDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    permanentBreakCellDictionary__keys[index][i] = key;
                    permanentBreakCellDictionary__values[index][i] = value;
                    permanentBreakCellDictionary__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoolDictionary Add: Dictionary is full");
        var preLen = hashKeys.Length;
        permanentBreakCellDictionary_ExpandList(index);
        permanentBreakCellDictionary__keys[index][preLen] = key;
        permanentBreakCellDictionary__values[index][preLen] = value;
        permanentBreakCellDictionary__size++;
        return true;
    }

    const int permanentBreakCellDictionary_expand = 5;
    void permanentBreakCellDictionary_ExpandList(int index)
    {
        var hashKeys = permanentBreakCellDictionary__keys[index];
        var hashValues = permanentBreakCellDictionary__values[index];
        var len = permanentBreakCellDictionary__keys[index].Length + permanentBreakCellDictionary_expand;
        var newKeys = new int[len];
        var newValues = new bool[len];
        for (int i = 0; i < permanentBreakCellDictionary__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = permanentBreakCellDictionary__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        permanentBreakCellDictionary__keys[index] = newKeys;
        permanentBreakCellDictionary__values[index] = newValues;
    }

    public bool permanentBreakCellDictionary_AddOrSetValue(int key, bool value)
    {
        int index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    permanentBreakCellDictionary__keys[index][i] = key;
                    permanentBreakCellDictionary__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    permanentBreakCellDictionary__keys[index][i] = key;
                    permanentBreakCellDictionary__values[index][i] = value;
                    permanentBreakCellDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    permanentBreakCellDictionary__keys[index][i] = key;
                    permanentBreakCellDictionary__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    permanentBreakCellDictionary__keys[index][i] = key;
                    permanentBreakCellDictionary__values[index][i] = value;
                    permanentBreakCellDictionary__size++;
                    return true;
                }
            }
        }

        //Debug.LogError("InkEyBoolDictionary AddOrSetValue: Dictionary is full");
        //return false;
        var preLen = hashKeys.Length;
        permanentBreakCellDictionary_ExpandList(index);
        permanentBreakCellDictionary__keys[index][preLen] = key;
        permanentBreakCellDictionary__values[index][preLen] = value;
        permanentBreakCellDictionary__size++;
        return true;
    }

    public void permanentBreakCellDictionary_SetValue(int key, bool value)
    {
        int index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    permanentBreakCellDictionary__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    permanentBreakCellDictionary__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public bool permanentBreakCellDictionary_GetValueOrDefault(int key, bool defaultValue)
    {
        int index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        var hashValues = permanentBreakCellDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return defaultValue;
    }

    public bool permanentBreakCellDictionary_GetValue(int key)
    {
        int index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        var hashValues = permanentBreakCellDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void permanentBreakCellDictionary_TryRemoveBatch(int[] keys, bool[] result)
    {
        for (int i = 0; i < keys.Length; i++)
        {
            result[i] = permanentBreakCellDictionary_TryRemove(keys[i]);
        }
    }

    public bool permanentBreakCellDictionary_TryRemove(int key)
    {
        int index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    permanentBreakCellDictionary__size--;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    permanentBreakCellDictionary__size--;
                    return true;
                }
            }
        }

        return false;
    }

    public void permanentBreakCellDictionary_Remove(int key)
    {
        if (!permanentBreakCellDictionary_TryRemove(key))
            Debug.LogError("Key not found");
    }

    int[][] chunkIndexToCellBiomesDictionary__keys;
    Biome[][][] chunkIndexToCellBiomesDictionary__values;
    int chunkIndexToCellBiomesDictionary__size;
    public int chunkIndexToCellBiomesDictionary_Count => chunkIndexToCellBiomesDictionary__size;

    const int chunkIndexToCellBiomesDictionary_bucketCount = 1;
    public void chunkIndexToCellBiomesDictionary_SetCapacity(int capacity)
    {
        int len = capacity / chunkIndexToCellBiomesDictionary_bucketCount;
        chunkIndexToCellBiomesDictionary__keys = new int[len][];
        for (int i = 0; i < chunkIndexToCellBiomesDictionary__keys.Length; i++)
        {
            chunkIndexToCellBiomesDictionary__keys[i] = new int[chunkIndexToCellBiomesDictionary_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < chunkIndexToCellBiomesDictionary_bucketCount; i++)
        {
            chunkIndexToCellBiomesDictionary__keys[0][i] = int.MaxValue;
        }

        chunkIndexToCellBiomesDictionary__values = new Biome[len][][];
        for (int i = 0; i < chunkIndexToCellBiomesDictionary__values.Length; i++)
        {
            chunkIndexToCellBiomesDictionary__values[i] = new Biome[chunkIndexToCellBiomesDictionary_bucketCount][];
        }
    }

    public bool chunkIndexToCellBiomesDictionary_HasItem(int key)
    {
        var index = chunkIndexToCellBiomesDictionary_Hash(key);
        var hashKeys = chunkIndexToCellBiomesDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int chunkIndexToCellBiomesDictionary_Hash(int key)
    {
        var len = chunkIndexToCellBiomesDictionary__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public int[] chunkIndexToCellBiomesDictionary_GenerateKeysArray()
    {
        int[] keys = new int[chunkIndexToCellBiomesDictionary__size];
        int index = 0;
        for (int i = 0; i < chunkIndexToCellBiomesDictionary__keys.Length; i++)
        {
            var hashKeys = chunkIndexToCellBiomesDictionary__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    public bool chunkIndexToCellBiomesDictionary_Add(int key, Biome[] value)
    {
        int index = chunkIndexToCellBiomesDictionary_Hash(key);
        var hashKeys = chunkIndexToCellBiomesDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBiomeArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkIndexToCellBiomesDictionary__keys[index][i] = key;
                    chunkIndexToCellBiomesDictionary__values[index][i] = value;
                    chunkIndexToCellBiomesDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBiomeArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    chunkIndexToCellBiomesDictionary__keys[index][i] = key;
                    chunkIndexToCellBiomesDictionary__values[index][i] = value;
                    chunkIndexToCellBiomesDictionary__size++;
                    return true;
                }
            }
        }

        var preLen = hashKeys.Length;
        chunkIndexToCellBiomesDictionary_ExpandList(index);
        chunkIndexToCellBiomesDictionary__keys[index][preLen] = key;
        chunkIndexToCellBiomesDictionary__values[index][preLen] = value;
        chunkIndexToCellBiomesDictionary__size++;
        return true;
    }

    const int chunkIndexToCellBiomesDictionary_expand = 5;
    void chunkIndexToCellBiomesDictionary_ExpandList(int index)
    {
        var hashKeys = chunkIndexToCellBiomesDictionary__keys[index];
        var hashValues = chunkIndexToCellBiomesDictionary__values[index];
        var len = chunkIndexToCellBiomesDictionary__keys[index].Length + chunkIndexToCellBiomesDictionary_expand;
        var newKeys = new int[len];
        var newValues = new Biome[len][];
        for (int i = 0; i < chunkIndexToCellBiomesDictionary__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = chunkIndexToCellBiomesDictionary__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        chunkIndexToCellBiomesDictionary__keys[index] = newKeys;
        chunkIndexToCellBiomesDictionary__values[index] = newValues;
    }

    public void chunkIndexToCellBiomesDictionary_AddOrSetValue(int key, Biome[] value)
    {
        int index = chunkIndexToCellBiomesDictionary_Hash(key);
        var hashKeys = chunkIndexToCellBiomesDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkIndexToCellBiomesDictionary__keys[index][i] = key;
                    chunkIndexToCellBiomesDictionary__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkIndexToCellBiomesDictionary__keys[index][i] = key;
                    chunkIndexToCellBiomesDictionary__values[index][i] = value;
                    chunkIndexToCellBiomesDictionary__size++;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkIndexToCellBiomesDictionary__keys[index][i] = key;
                    chunkIndexToCellBiomesDictionary__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == default)
                {
                    chunkIndexToCellBiomesDictionary__keys[index][i] = key;
                    chunkIndexToCellBiomesDictionary__values[index][i] = value;
                    chunkIndexToCellBiomesDictionary__size++;
                    return;
                }
            }
        }

        var preLen = hashKeys.Length;
        chunkIndexToCellBiomesDictionary_ExpandList(index);
        chunkIndexToCellBiomesDictionary__keys[index][preLen] = key;
        chunkIndexToCellBiomesDictionary__values[index][preLen] = value;
        chunkIndexToCellBiomesDictionary__size++;
    }

    public void chunkIndexToCellBiomesDictionary_SetValue(int key, Biome[] value)
    {
        int index = chunkIndexToCellBiomesDictionary_Hash(key);
        var hashKeys = chunkIndexToCellBiomesDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkIndexToCellBiomesDictionary__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkIndexToCellBiomesDictionary__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public Biome[] chunkIndexToCellBiomesDictionary_GetValue(int key)
    {
        int index = chunkIndexToCellBiomesDictionary_Hash(key);
        var hashKeys = chunkIndexToCellBiomesDictionary__keys[index];
        var hashValues = chunkIndexToCellBiomesDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void chunkIndexToCellBiomesDictionary_Remove(int key)
    {
        int index = chunkIndexToCellBiomesDictionary_Hash(key);
        var hashKeys = chunkIndexToCellBiomesDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    chunkIndexToCellBiomesDictionary__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    chunkIndexToCellBiomesDictionary__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    int[][] instanceIDToGlobalCellIndexDictionary__keys;
    int[][] instanceIDToGlobalCellIndexDictionary__values;
    int instanceIDToGlobalCellIndexDictionary__size;
    public int instanceIDToGlobalCellIndexDictionary_Count => instanceIDToGlobalCellIndexDictionary__size;

    const int instanceIDToGlobalCellIndexDictionary_bucketCount = 1;
    public void instanceIDToGlobalCellIndexDictionary_SetCapacity(int capacity)
    {
        int len = capacity / instanceIDToGlobalCellIndexDictionary_bucketCount;
        instanceIDToGlobalCellIndexDictionary__keys = new int[len][];
        for (int i = 0; i < instanceIDToGlobalCellIndexDictionary__keys.Length; i++)
        {
            instanceIDToGlobalCellIndexDictionary__keys[i] = new int[instanceIDToGlobalCellIndexDictionary_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < instanceIDToGlobalCellIndexDictionary_bucketCount; i++)
        {
            instanceIDToGlobalCellIndexDictionary__keys[0][i] = int.MaxValue;
        }

        instanceIDToGlobalCellIndexDictionary__values = new int[len][];
        for (int i = 0; i < instanceIDToGlobalCellIndexDictionary__values.Length; i++)
        {
            instanceIDToGlobalCellIndexDictionary__values[i] = new int[instanceIDToGlobalCellIndexDictionary_bucketCount];
        }
    }

    public bool instanceIDToGlobalCellIndexDictionary_HasItem(int key)
    {
        var index = instanceIDToGlobalCellIndexDictionary_Hash(key);
        var hashKeys = instanceIDToGlobalCellIndexDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int instanceIDToGlobalCellIndexDictionary_Hash(int key)
    {
        var len = instanceIDToGlobalCellIndexDictionary__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public int[] instanceIDToGlobalCellIndexDictionary_GenerateKeysArray()
    {
        int[] keys = new int[instanceIDToGlobalCellIndexDictionary__size];
        int index = 0;
        for (int i = 0; i < instanceIDToGlobalCellIndexDictionary__keys.Length; i++)
        {
            var hashKeys = instanceIDToGlobalCellIndexDictionary__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    public bool instanceIDToGlobalCellIndexDictionary_Add(int key, int value)
    {
        int index = instanceIDToGlobalCellIndexDictionary_Hash(key);
        var hashKeys = instanceIDToGlobalCellIndexDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyintDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    instanceIDToGlobalCellIndexDictionary__keys[index][i] = key;
                    instanceIDToGlobalCellIndexDictionary__values[index][i] = value;
                    instanceIDToGlobalCellIndexDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyintDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    instanceIDToGlobalCellIndexDictionary__keys[index][i] = key;
                    instanceIDToGlobalCellIndexDictionary__values[index][i] = value;
                    instanceIDToGlobalCellIndexDictionary__size++;
                    return true;
                }
            }
        }

        var preLen = hashKeys.Length;
        instanceIDToGlobalCellIndexDictionary_ExpandList(index);
        instanceIDToGlobalCellIndexDictionary__keys[index][preLen] = key;
        instanceIDToGlobalCellIndexDictionary__values[index][preLen] = value;
        instanceIDToGlobalCellIndexDictionary__size++;
        return true;
    }

    const int instanceIDToGlobalCellIndexDictionary_expand = 5;
    void instanceIDToGlobalCellIndexDictionary_ExpandList(int index)
    {
        var hashKeys = instanceIDToGlobalCellIndexDictionary__keys[index];
        var hashValues = instanceIDToGlobalCellIndexDictionary__values[index];
        var len = instanceIDToGlobalCellIndexDictionary__keys[index].Length + instanceIDToGlobalCellIndexDictionary_expand;
        var newKeys = new int[len];
        var newValues = new int[len];
        for (int i = 0; i < instanceIDToGlobalCellIndexDictionary__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = instanceIDToGlobalCellIndexDictionary__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        instanceIDToGlobalCellIndexDictionary__keys[index] = newKeys;
        instanceIDToGlobalCellIndexDictionary__values[index] = newValues;
    }

    public void instanceIDToGlobalCellIndexDictionary_AddOrSetValue(int key, int value)
    {
        int index = instanceIDToGlobalCellIndexDictionary_Hash(key);
        var hashKeys = instanceIDToGlobalCellIndexDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    instanceIDToGlobalCellIndexDictionary__keys[index][i] = key;
                    instanceIDToGlobalCellIndexDictionary__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    instanceIDToGlobalCellIndexDictionary__keys[index][i] = key;
                    instanceIDToGlobalCellIndexDictionary__values[index][i] = value;
                    instanceIDToGlobalCellIndexDictionary__size++;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    instanceIDToGlobalCellIndexDictionary__keys[index][i] = key;
                    instanceIDToGlobalCellIndexDictionary__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == default)
                {
                    instanceIDToGlobalCellIndexDictionary__keys[index][i] = key;
                    instanceIDToGlobalCellIndexDictionary__values[index][i] = value;
                    instanceIDToGlobalCellIndexDictionary__size++;
                    return;
                }
            }
        }

        var preLen = hashKeys.Length;
        instanceIDToGlobalCellIndexDictionary_ExpandList(index);
        instanceIDToGlobalCellIndexDictionary__keys[index][preLen] = key;
        instanceIDToGlobalCellIndexDictionary__values[index][preLen] = value;
        instanceIDToGlobalCellIndexDictionary__size++;
    }

    public void instanceIDToGlobalCellIndexDictionary_SetValue(int key, int value)
    {
        int index = instanceIDToGlobalCellIndexDictionary_Hash(key);
        var hashKeys = instanceIDToGlobalCellIndexDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    instanceIDToGlobalCellIndexDictionary__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    instanceIDToGlobalCellIndexDictionary__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public int instanceIDToGlobalCellIndexDictionary_GetValue(int key)
    {
        int index = instanceIDToGlobalCellIndexDictionary_Hash(key);
        var hashKeys = instanceIDToGlobalCellIndexDictionary__keys[index];
        var hashValues = instanceIDToGlobalCellIndexDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public int instanceIDToGlobalCellIndexDictionary_GetValueOrDefault(int key, int defaultValue)
    {
        int index = instanceIDToGlobalCellIndexDictionary_Hash(key);
        var hashKeys = instanceIDToGlobalCellIndexDictionary__keys[index];
        var hashValues = instanceIDToGlobalCellIndexDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return defaultValue;
    }

    public void instanceIDToGlobalCellIndexDictionary_Remove(int key)
    {
        if (instanceIDToGlobalCellIndexDictionary_TryRemove(key))
            return;
        Debug.LogError("Key not found");
    }

    public bool instanceIDToGlobalCellIndexDictionary_TryRemove(int key)
    {
        int index = instanceIDToGlobalCellIndexDictionary_Hash(key);
        var hashKeys = instanceIDToGlobalCellIndexDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    instanceIDToGlobalCellIndexDictionary__size--;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    instanceIDToGlobalCellIndexDictionary__size--;
                    return true;
                }
            }
        }

        return false;
    }

    int[][] instanceIDToBiomeDictionary__keys;
    Biome[][] instanceIDToBiomeDictionary__values;
    int instanceIDToBiomeDictionary__size;
    public int instanceIDToBiomeDictionary_Count => instanceIDToBiomeDictionary__size;

    const int instanceIDToBiomeDictionary_bucketCount = 1;
    public void instanceIDToBiomeDictionary_SetCapacity(int capacity)
    {
        int len = capacity / instanceIDToBiomeDictionary_bucketCount;
        instanceIDToBiomeDictionary__keys = new int[len][];
        for (int i = 0; i < instanceIDToBiomeDictionary__keys.Length; i++)
        {
            instanceIDToBiomeDictionary__keys[i] = new int[instanceIDToBiomeDictionary_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < instanceIDToBiomeDictionary_bucketCount; i++)
        {
            instanceIDToBiomeDictionary__keys[0][i] = int.MaxValue;
        }

        instanceIDToBiomeDictionary__values = new Biome[len][];
        for (int i = 0; i < instanceIDToBiomeDictionary__values.Length; i++)
        {
            instanceIDToBiomeDictionary__values[i] = new Biome[instanceIDToBiomeDictionary_bucketCount];
        }
    }

    public bool instanceIDToBiomeDictionary_HasItem(int key)
    {
        var index = instanceIDToBiomeDictionary_Hash(key);
        var hashKeys = instanceIDToBiomeDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int instanceIDToBiomeDictionary_Hash(int key)
    {
        var len = instanceIDToBiomeDictionary__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public int[] instanceIDToBiomeDictionary_GenerateKeysArray()
    {
        int[] keys = new int[instanceIDToBiomeDictionary__size];
        int index = 0;
        for (int i = 0; i < instanceIDToBiomeDictionary__keys.Length; i++)
        {
            var hashKeys = instanceIDToBiomeDictionary__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    public bool instanceIDToBiomeDictionary_Add(int key, Biome value)
    {
        int index = instanceIDToBiomeDictionary_Hash(key);
        var hashKeys = instanceIDToBiomeDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBiomeArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    instanceIDToBiomeDictionary__keys[index][i] = key;
                    instanceIDToBiomeDictionary__values[index][i] = value;
                    instanceIDToBiomeDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBiomeArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    instanceIDToBiomeDictionary__keys[index][i] = key;
                    instanceIDToBiomeDictionary__values[index][i] = value;
                    instanceIDToBiomeDictionary__size++;
                    return true;
                }
            }
        }

        var preLen = hashKeys.Length;
        instanceIDToBiomeDictionary_ExpandList(index);
        instanceIDToBiomeDictionary__keys[index][preLen] = key;
        instanceIDToBiomeDictionary__values[index][preLen] = value;
        instanceIDToBiomeDictionary__size++;
        return true;
    }

    const int instanceIDToBiomeDictionary_expand = 5;
    void instanceIDToBiomeDictionary_ExpandList(int index)
    {
        var hashKeys = instanceIDToBiomeDictionary__keys[index];
        var hashValues = instanceIDToBiomeDictionary__values[index];
        var len = instanceIDToBiomeDictionary__keys[index].Length + instanceIDToBiomeDictionary_expand;
        var newKeys = new int[len];
        var newValues = new Biome[len];
        for (int i = 0; i < instanceIDToBiomeDictionary__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = instanceIDToBiomeDictionary__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        instanceIDToBiomeDictionary__keys[index] = newKeys;
        instanceIDToBiomeDictionary__values[index] = newValues;
    }

    public void instanceIDToBiomeDictionary_AddOrSetValue(int key, Biome value)
    {
        int index = instanceIDToBiomeDictionary_Hash(key);
        var hashKeys = instanceIDToBiomeDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    instanceIDToBiomeDictionary__keys[index][i] = key;
                    instanceIDToBiomeDictionary__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    instanceIDToBiomeDictionary__keys[index][i] = key;
                    instanceIDToBiomeDictionary__values[index][i] = value;
                    instanceIDToBiomeDictionary__size++;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    instanceIDToBiomeDictionary__keys[index][i] = key;
                    instanceIDToBiomeDictionary__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == default)
                {
                    instanceIDToBiomeDictionary__keys[index][i] = key;
                    instanceIDToBiomeDictionary__values[index][i] = value;
                    instanceIDToBiomeDictionary__size++;
                    return;
                }
            }
        }

        var preLen = hashKeys.Length;
        instanceIDToBiomeDictionary_ExpandList(index);
        instanceIDToBiomeDictionary__keys[index][preLen] = key;
        instanceIDToBiomeDictionary__values[index][preLen] = value;
        instanceIDToBiomeDictionary__size++;
    }

    public void instanceIDToBiomeDictionary_SetValue(int key, Biome value)
    {
        int index = instanceIDToBiomeDictionary_Hash(key);
        var hashKeys = instanceIDToBiomeDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    instanceIDToBiomeDictionary__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    instanceIDToBiomeDictionary__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public Biome instanceIDToBiomeDictionary_GetValue(int key)
    {
        int index = instanceIDToBiomeDictionary_Hash(key);
        var hashKeys = instanceIDToBiomeDictionary__keys[index];
        var hashValues = instanceIDToBiomeDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void instanceIDToBiomeDictionary_Remove(int key)
    {
        int index = instanceIDToBiomeDictionary_Hash(key);
        var hashKeys = instanceIDToBiomeDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    instanceIDToBiomeDictionary__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    instanceIDToBiomeDictionary__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public override void BreakCell(GameObject cell)
    {
        // gc alloc debug only
        /*if(cell!=null){
            var cellId=cell.GetInstanceID();
            var globalCellIndex=instanceIDToGlobalCellIndexDictionary.GetValue(cellId);
            permanentBreakCellDictionary.AddOrSetValue(globalCellIndex,true);
            //tempBreakCellDictionary.AddOrSetValue(cellId,true); // may colision this is beacause not broken cells disappaer bug haapens 
            UnloadCell(cell,cellId);
        } else {
            Debug.LogWarning("Cell pool is empty!");
        }*/
        var cellId = cell.GetInstanceID();
        var globalCellIndex = instanceIDToGlobalCellIndexDictionary_GetValueOrDefault(cellId, int.MaxValue);
        if (globalCellIndex != int.MaxValue)
        {
            permanentBreakCellDictionary_AddOrSetValue(globalCellIndex, true);
            if (permanentBreakCellArrLength < permanentBreakCellArr.Length)
            {
                permanentBreakCellArr[permanentBreakCellArrLength] = globalCellIndex;
                permanentBreakCellArrLength++;
            }
        }
        else
        {
            Debug.LogWarning(cellId + " :globalCellIndex is -1");
        }

        //tempBreakCellDictionary.AddOrSetValue(cellId,true); // may colision this is beacause not broken cells disappaer bug haapens 
        var biome = instanceIDToBiomeDictionary_GetValue(cellId);
        UnloadCell(cell, cellId, biome);
    }

    int permanentBreakCellArrLength = 0;
    public override void BreakCells(GameObject[] cells, int length)
    {
        for (int i = 0; i < length; i++)
        {
            var cell = cells[i];
            var cellId = cell.GetInstanceID();
            var globalCellIndex = instanceIDToGlobalCellIndexDictionary_GetValueOrDefault(cellId, int.MaxValue);
            if (globalCellIndex != int.MaxValue)
            {
                permanentBreakCellDictionary_AddOrSetValue(globalCellIndex, true);
                if (permanentBreakCellArrLength < permanentBreakCellArr.Length)
                {
                    permanentBreakCellArr[permanentBreakCellArrLength] = globalCellIndex;
                    permanentBreakCellArrLength++;
                }
            }
            else
            {
                Debug.LogWarning(cellId + " :globalCellIndex is -1");
            }

            var biome = instanceIDToBiomeDictionary_GetValue(cellId);
            meshCombiner_BreakCell(cell, cellId);
        //UnloadCell(cell,cellId,biome);
        }
    }

    void UnloadCell(GameObject cell, int id, Biome biomeType)
    {
        if (!instanceIDToGlobalCellIndexDictionary_TryRemove(id))
        {
            Debug.LogWarning("UnloadCell: instanceIDToGlobalCellIndexDictionary not has item " + id);
        }

        BiomeReturn(biomeType, cell, id);
    }

    float scale => settings_scale;

    float TileScale => settings_TileScale;

    float xValue, zValue, perlinValue, height, xTValue, zTValue, xHValue, zHValue;
    Vector3 spawnPos;
    [UdonSynced]
    float _seedX;
    [UdonSynced]
    float _seedZ;
    [UdonSynced]
    float _seedTX;
    [UdonSynced]
    float _seedTZ;
    [UdonSynced]
    float _seedHX;
    [UdonSynced]
    float _seedHZ;
    [SerializeField]
    Transform chunkParent;
    public bool meshCombiner_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        meshCombiner_itemOperator_col.enabled = active;
        meshCombiner_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool meshCombiner_itemOperator_SetColliderActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        meshCombiner_itemOperator_col.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    //[SerializeField]int capacity=300000;
    void meshCombiner_itemOperator_Start()
    {
    //idToColDict.SetCapacity(capacity);
    //idToMeshDict.SetCapacity(capacity);
    }

    //[SerializeField,UnrollAttribute]IntToBoxColliderDictionary idToColDict;
    //[SerializeField,UnrollAttribute]IntToMeshRendererDictionary idToMeshDict;
    BoxCollider meshCombiner_itemOperator_col;
    MeshRenderer meshCombiner_itemOperator_mesh;
    public bool meshCombiner_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        meshCombiner_itemOperator_col = obj.GetComponent<BoxCollider>();
        meshCombiner_itemOperator_mesh = obj.GetComponent<MeshRenderer>();
        meshCombiner_itemOperator_col.enabled = active;
        meshCombiner_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool meshCombiner_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (meshCombiner_itemOperator_col == null || meshCombiner_itemOperator_mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return meshCombiner_itemOperator_col.enabled && meshCombiner_itemOperator_mesh.enabled;
    }

    public bool meshCombiner_chunkOperator_SetActive(GameObject obj, bool active)
    {
        MeshCollider col = obj.GetComponent<MeshCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        /*if(col==null||mesh==null){
            Debug.LogError("TilePoolItemOperator: MeshCollider or MeshRenderer is null!");
            return false;
        } gc alloc */
        col.enabled = active;
        mesh.enabled = active;
        //mesh.material.SetFloat("_UpDown",0);// コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    //[SerializeField,UnrollAttribute]IntToMeshColliderDictionary idToColDict;
    //[SerializeField,UnrollAttribute]IntToMeshRendererDictionary idToMeshDict;
    /*[SerializeField]int capacity=100000;

    void Start()
    {
        idToColDict.SetCapacity(capacity);
        idToMeshDict.SetCapacity(capacity);
    }*/
    public bool meshCombiner_chunkOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        return meshCombiner_chunkOperator_SetActive(obj, active);
    /*MeshCollider col;
        if(idToColDict.HasItem(instanceID)){
            col=idToColDict.GetValue(instanceID);
        }else{
            col = obj.GetComponent<MeshCollider>();
            idToColDict.Add(instanceID,col);
        }
        MeshRenderer mesh;
        if(idToMeshDict.HasItem(instanceID)){
            mesh=idToMeshDict.GetValue(instanceID);
        }else{
            mesh = obj.GetComponent<MeshRenderer>();
            idToMeshDict.Add(instanceID,mesh);
        }
        col.enabled=active;
        mesh.enabled=active;
        return true;*/
    }

    public bool meshCombiner_chunkOperator_IsActive(GameObject obj)
    {
        MeshCollider col = obj.GetComponent<MeshCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: MeshCollider or MeshRenderer is null!");
            return false;
        }

        return mesh.enabled;
    }

    /*public  GameObject[] GetAllParts(int count){
        var target=allPartsCache[count];
        if(target==null){
            target=new GameObject[count];
            allPartsCache[count]=target;
        }
        return target;

    }*/
    //CombineInstance[][] combineCache ;
    //GameObject[][] allPartsCache;
    void meshCombiner_Start()
    {
        meshCombiner_itemOperator_Start();
    //combineCache = new CombineInstance[size*size*size][];
    //allPartsCache = new GameObject[10][];
    }

    public void meshCombiner_BreakCell(GameObject cell, int id)
    {
        meshCombiner_itemOperator_SetActive(cell, id, false);
    }

    public void meshCombiner_SwitchCombineMesh(bool active, GameObject outline, int outlineId, GameObject[] cells, int[] cellIds, bool[] brokenArr)
    {
        meshCombiner_chunkOperator_SetActive(outline, outlineId, active);
        /*for(int i=1;i<outlines.Length;i++){
            itemOperator.SetActive(outlines[i],!active);
        }*/
        if (active)
        {
            for (int i = 0; i < cells.Length; i++)
            {
                meshCombiner_itemOperator_SetActive(cells[i], cellIds[i], false);
            /*if(colOnlyArr[i]){
                    itemOperator.SetColliderActive(cells[i],true);
                }*/
            }
        }
        else
        {
            for (int i = 0; i < cells.Length; i++)
            {
                meshCombiner_itemOperator_SetActive(cells[i], cellIds[i], !brokenArr[i]);
            }
        }
    }

    CombineInstance[] meshCombiner_combine;
    MeshFilter meshCombiner_parentMeshFilter;
    MeshCollider meshCombiner_meshCol;
    public GameObject meshCombiner_CombineMesh(GameObject fieldParent, MeshFilter[] meshFilters, int[] ids, bool isInDetailRange, bool[] brokenArr, bool hasItem)
    {
        meshCombiner_parentMeshFilter = fieldParent.GetComponent<MeshFilter>(); //CheckParentComponent<MeshFilter>(fieldParent.gameObject);
        /*if(parentMeshFilter==null ){
            Debug.LogError("Parent object has no MeshFilter !");
        }*/
        // 親オブジェクトにMeshRendererがあるかどうか確認します。
        //MeshRenderer parentMeshRenderer = fieldParent.GetComponent<MeshRenderer>();//(fieldParent.gameObject);
        /*if(parentMeshRenderer== null){
            Debug.LogError("Parent object has no  MeshRenderer!");
        }*/
        // 子オブジェクトのMeshFilterへの参照を配列として保持します。
        // ただし、親オブジェクトのメッシュもGetComponentsInChildrenに含まれるので除外します。
        //MeshFilter[] meshFilters = fieldParent.GetComponentsInChildren<MeshFilter>();
        /*Material combinedMat = meshFilters[0].GetComponent<MeshRenderer>().material;
        int combineCount=0;
        foreach(var mesh in meshFilters){
            if(mesh.GetComponent<MeshRenderer>().material.name==combinedMat.name){
                combineCount++;
            }
        }*/
        int combineCount = 0;
        for (int i = 0; i < meshFilters.Length; i++)
        {
            if (!brokenArr[i])
            {
                combineCount++;
            }
        }

        int combineIndex = 0;
        // 結合するメッシュの配列を作成します。
        if (meshCombiner_combine == null && !hasItem)
            meshCombiner_combine = new CombineInstance[combineCount];
        //CombineInstance[] combine = GetCombine(combineCount);//new CombineInstance[combineCount];//
        //GameObject[] allParts = new GameObject[meshFilters.Length-combineCount+1];
        //GameObject[] allParts = new GameObject[1];
        //allParts[0]=fieldParent;
        // 結合するメッシュの情報をCombineInstanceに追加していきます。
        for (int i = 0; i < meshFilters.Length; i++)
        {
            var mesh = meshFilters[i];
            //TODO: destory block dictionaryを参照する
            if (!hasItem && !brokenArr[i])
            {
                meshCombiner_combine[combineIndex].mesh = mesh.sharedMesh;
                meshCombiner_combine[combineIndex].transform = mesh.transform.localToWorldMatrix;
                combineIndex++;
            }

            if (isInDetailRange)
            {
                meshCombiner_itemOperator_SetActive(mesh.gameObject, ids[i], !brokenArr[i]); // try to spawnでtrueは保証されている
            }
            else
            {
                meshCombiner_itemOperator_SetActive(mesh.gameObject, ids[i], false); // try to spawnでtrueは保証されている
            /*if(colOnlyArr[i]){
                    itemOperator.SetColliderActive(mesh.gameObject,true);
                }*/
            }
        /*if(mesh.GetComponent<MeshRenderer>().material.name==combinedMat.name){
                combine[index].mesh = mesh.sharedMesh;
                combine[index].transform = mesh.transform.localToWorldMatrix;
                itemOperator.SetActive(mesh.gameObject,false);
                index++;
            } else {
                //allParts[restIndex]=mesh.gameObject;
                restIndex++;
                itemOperator.SetActive(mesh.gameObject,true);
                Debug.LogWarning("MeshCombiner: MeshRenderer material is not same as parent material. ");
            }*/
        }

        if (!hasItem)
        {
            meshCombiner_parentMeshFilter.mesh = new Mesh();
            meshCombiner_parentMeshFilter.mesh.CombineMeshes(meshCombiner_combine);
            meshCombiner_meshCol = fieldParent.GetComponent<MeshCollider>();
            meshCombiner_meshCol.sharedMesh = meshCombiner_parentMeshFilter.mesh;
        }

        meshCombiner_chunkOperator_SetActive(fieldParent, !isInDetailRange);
        return fieldParent;
    }

    MeshFilter[] meshFilters;
    int[][] chunkToCellsDict__keys;
    GameObject[][][] chunkToCellsDict__values;
    int chunkToCellsDict__size;
    public int chunkToCellsDict_Count => chunkToCellsDict__size;

    const int chunkToCellsDict_bucketCount = 1;
    public void chunkToCellsDict_SetCapacity(int capacity)
    {
        int len = capacity / chunkToCellsDict_bucketCount;
        chunkToCellsDict__keys = new int[len][];
        for (int i = 0; i < chunkToCellsDict__keys.Length; i++)
        {
            chunkToCellsDict__keys[i] = new int[chunkToCellsDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < chunkToCellsDict_bucketCount; i++)
        {
            chunkToCellsDict__keys[0][i] = int.MaxValue;
        }

        chunkToCellsDict__values = new GameObject[len][][];
        for (int i = 0; i < chunkToCellsDict__values.Length; i++)
        {
            chunkToCellsDict__values[i] = new GameObject[chunkToCellsDict_bucketCount][];
        }
    }

    public bool chunkToCellsDict_HasItem(int key)
    {
        var index = chunkToCellsDict_Hash(key);
        var hashKeys = chunkToCellsDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int chunkToCellsDict_Hash(int key)
    {
        var len = chunkToCellsDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public int[] chunkToCellsDict_GenerateKeysArray()
    {
        int[] keys = new int[chunkToCellsDict__size];
        int index = 0;
        for (int i = 0; i < chunkToCellsDict__keys.Length; i++)
        {
            var hashKeys = chunkToCellsDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    public bool chunkToCellsDict_Add(int key, GameObject[] value)
    {
        int index = chunkToCellsDict_Hash(key);
        var hashKeys = chunkToCellsDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkToCellsDict__keys[index][i] = key;
                    chunkToCellsDict__values[index][i] = value;
                    chunkToCellsDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    chunkToCellsDict__keys[index][i] = key;
                    chunkToCellsDict__values[index][i] = value;
                    chunkToCellsDict__size++;
                    return true;
                }
            }
        }

        var preLen = hashKeys.Length;
        chunkToCellsDict_ExpandList(index);
        chunkToCellsDict__keys[index][preLen] = key;
        chunkToCellsDict__values[index][preLen] = value;
        chunkToCellsDict__size++;
        return true;
    }

    const int chunkToCellsDict_expand = 5;
    void chunkToCellsDict_ExpandList(int index)
    {
        var hashKeys = chunkToCellsDict__keys[index];
        var hashValues = chunkToCellsDict__values[index];
        var len = chunkToCellsDict__keys[index].Length + chunkToCellsDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len][];
        for (int i = 0; i < chunkToCellsDict__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = chunkToCellsDict__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        chunkToCellsDict__keys[index] = newKeys;
        chunkToCellsDict__values[index] = newValues;
    }

    public void chunkToCellsDict_AddOrSetValue(int key, GameObject[] value)
    {
        int index = chunkToCellsDict_Hash(key);
        var hashKeys = chunkToCellsDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkToCellsDict__keys[index][i] = key;
                    chunkToCellsDict__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkToCellsDict__keys[index][i] = key;
                    chunkToCellsDict__values[index][i] = value;
                    chunkToCellsDict__size++;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkToCellsDict__keys[index][i] = key;
                    chunkToCellsDict__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == default)
                {
                    chunkToCellsDict__keys[index][i] = key;
                    chunkToCellsDict__values[index][i] = value;
                    chunkToCellsDict__size++;
                    return;
                }
            }
        }

        var preLen = hashKeys.Length;
        chunkToCellsDict_ExpandList(index);
        chunkToCellsDict__keys[index][preLen] = key;
        chunkToCellsDict__values[index][preLen] = value;
        chunkToCellsDict__size++;
    }

    public void chunkToCellsDict_SetValue(int key, GameObject[] value)
    {
        int index = chunkToCellsDict_Hash(key);
        var hashKeys = chunkToCellsDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkToCellsDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkToCellsDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject[] chunkToCellsDict_GetValue(int key)
    {
        int index = chunkToCellsDict_Hash(key);
        var hashKeys = chunkToCellsDict__keys[index];
        var hashValues = chunkToCellsDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void chunkToCellsDict_Remove(int key)
    {
        int index = chunkToCellsDict_Hash(key);
        var hashKeys = chunkToCellsDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    chunkToCellsDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    chunkToCellsDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    GameObject chunkPool_prefab;
    public void chunkPool_SetPrefab(GameObject prefab)
    {
        this.chunkPool_prefab = chunkPool_prefab;
    }

    int[][] chunkPool_idToObjDict__keys;
    GameObject[][] chunkPool_idToObjDict__values;
    int chunkPool_idToObjDict__size;
    public int chunkPool_idToObjDict_Count => chunkPool_idToObjDict__size;

    public int[] chunkPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[chunkPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < chunkPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = chunkPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int chunkPool_idToObjDict_bucketCount = 1;
    public int chunkPool_idToObjDict_KeyLength => chunkPool_idToObjDict__keys.Length;

    public void chunkPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / chunkPool_idToObjDict_bucketCount;
        chunkPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            chunkPool_idToObjDict__keys[i] = new int[chunkPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < chunkPool_idToObjDict_bucketCount; i++)
        {
            chunkPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        chunkPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            chunkPool_idToObjDict__values[i] = new GameObject[chunkPool_idToObjDict_bucketCount];
        }
    }

    public bool chunkPool_idToObjDict_HasItem(int key)
    {
        var index = chunkPool_idToObjDict_Hash(key);
        var hashKeys = chunkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int chunkPool_idToObjDict_Hash(int key)
    {
        var len = chunkPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool chunkPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = chunkPool_idToObjDict_Hash(key);
        var hashKeys = chunkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkPool_idToObjDict__keys[index][i] = key;
                    chunkPool_idToObjDict__values[index][i] = value;
                    chunkPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    chunkPool_idToObjDict__keys[index][i] = key;
                    chunkPool_idToObjDict__values[index][i] = value;
                    chunkPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        chunkPool_idToObjDict_ExpandList(index);
        chunkPool_idToObjDict__keys[index][preLen] = key;
        chunkPool_idToObjDict__values[index][preLen] = value;
        chunkPool_idToObjDict__size++;
        return true;
    }

    const int chunkPool_idToObjDict_expand = 5;
    void chunkPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = chunkPool_idToObjDict__keys[index];
        var hashValues = chunkPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + chunkPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        chunkPool_idToObjDict__keys[index] = newKeys;
        chunkPool_idToObjDict__values[index] = newValues;
    }

    public bool chunkPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = chunkPool_idToObjDict_Hash(key);
        var hashKeys = chunkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkPool_idToObjDict__keys[index][i] = key;
                    chunkPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkPool_idToObjDict__keys[index][i] = key;
                    chunkPool_idToObjDict__values[index][i] = value;
                    chunkPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkPool_idToObjDict__keys[index][i] = key;
                    chunkPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    chunkPool_idToObjDict__keys[index][i] = key;
                    chunkPool_idToObjDict__values[index][i] = value;
                    chunkPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        chunkPool_idToObjDict_ExpandList(index);
        chunkPool_idToObjDict__keys[index][preLen] = key;
        chunkPool_idToObjDict__values[index][preLen] = value;
        chunkPool_idToObjDict__size++;
        return true;
    }

    public void chunkPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = chunkPool_idToObjDict_Hash(key);
        var hashKeys = chunkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject chunkPool_idToObjDict_GetValue(int key)
    {
        int index = chunkPool_idToObjDict_Hash(key);
        var hashKeys = chunkPool_idToObjDict__keys[index];
        var hashValues = chunkPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject chunkPool_idToObjDict_TryGetValue(int key)
    {
        int index = chunkPool_idToObjDict_Hash(key);
        var hashKeys = chunkPool_idToObjDict__keys[index];
        var hashValues = chunkPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void chunkPool_idToObjDict_Remove(int key)
    {
        int index = chunkPool_idToObjDict_Hash(key);
        var hashKeys = chunkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    chunkPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    chunkPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int chunkPool_Capacity = 50021;
    public bool chunkPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        MeshCollider col = obj.GetComponent<MeshCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        /*if(col==null||mesh==null){
            Debug.LogError("TilePoolItemOperator: MeshCollider or MeshRenderer is null!");
            return false;
        } gc alloc */
        col.enabled = active;
        mesh.enabled = active;
        //mesh.material.SetFloat("_UpDown",0);// コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    //[SerializeField,UnrollAttribute]IntToMeshColliderDictionary idToColDict;
    //[SerializeField,UnrollAttribute]IntToMeshRendererDictionary idToMeshDict;
    /*[SerializeField]int capacity=100000;

    void Start()
    {
        idToColDict.SetCapacity(capacity);
        idToMeshDict.SetCapacity(capacity);
    }*/
    public bool chunkPool_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        return chunkPool_itemOperator_SetActive(obj, active);
    /*MeshCollider col;
        if(idToColDict.HasItem(instanceID)){
            col=idToColDict.GetValue(instanceID);
        }else{
            col = obj.GetComponent<MeshCollider>();
            idToColDict.Add(instanceID,col);
        }
        MeshRenderer mesh;
        if(idToMeshDict.HasItem(instanceID)){
            mesh=idToMeshDict.GetValue(instanceID);
        }else{
            mesh = obj.GetComponent<MeshRenderer>();
            idToMeshDict.Add(instanceID,mesh);
        }
        col.enabled=active;
        mesh.enabled=active;
        return true;*/
    }

    public bool chunkPool_itemOperator_IsActive(GameObject obj)
    {
        MeshCollider col = obj.GetComponent<MeshCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: MeshCollider or MeshRenderer is null!");
            return false;
        }

        return mesh.enabled;
    }

    int chunkPool_poolSize;
    private int[] chunkPool_notActiveObjQueue__array;
    private int chunkPool_notActiveObjQueue__head; // First valid element in the queue.
    private int chunkPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int chunkPool_notActiveObjQueue__size; // Number of elements.
    private int chunkPool_notActiveObjQueue__version;
    private const int chunkPool_notActiveObjQueue_MinimumGrow = 100000;
    public int chunkPool_notActiveObjQueue_Count => chunkPool_notActiveObjQueue__size;
    public int chunkPool_notActiveObjQueue_Version => chunkPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int chunkPool_notActiveObjQueue_GetCount() => chunkPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int chunkPool_notActiveObjQueue_GetVersion() => chunkPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void chunkPool_notActiveObjQueue_Clear()
    {
        chunkPool_notActiveObjQueue__size = 0;
        chunkPool_notActiveObjQueue__head = 0;
        chunkPool_notActiveObjQueue__tail = 0;
        chunkPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void chunkPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < chunkPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = chunkPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = chunkPool_notActiveObjQueue__array.Length - chunkPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(chunkPool_notActiveObjQueue__array, chunkPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(chunkPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void chunkPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (chunkPool_notActiveObjQueue__array == null)
        {
            chunkPool_notActiveObjQueue_SetCapacity(chunkPool_notActiveObjQueue_MinimumGrow);
        }
        else if (chunkPool_notActiveObjQueue__size == chunkPool_notActiveObjQueue__array.Length)
        {
            chunkPool_notActiveObjQueue_SetCapacity(chunkPool_notActiveObjQueue__array.Length + chunkPool_notActiveObjQueue_MinimumGrow);
        }

        chunkPool_notActiveObjQueue__array[chunkPool_notActiveObjQueue__tail] = obj;
        chunkPool_notActiveObjQueue__tail = (chunkPool_notActiveObjQueue__tail + 1) % chunkPool_notActiveObjQueue__array.Length;
        chunkPool_notActiveObjQueue__size++;
        chunkPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int chunkPool_notActiveObjQueue_Dequeue()
    {
        if (chunkPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = chunkPool_notActiveObjQueue__array[chunkPool_notActiveObjQueue__head];
        chunkPool_notActiveObjQueue__array[chunkPool_notActiveObjQueue__head] = int.MaxValue;
        chunkPool_notActiveObjQueue__head = (chunkPool_notActiveObjQueue__head + 1) % chunkPool_notActiveObjQueue__array.Length;
        chunkPool_notActiveObjQueue__size--;
        chunkPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int chunkPool_notActiveObjQueue_Peek()
    {
        if (chunkPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return chunkPool_notActiveObjQueue__array[chunkPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] chunkPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[chunkPool_notActiveObjQueue__size];
        if (chunkPool_notActiveObjQueue__size == 0)
        {
        }
        else if (chunkPool_notActiveObjQueue__head < chunkPool_notActiveObjQueue__tail)
        {
            Array.Copy(chunkPool_notActiveObjQueue__array, chunkPool_notActiveObjQueue__head, arr, 0, chunkPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = chunkPool_notActiveObjQueue__array.Length - chunkPool_notActiveObjQueue__head;
            Array.Copy(chunkPool_notActiveObjQueue__array, chunkPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(chunkPool_notActiveObjQueue__array, 0, arr, toHead, chunkPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void chunkPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (chunkPool_notActiveObjQueue__size == 0)
        {
        }
        else if (chunkPool_notActiveObjQueue__head < chunkPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(chunkPool_notActiveObjQueue__array, chunkPool_notActiveObjQueue__head, newArray, 0, chunkPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = chunkPool_notActiveObjQueue__array.Length - chunkPool_notActiveObjQueue__head;
            Array.Copy(chunkPool_notActiveObjQueue__array, chunkPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(chunkPool_notActiveObjQueue__array, 0, newArray, toHead, chunkPool_notActiveObjQueue__tail);
        }

        chunkPool_notActiveObjQueue__array = newArray;
        chunkPool_notActiveObjQueue__head = 0;
        chunkPool_notActiveObjQueue__tail = chunkPool_notActiveObjQueue__size == capacity ? 0 : chunkPool_notActiveObjQueue__size;
        chunkPool_notActiveObjQueue__version++;
    }

    //[SerializeField]Transform parent;
    void chunkPool_Start()
    {
        chunkPool_idToObjDict_SetCapacity(chunkPool_Capacity);
        chunkPool_notActiveObjQueue_SetCapacity(chunkPool_Capacity);
    }

    public bool chunkPool_PeekIsInstantiated()
    {
        return chunkPool_isInstantiated;
    }

    bool chunkPool_isInstantiated = false;
    public void chunkPool_Store(Transform p = null)
    {
        if (chunkPool_idToObjDict_Count > chunkPool_idToObjDict_KeyLength)
            return;
        chunkPool_isInstantiated = true;
        GameObject instance;
        int id;
        chunkPool_instance = GameObject.Instantiate(chunkPool_prefab);
        //gc alloc debug only
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        //id = GetInstanceID(instance);/*instance.GetInstanceID();*///.GetHashCode();
        id = chunkPool_instance.GetInstanceID();
        chunkPool_itemOperator_SetActive(chunkPool_instance, id, false);
        chunkPool_idToObjDict_Add(id, chunkPool_instance);
        chunkPool_notActiveObjQueue_Enqueue(id);
    }

    GameObject chunkPool_instance;
    // falseで出してmeshcombinerで切り替える
    int chunkPool_uniqueId = 0;
    public GameObject chunkPool_TryToSpawn()
    {
        int id;
        chunkPool_isInstantiated = true;
        if (chunkPool_notActiveObjQueue_Count > 0)
        {
            chunkPool_isInstantiated = false;
            id = chunkPool_notActiveObjQueue_Dequeue();
            if (chunkPool_idToObjDict_HasItem(id))
            {
                var obj = chunkPool_idToObjDict_GetValue(id);
                //itemOperator.SetActive(obj,id,true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        chunkPool_instance = GameObject.Instantiate(chunkPool_prefab);
        //gc alloc
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        id = chunkPool_instance.GetInstanceID();
        chunkPool_idToObjDict_Add(id, chunkPool_instance); // gc alloc
        //itemOperator.SetActive(instance,id,true);
        //}while(!idToObjDict.Add(id,instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return chunkPool_instance;
    }

    public GameObject chunkPool_TryToSpawn(int id)
    {
        chunkPool_isInstantiated = false;
        if (chunkPool_idToObjDict_HasItem(id))
        {
            var obj = chunkPool_idToObjDict_GetValue(id);
            chunkPool_itemOperator_SetActive(obj, id, false);
            return obj;
        }
        else
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return null;
        }
    }

    public void chunkPool_Return(GameObject obj, bool force = false, bool enqueue = true)
    {
        // gc alloc debug only
        //if(obj==null)return; // gc alloc debug only
        int id = obj.GetInstanceID(); //obj.GetInstanceID();
        if (!chunkPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        chunkPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            chunkPool_notActiveObjQueue_Enqueue(id);
    }

    public void chunkPool_Return(GameObject obj, int id, bool force = false, bool enqueue = true)
    {
        //if(obj==null)return; // gc alloc debug only
        if (!chunkPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        chunkPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            chunkPool_notActiveObjQueue_Enqueue(id);
    }

    public bool chunkPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(chunkPool_prefab.name);
    }

    public void chunkPool_Clear()
    {
        chunkPool_notActiveObjQueue_Clear();
        foreach (var obj in chunkPool_idToObjDict_GenerateKeysArray())
        {
            chunkPool_itemOperator_SetActive(chunkPool_idToObjDict_GetValue(obj), false);
            chunkPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    GameObject[] generatingCells;
    Biome[] generatingCellBiomes;
    int[] generatingCellInstanceIds;
    int chunkXIndex, chunkYIndex, chunkZIndex;
    int chunkID;
    public const string IndestructibleTag = "Cell";
    public const string CellTag = "Cell";
    int ToChunkIndex(int x, int z)
    {
        return (z - ZSTARTINDEX) * chunkWidth + (x - XSTARTINDEX);
    }

    int ToLocalCellIndex(int xIndex, int yIndex, int zIndex)
    {
        return (xIndex * chunkSize + zIndex) * chunkSizeY + yIndex;
    }

    int ToGlobalCellIndex(int localCellIndex, int chunkIndex)
    {
        return localCellIndex + chunkIndex * chunkSize * chunkSize * chunkSizeY;
    }

    GameObject chunkObj;
    GenerateChunkMode GenerateChunk()
    {
        int chunkIndex = ToChunkIndex(xStartChunkIndex, zStartChunkIndex);
        if (chunkStateDict_IsLoaded(chunkIndex))
            return GenerateChunkMode.Pass;
        bool isInit = false;
        if (chunkXIndex == 0 && chunkZIndex == 0 && chunkYIndex == 0)
        {
            //Debug.Log("GenerateChunk: "+chunkIndex);
            isInit = true;
            //gc alloc debug only
            //if(chunkObj!=null)Debug.LogError("chunkObj is not null");
            if (chunkIndexToInstanceIdDictionary_HasItem(chunkIndex))
            {
                int id = chunkIndexToInstanceIdDictionary_GetValue(chunkIndex);
                chunkObj = chunkPool_TryToSpawn(id);
            }
            else
            {
                chunkObj = chunkPool_TryToSpawn();
                chunkIndexToInstanceIdDictionary_Add(chunkIndex, chunkObj.GetInstanceID());
            }

            //Debug.Log("generate chunkID: "+chunkIndex);
            if (chunkToCellsDict_HasItem(chunkIndex))
            {
                generatingCells = chunkToCellsDict_GetValue(chunkIndex);
                generatingCellBiomes = chunkIndexToCellBiomesDictionary_GetValue(chunkIndex);
                generatingCellInstanceIds = chunkToCellInstanceIdsDictionary_GetValue(chunkIndex);
            }
            else
            {
                generatingCells = new GameObject[chunkSize * chunkSize * chunkSizeY];
                generatingCellBiomes = new Biome[chunkSize * chunkSize * chunkSizeY];
                generatingCellInstanceIds = new int[chunkSize * chunkSize * chunkSizeY];
            }
        }

        //MeshFilter[] meshFilters = new MeshFilter[chunkSize*chunkSize];
        var resCell = GenerateCell(xStartChunkIndex * chunkSize + chunkXIndex, zStartChunkIndex * chunkSize + chunkZIndex, chunkYIndex - chunkSizeY + 1, null);
        /*if(chunkYIndex<indestructibleLine){
            resCell.layer=LayerMask.NameToLayer(IndestructibleTag);
        } else {
            resCell.layer=LayerMask.NameToLayer(CellTag);
        }*/
        int localIndex = ToLocalCellIndex(chunkXIndex, chunkYIndex, chunkZIndex);
        int instanceId = resCell.GetInstanceID();
        meshFilters[localIndex] = resCell.GetComponent<MeshFilter>();
        generatingCells[localIndex] = resCell;
        generatingCellInstanceIds[localIndex] = instanceId;
        generatingCellBiomes[localIndex] = currentCellBiome;
        instanceIDToGlobalCellIndexDictionary_Add(instanceId, ToGlobalCellIndex(localIndex, chunkIndex));
        instanceIDToBiomeDictionary_AddOrSetValue(instanceId, currentCellBiome);
        chunkYIndex++;
        if (chunkYIndex == chunkSizeY)
        {
            chunkYIndex = 0;
            chunkZIndex++;
            //resCell.name+=IndestructibleTag; // 底は破壊不可能にする
            if (chunkZIndex == chunkSize)
            {
                chunkZIndex = 0;
                chunkXIndex++;
                if (chunkXIndex == chunkSize)
                {
                    if (!chunkToCellsDict_HasItem(chunkIndex))
                    {
                        chunkToCellsDict_Add(chunkIndex, generatingCells);
                        chunkIndexToCellBiomesDictionary_Add(chunkIndex, generatingCellBiomes);
                        chunkToCellInstanceIdsDictionary_Add(chunkIndex, generatingCellInstanceIds);
                    }
                    else
                    {
                    // no need to call
                    /*chunkToCellsDict.SetValue(chunkIndex,generatingCells);
                        chunkIndexToCellBiomesDictionary.SetValue(chunkIndex,generatingCellBiomes);
                        chunkToCellInstanceIdsDictionary.SetValue(chunkIndex,generatingCellInstanceIds);
                        */
                    }

                    bool isInDetailRange = IsInDetailRange(GetPlayerPosition(), xStartChunkIndex, zStartChunkIndex);
                    for (int i = 0; i < generatingCells.Length; i++)
                    {
                        brokenArr[i] = isInDetailRange && permanentBreakCellDictionary_GetValueOrDefault(ToGlobalCellIndex(i, chunkIndex), false);
                    }

                    chunkStateDict_AddOrSetValue(chunkIndex, isInDetailRange ? ChunkState.Detailed : ChunkState.UnDetailed);
                    var hasIItem = false; //outlineDict.HasItem(chunkIndex);
                    meshCombiner_CombineMesh(chunkObj, meshFilters, generatingCellInstanceIds, isInDetailRange, brokenArr, hasIItem);
                    outlineDict_AddOrSetValue(chunkIndex, chunkObj);
                    //}
                    //chunkObj=null;
                    return GenerateChunkMode.Complete;
                }
            }
        }

        if (isInit)
            return GenerateChunkMode.Init;
        return GenerateChunkMode.Generating;
    }

    [SerializeField]
    int indestructibleLine = 2;
    [SerializeField]
    Transform playerSpawnPos;
    [SerializeField]
    float IndestructibleRange = 5;
    public GameObject GenerateCell(int xIndex, int zIndex, int yIndex, Transform parent)
    {
        xValue = xIndex * scale + _seedX;
        zValue = zIndex * scale + _seedZ;
        perlinValue = fbm(xValue, zValue, 4, 0.4f); //Mathf.PerlinNoise(xValue, zValue);
        height = fieldHeight * (perlinValue - waterPercentage);
        height = Mathf.Round(height);
        spawnPos = new Vector3(xIndex, height + yIndex, zIndex) * TileScale;
        //spawnPos = new Vector3((xIndex)*TileScale,height,zIndex*TileScale);
        biomeCell = GenerateBiome(xIndex, zIndex, parent);
        biomeCell.transform.localPosition = spawnPos;
        ///////////////////////////
        // WARNING: 特別処理
        float playerSpawnChunkDist = (playerSpawnPos.position.x - spawnPos.x) * (playerSpawnPos.position.x - spawnPos.x) + (playerSpawnPos.position.z - spawnPos.z) * (playerSpawnPos.position.z - spawnPos.z);
        if (playerSpawnChunkDist < IndestructibleRange * IndestructibleRange)
        {
            biomeCell.layer = 22;
        }

        ////////////////////////////
        //gc alloc
        /*if(biomeCell!=null){
            biomeCell.transform.localPosition = spawnPos;
        } else {
            Debug.LogWarning("Chunk pool is empty!");
        }*/
        return biomeCell;
    }

    GameObject biomeCell;
    float scaleT => settings_scaleT;

    float scaleH => settings_scaleH;

    bool isInstantiated = false;
    Biome currentCellBiome = 0;
    GameObject GenerateBiome(int xIndex, int zIndex, Transform parent)
    {
        xTValue = xIndex * scaleT + _seedTX;
        zTValue = zIndex * scaleT + _seedTZ;
        xHValue = xIndex * scaleH + _seedHX;
        zHValue = zIndex * scaleH + _seedHZ;
        float temperature = Mathf.PerlinNoise(xTValue, zTValue);
        float humidity = Mathf.PerlinNoise(xHValue, zHValue);
        //humidity *= Mathf.Sqrt(1-(1-temperature)*(1-temperature));
        Biome biomeType;
        if (height <= 0)
            biomeType = Biome.Water;
        else
        {
            int tempIndex = Math.Min((int)(temperature * 5), 4);
            int humIndex = Math.Min((int)(humidity * 5), 4);
            switch (mission.PlanetType)
            {
                case PlanetType.Earth:
                    biomeType = biomeEarthMap[tempIndex][humIndex];
                    break;
                case PlanetType.Moon:
                    biomeType = biomeMoonMap[tempIndex][humIndex];
                    break;
                case PlanetType.Mars:
                    biomeType = biomeMarsMap[tempIndex][humIndex];
                    break;
                default:
                    Debug.LogError("PlanetType is not set");
                    biomeType = Biome.Water;
                    break;
            }
        }

        var cell = BiomeTryToSpawn(biomeType);
        currentCellBiome = biomeType;
        isInstantiated = BiomePeekIsInstantiated(biomeType);
        return cell;
    }

    float fbmTotal, fbmFrequency, fbmAmplitude, fbmMaxValue;
    int fbmIndex;
    float fbm(float x, float y, int octaves, float persistence)
    {
        fbmTotal = 0;
        fbmFrequency = 1;
        fbmAmplitude = 1;
        fbmMaxValue = 0; // Used for normalizing result to 0.0 - 1.0
        for (fbmIndex = 0; fbmIndex < octaves; fbmIndex++)
        {
            fbmTotal += Mathf.PerlinNoise(x * fbmFrequency, y * fbmFrequency) * fbmAmplitude;
            fbmMaxValue += fbmAmplitude;
            fbmAmplitude *= persistence;
            fbmFrequency *= 2;
        }

        return fbmTotal / fbmMaxValue;
    }
}