using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System.Runtime.InteropServices;
using System;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using UdonObjectPool;

[UdonBehaviourSyncMode(BehaviourSyncMode.Manual)]
public class UnrolledMapGenerator : UdonSharpBehaviour
{
    [SerializeField]
    GameObject grassPool_prefab;
    int[][] grassPool_idToObjDict__keys;
    GameObject[][] grassPool_idToObjDict__values;
    int grassPool_idToObjDict__size;
    public int grassPool_idToObjDict_Count => grassPool_idToObjDict__size;

    public int[] grassPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[grassPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < grassPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = grassPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    [SerializeField]
    int grassPool_idToObjDict_bucketCount = 4;
    public int grassPool_idToObjDict_KeyLength => grassPool_idToObjDict__keys.Length;

    public void grassPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / grassPool_idToObjDict_bucketCount;
        grassPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            grassPool_idToObjDict__keys[i] = new int[grassPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < grassPool_idToObjDict_bucketCount; i++)
        {
            grassPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        grassPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            grassPool_idToObjDict__values[i] = new GameObject[grassPool_idToObjDict_bucketCount];
        }
    }

    public bool grassPool_idToObjDict_HasItem(int key)
    {
        var index = grassPool_idToObjDict_Hash(key);
        var hashKeys = grassPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int grassPool_idToObjDict_Hash(int key)
    {
        var len = grassPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool grassPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = grassPool_idToObjDict_Hash(key);
        var hashKeys = grassPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    grassPool_idToObjDict__keys[index][i] = key;
                    grassPool_idToObjDict__values[index][i] = value;
                    grassPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    grassPool_idToObjDict__keys[index][i] = key;
                    grassPool_idToObjDict__values[index][i] = value;
                    grassPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full " + index);
        var preLen = hashKeys.Length;
        grassPool_idToObjDict_ExpandList(index);
        grassPool_idToObjDict__keys[index][preLen] = key;
        grassPool_idToObjDict__values[index][preLen] = value;
        grassPool_idToObjDict__size++;
        return true;
    }

    const int grassPool_idToObjDict_expand = 10;
    void grassPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = grassPool_idToObjDict__keys[index];
        var hashValues = grassPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + grassPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        grassPool_idToObjDict__keys[index] = newKeys;
        grassPool_idToObjDict__values[index] = newValues;
    }

    public bool grassPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = grassPool_idToObjDict_Hash(key);
        var hashKeys = grassPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    grassPool_idToObjDict__keys[index][i] = key;
                    grassPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    grassPool_idToObjDict__keys[index][i] = key;
                    grassPool_idToObjDict__values[index][i] = value;
                    grassPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    grassPool_idToObjDict__keys[index][i] = key;
                    grassPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    grassPool_idToObjDict__keys[index][i] = key;
                    grassPool_idToObjDict__values[index][i] = value;
                    grassPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        grassPool_idToObjDict_ExpandList(index);
        grassPool_idToObjDict__keys[index][preLen] = key;
        grassPool_idToObjDict__values[index][preLen] = value;
        grassPool_idToObjDict__size++;
        return true;
    }

    public void grassPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = grassPool_idToObjDict_Hash(key);
        var hashKeys = grassPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    grassPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    grassPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject grassPool_idToObjDict_GetValue(int key)
    {
        int index = grassPool_idToObjDict_Hash(key);
        var hashKeys = grassPool_idToObjDict__keys[index];
        var hashValues = grassPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void grassPool_idToObjDict_Remove(int key)
    {
        int index = grassPool_idToObjDict_Hash(key);
        var hashKeys = grassPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    grassPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    grassPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int grassPool_InitGenerateCount = 0;
    [SerializeField]
    int grassPool_Capacity = 100000;
    public bool grassPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        col.enabled = active;
        mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool grassPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return col.enabled && mesh.enabled;
    }

    int grassPool_poolSize;
    private int[] grassPool_notActiveObjQueue__array;
    private int grassPool_notActiveObjQueue__head; // First valid element in the queue.
    private int grassPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int grassPool_notActiveObjQueue__size; // Number of elements.
    private int grassPool_notActiveObjQueue__version;
    private const int grassPool_notActiveObjQueue_MinimumGrow = 100000;
    public int grassPool_notActiveObjQueue_Count => grassPool_notActiveObjQueue__size;
    public int grassPool_notActiveObjQueue_Version => grassPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int grassPool_notActiveObjQueue_GetCount() => grassPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int grassPool_notActiveObjQueue_GetVersion() => grassPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void grassPool_notActiveObjQueue_Clear()
    {
        if (grassPool_notActiveObjQueue__size != 0)
        {
            if (grassPool_notActiveObjQueue__head < grassPool_notActiveObjQueue__tail)
            {
                Array.Clear(grassPool_notActiveObjQueue__array, grassPool_notActiveObjQueue__head, grassPool_notActiveObjQueue__size);
            }
            else
            {
                Array.Clear(grassPool_notActiveObjQueue__array, grassPool_notActiveObjQueue__head, grassPool_notActiveObjQueue__array.Length - grassPool_notActiveObjQueue__head);
                Array.Clear(grassPool_notActiveObjQueue__array, 0, grassPool_notActiveObjQueue__tail);
            }

            grassPool_notActiveObjQueue__size = 0;
        }

        grassPool_notActiveObjQueue__head = 0;
        grassPool_notActiveObjQueue__tail = 0;
        grassPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void grassPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < grassPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = grassPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = grassPool_notActiveObjQueue__array.Length - grassPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(grassPool_notActiveObjQueue__array, grassPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(grassPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void grassPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (grassPool_notActiveObjQueue__array == null)
        {
            grassPool_notActiveObjQueue_SetCapacity(grassPool_notActiveObjQueue_MinimumGrow);
        }
        else if (grassPool_notActiveObjQueue__size == grassPool_notActiveObjQueue__array.Length)
        {
            grassPool_notActiveObjQueue_SetCapacity(grassPool_notActiveObjQueue__array.Length + grassPool_notActiveObjQueue_MinimumGrow);
        }

        grassPool_notActiveObjQueue__array[grassPool_notActiveObjQueue__tail] = obj;
        grassPool_notActiveObjQueue__tail = (grassPool_notActiveObjQueue__tail + 1) % grassPool_notActiveObjQueue__array.Length;
        grassPool_notActiveObjQueue__size++;
        grassPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int grassPool_notActiveObjQueue_Dequeue()
    {
        if (grassPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = grassPool_notActiveObjQueue__array[grassPool_notActiveObjQueue__head];
        grassPool_notActiveObjQueue__array[grassPool_notActiveObjQueue__head] = int.MaxValue;
        grassPool_notActiveObjQueue__head = (grassPool_notActiveObjQueue__head + 1) % grassPool_notActiveObjQueue__array.Length;
        grassPool_notActiveObjQueue__size--;
        grassPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int grassPool_notActiveObjQueue_Peek()
    {
        if (grassPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return grassPool_notActiveObjQueue__array[grassPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] grassPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[grassPool_notActiveObjQueue__size];
        if (grassPool_notActiveObjQueue__size == 0)
        {
        }
        else if (grassPool_notActiveObjQueue__head < grassPool_notActiveObjQueue__tail)
        {
            Array.Copy(grassPool_notActiveObjQueue__array, grassPool_notActiveObjQueue__head, arr, 0, grassPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = grassPool_notActiveObjQueue__array.Length - grassPool_notActiveObjQueue__head;
            Array.Copy(grassPool_notActiveObjQueue__array, grassPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(grassPool_notActiveObjQueue__array, 0, arr, toHead, grassPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void grassPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (grassPool_notActiveObjQueue__size == 0)
        {
        }
        else if (grassPool_notActiveObjQueue__head < grassPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(grassPool_notActiveObjQueue__array, grassPool_notActiveObjQueue__head, newArray, 0, grassPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = grassPool_notActiveObjQueue__array.Length - grassPool_notActiveObjQueue__head;
            Array.Copy(grassPool_notActiveObjQueue__array, grassPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(grassPool_notActiveObjQueue__array, 0, newArray, toHead, grassPool_notActiveObjQueue__tail);
        }

        grassPool_notActiveObjQueue__array = newArray;
        grassPool_notActiveObjQueue__head = 0;
        grassPool_notActiveObjQueue__tail = grassPool_notActiveObjQueue__size == capacity ? 0 : grassPool_notActiveObjQueue__size;
        grassPool_notActiveObjQueue__version++;
    }

    [SerializeField]
    Transform grassPool_parent;
    void grassPool_Start()
    {
        grassPool_poolSize = grassPool_InitGenerateCount;
        grassPool_idToObjDict_SetCapacity(grassPool_Capacity);
        grassPool_notActiveObjQueue_SetCapacity(grassPool_Capacity);
        for (int i = 0; i < grassPool_InitGenerateCount; i++)
        {
            int id;
            GameObject instance;
            do
            {
                instance = GameObject.Instantiate(grassPool_prefab);
                if (instance == null)
                {
                    Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
                }

                id = instance.GetInstanceID().GetHashCode();
            }
            while (!grassPool_idToObjDict_Add(id, instance));
            grassPool_itemOperator_SetActive(instance, false);
            grassPool_notActiveObjQueue_Enqueue(id);
        }
    }

    public bool grassPool_PeekIsInstantiated()
    {
        return grassPool_isInstantiated;
    }

    bool grassPool_isInstantiated = false;
    public void grassPool_Batch(PoolOperatorType[] opes, GameObject[] objs)
    {
        int i = 0;
        foreach (var ope in opes)
        {
            switch (ope)
            {
                case PoolOperatorType.TryToSpawn:
                    grassPool_TryToSpawn();
                    break;
                case PoolOperatorType.Return:
                    grassPool_Return(objs[i]);
                    i++;
                    break;
                case PoolOperatorType.Store:
                    grassPool_Store();
                    break;
                case PoolOperatorType.Clear:
                    grassPool_Clear();
                    break;
            }
        }
    }

    public void grassPool_Store(Transform p = null)
    {
        if (grassPool_idToObjDict_Count > grassPool_idToObjDict_KeyLength)
            return;
        grassPool_isInstantiated = true;
        GameObject instance;
        int id;
        do
        {
            instance = GameObject.Instantiate(grassPool_prefab);
            if (instance == null)
            {
                Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
            }

            id = instance.GetInstanceID().GetHashCode();
            grassPool_itemOperator_SetActive(instance, false);
        }
        while (!grassPool_idToObjDict_Add(id, instance));
        grassPool_notActiveObjQueue_Enqueue(id);
    }

    // falseで出してmeshcombinerで切り替える
    public GameObject grassPool_TryToSpawn(Transform p = null)
    {
        int id;
        grassPool_isInstantiated = true;
        if (grassPool_notActiveObjQueue_Count > 0)
        {
            grassPool_isInstantiated = false;
            id = grassPool_notActiveObjQueue_Dequeue();
            if (grassPool_idToObjDict_HasItem(id))
            {
                var obj = grassPool_idToObjDict_GetValue(id);
                grassPool_itemOperator_SetActive(obj, true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        GameObject instance;
        do
        {
            instance = GameObject.Instantiate(grassPool_prefab);
            if (instance == null)
            {
                Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
            }

            id = instance.GetInstanceID().GetHashCode();
        }
        while (!grassPool_idToObjDict_Add(id, instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return instance;
    }

    public void grassPool_Return(GameObject obj, bool force = false)
    {
        if (obj == null)
            return;
        int id = obj.GetInstanceID().GetHashCode();
        if (!grassPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        grassPool_itemOperator_SetActive(obj, false);
        grassPool_notActiveObjQueue_Enqueue(id);
    }

    public bool grassPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(grassPool_prefab.name);
    }

    public string grassPool_prefabName => grassPool_prefab.name;

    public void grassPool_Clear()
    {
        grassPool_notActiveObjQueue_Clear();
        foreach (var obj in grassPool_idToObjDict_GenerateKeysArray())
        {
            grassPool_itemOperator_SetActive(grassPool_idToObjDict_GetValue(obj), false);
            grassPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject tundraPool_prefab;
    int[][] tundraPool_idToObjDict__keys;
    GameObject[][] tundraPool_idToObjDict__values;
    int tundraPool_idToObjDict__size;
    public int tundraPool_idToObjDict_Count => tundraPool_idToObjDict__size;

    public int[] tundraPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[tundraPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < tundraPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = tundraPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    [SerializeField]
    int tundraPool_idToObjDict_bucketCount = 4;
    public int tundraPool_idToObjDict_KeyLength => tundraPool_idToObjDict__keys.Length;

    public void tundraPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / tundraPool_idToObjDict_bucketCount;
        tundraPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            tundraPool_idToObjDict__keys[i] = new int[tundraPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < tundraPool_idToObjDict_bucketCount; i++)
        {
            tundraPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        tundraPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            tundraPool_idToObjDict__values[i] = new GameObject[tundraPool_idToObjDict_bucketCount];
        }
    }

    public bool tundraPool_idToObjDict_HasItem(int key)
    {
        var index = tundraPool_idToObjDict_Hash(key);
        var hashKeys = tundraPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int tundraPool_idToObjDict_Hash(int key)
    {
        var len = tundraPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool tundraPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = tundraPool_idToObjDict_Hash(key);
        var hashKeys = tundraPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    tundraPool_idToObjDict__keys[index][i] = key;
                    tundraPool_idToObjDict__values[index][i] = value;
                    tundraPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    tundraPool_idToObjDict__keys[index][i] = key;
                    tundraPool_idToObjDict__values[index][i] = value;
                    tundraPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full " + index);
        var preLen = hashKeys.Length;
        tundraPool_idToObjDict_ExpandList(index);
        tundraPool_idToObjDict__keys[index][preLen] = key;
        tundraPool_idToObjDict__values[index][preLen] = value;
        tundraPool_idToObjDict__size++;
        return true;
    }

    const int tundraPool_idToObjDict_expand = 10;
    void tundraPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = tundraPool_idToObjDict__keys[index];
        var hashValues = tundraPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + tundraPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        tundraPool_idToObjDict__keys[index] = newKeys;
        tundraPool_idToObjDict__values[index] = newValues;
    }

    public bool tundraPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = tundraPool_idToObjDict_Hash(key);
        var hashKeys = tundraPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tundraPool_idToObjDict__keys[index][i] = key;
                    tundraPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    tundraPool_idToObjDict__keys[index][i] = key;
                    tundraPool_idToObjDict__values[index][i] = value;
                    tundraPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tundraPool_idToObjDict__keys[index][i] = key;
                    tundraPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    tundraPool_idToObjDict__keys[index][i] = key;
                    tundraPool_idToObjDict__values[index][i] = value;
                    tundraPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        tundraPool_idToObjDict_ExpandList(index);
        tundraPool_idToObjDict__keys[index][preLen] = key;
        tundraPool_idToObjDict__values[index][preLen] = value;
        tundraPool_idToObjDict__size++;
        return true;
    }

    public void tundraPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = tundraPool_idToObjDict_Hash(key);
        var hashKeys = tundraPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tundraPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tundraPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject tundraPool_idToObjDict_GetValue(int key)
    {
        int index = tundraPool_idToObjDict_Hash(key);
        var hashKeys = tundraPool_idToObjDict__keys[index];
        var hashValues = tundraPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void tundraPool_idToObjDict_Remove(int key)
    {
        int index = tundraPool_idToObjDict_Hash(key);
        var hashKeys = tundraPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    tundraPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    tundraPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int tundraPool_InitGenerateCount = 0;
    [SerializeField]
    int tundraPool_Capacity = 100000;
    public bool tundraPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        col.enabled = active;
        mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool tundraPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return col.enabled && mesh.enabled;
    }

    int tundraPool_poolSize;
    private int[] tundraPool_notActiveObjQueue__array;
    private int tundraPool_notActiveObjQueue__head; // First valid element in the queue.
    private int tundraPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int tundraPool_notActiveObjQueue__size; // Number of elements.
    private int tundraPool_notActiveObjQueue__version;
    private const int tundraPool_notActiveObjQueue_MinimumGrow = 100000;
    public int tundraPool_notActiveObjQueue_Count => tundraPool_notActiveObjQueue__size;
    public int tundraPool_notActiveObjQueue_Version => tundraPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int tundraPool_notActiveObjQueue_GetCount() => tundraPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int tundraPool_notActiveObjQueue_GetVersion() => tundraPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void tundraPool_notActiveObjQueue_Clear()
    {
        if (tundraPool_notActiveObjQueue__size != 0)
        {
            if (tundraPool_notActiveObjQueue__head < tundraPool_notActiveObjQueue__tail)
            {
                Array.Clear(tundraPool_notActiveObjQueue__array, tundraPool_notActiveObjQueue__head, tundraPool_notActiveObjQueue__size);
            }
            else
            {
                Array.Clear(tundraPool_notActiveObjQueue__array, tundraPool_notActiveObjQueue__head, tundraPool_notActiveObjQueue__array.Length - tundraPool_notActiveObjQueue__head);
                Array.Clear(tundraPool_notActiveObjQueue__array, 0, tundraPool_notActiveObjQueue__tail);
            }

            tundraPool_notActiveObjQueue__size = 0;
        }

        tundraPool_notActiveObjQueue__head = 0;
        tundraPool_notActiveObjQueue__tail = 0;
        tundraPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void tundraPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < tundraPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = tundraPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = tundraPool_notActiveObjQueue__array.Length - tundraPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(tundraPool_notActiveObjQueue__array, tundraPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(tundraPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void tundraPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (tundraPool_notActiveObjQueue__array == null)
        {
            tundraPool_notActiveObjQueue_SetCapacity(tundraPool_notActiveObjQueue_MinimumGrow);
        }
        else if (tundraPool_notActiveObjQueue__size == tundraPool_notActiveObjQueue__array.Length)
        {
            tundraPool_notActiveObjQueue_SetCapacity(tundraPool_notActiveObjQueue__array.Length + tundraPool_notActiveObjQueue_MinimumGrow);
        }

        tundraPool_notActiveObjQueue__array[tundraPool_notActiveObjQueue__tail] = obj;
        tundraPool_notActiveObjQueue__tail = (tundraPool_notActiveObjQueue__tail + 1) % tundraPool_notActiveObjQueue__array.Length;
        tundraPool_notActiveObjQueue__size++;
        tundraPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int tundraPool_notActiveObjQueue_Dequeue()
    {
        if (tundraPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = tundraPool_notActiveObjQueue__array[tundraPool_notActiveObjQueue__head];
        tundraPool_notActiveObjQueue__array[tundraPool_notActiveObjQueue__head] = int.MaxValue;
        tundraPool_notActiveObjQueue__head = (tundraPool_notActiveObjQueue__head + 1) % tundraPool_notActiveObjQueue__array.Length;
        tundraPool_notActiveObjQueue__size--;
        tundraPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int tundraPool_notActiveObjQueue_Peek()
    {
        if (tundraPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return tundraPool_notActiveObjQueue__array[tundraPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] tundraPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[tundraPool_notActiveObjQueue__size];
        if (tundraPool_notActiveObjQueue__size == 0)
        {
        }
        else if (tundraPool_notActiveObjQueue__head < tundraPool_notActiveObjQueue__tail)
        {
            Array.Copy(tundraPool_notActiveObjQueue__array, tundraPool_notActiveObjQueue__head, arr, 0, tundraPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = tundraPool_notActiveObjQueue__array.Length - tundraPool_notActiveObjQueue__head;
            Array.Copy(tundraPool_notActiveObjQueue__array, tundraPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(tundraPool_notActiveObjQueue__array, 0, arr, toHead, tundraPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void tundraPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (tundraPool_notActiveObjQueue__size == 0)
        {
        }
        else if (tundraPool_notActiveObjQueue__head < tundraPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(tundraPool_notActiveObjQueue__array, tundraPool_notActiveObjQueue__head, newArray, 0, tundraPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = tundraPool_notActiveObjQueue__array.Length - tundraPool_notActiveObjQueue__head;
            Array.Copy(tundraPool_notActiveObjQueue__array, tundraPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(tundraPool_notActiveObjQueue__array, 0, newArray, toHead, tundraPool_notActiveObjQueue__tail);
        }

        tundraPool_notActiveObjQueue__array = newArray;
        tundraPool_notActiveObjQueue__head = 0;
        tundraPool_notActiveObjQueue__tail = tundraPool_notActiveObjQueue__size == capacity ? 0 : tundraPool_notActiveObjQueue__size;
        tundraPool_notActiveObjQueue__version++;
    }

    [SerializeField]
    Transform tundraPool_parent;
    void tundraPool_Start()
    {
        tundraPool_poolSize = tundraPool_InitGenerateCount;
        tundraPool_idToObjDict_SetCapacity(tundraPool_Capacity);
        tundraPool_notActiveObjQueue_SetCapacity(tundraPool_Capacity);
        for (int i = 0; i < tundraPool_InitGenerateCount; i++)
        {
            int id;
            GameObject instance;
            do
            {
                instance = GameObject.Instantiate(tundraPool_prefab);
                if (instance == null)
                {
                    Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
                }

                id = instance.GetInstanceID().GetHashCode();
            }
            while (!tundraPool_idToObjDict_Add(id, instance));
            tundraPool_itemOperator_SetActive(instance, false);
            tundraPool_notActiveObjQueue_Enqueue(id);
        }
    }

    public bool tundraPool_PeekIsInstantiated()
    {
        return tundraPool_isInstantiated;
    }

    bool tundraPool_isInstantiated = false;
    public void tundraPool_Batch(PoolOperatorType[] opes, GameObject[] objs)
    {
        int i = 0;
        foreach (var ope in opes)
        {
            switch (ope)
            {
                case PoolOperatorType.TryToSpawn:
                    tundraPool_TryToSpawn();
                    break;
                case PoolOperatorType.Return:
                    tundraPool_Return(objs[i]);
                    i++;
                    break;
                case PoolOperatorType.Store:
                    tundraPool_Store();
                    break;
                case PoolOperatorType.Clear:
                    tundraPool_Clear();
                    break;
            }
        }
    }

    public void tundraPool_Store(Transform p = null)
    {
        if (tundraPool_idToObjDict_Count > tundraPool_idToObjDict_KeyLength)
            return;
        tundraPool_isInstantiated = true;
        GameObject instance;
        int id;
        do
        {
            instance = GameObject.Instantiate(tundraPool_prefab);
            if (instance == null)
            {
                Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
            }

            id = instance.GetInstanceID().GetHashCode();
            tundraPool_itemOperator_SetActive(instance, false);
        }
        while (!tundraPool_idToObjDict_Add(id, instance));
        tundraPool_notActiveObjQueue_Enqueue(id);
    }

    // falseで出してmeshcombinerで切り替える
    public GameObject tundraPool_TryToSpawn(Transform p = null)
    {
        int id;
        tundraPool_isInstantiated = true;
        if (tundraPool_notActiveObjQueue_Count > 0)
        {
            tundraPool_isInstantiated = false;
            id = tundraPool_notActiveObjQueue_Dequeue();
            if (tundraPool_idToObjDict_HasItem(id))
            {
                var obj = tundraPool_idToObjDict_GetValue(id);
                tundraPool_itemOperator_SetActive(obj, true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        GameObject instance;
        do
        {
            instance = GameObject.Instantiate(tundraPool_prefab);
            if (instance == null)
            {
                Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
            }

            id = instance.GetInstanceID().GetHashCode();
        }
        while (!tundraPool_idToObjDict_Add(id, instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return instance;
    }

    public void tundraPool_Return(GameObject obj, bool force = false)
    {
        if (obj == null)
            return;
        int id = obj.GetInstanceID().GetHashCode();
        if (!tundraPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        tundraPool_itemOperator_SetActive(obj, false);
        tundraPool_notActiveObjQueue_Enqueue(id);
    }

    public bool tundraPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(tundraPool_prefab.name);
    }

    public string tundraPool_prefabName => tundraPool_prefab.name;

    public void tundraPool_Clear()
    {
        tundraPool_notActiveObjQueue_Clear();
        foreach (var obj in tundraPool_idToObjDict_GenerateKeysArray())
        {
            tundraPool_itemOperator_SetActive(tundraPool_idToObjDict_GetValue(obj), false);
            tundraPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject desertPool_prefab;
    int[][] desertPool_idToObjDict__keys;
    GameObject[][] desertPool_idToObjDict__values;
    int desertPool_idToObjDict__size;
    public int desertPool_idToObjDict_Count => desertPool_idToObjDict__size;

    public int[] desertPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[desertPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < desertPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = desertPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    [SerializeField]
    int desertPool_idToObjDict_bucketCount = 4;
    public int desertPool_idToObjDict_KeyLength => desertPool_idToObjDict__keys.Length;

    public void desertPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / desertPool_idToObjDict_bucketCount;
        desertPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            desertPool_idToObjDict__keys[i] = new int[desertPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < desertPool_idToObjDict_bucketCount; i++)
        {
            desertPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        desertPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            desertPool_idToObjDict__values[i] = new GameObject[desertPool_idToObjDict_bucketCount];
        }
    }

    public bool desertPool_idToObjDict_HasItem(int key)
    {
        var index = desertPool_idToObjDict_Hash(key);
        var hashKeys = desertPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int desertPool_idToObjDict_Hash(int key)
    {
        var len = desertPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool desertPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = desertPool_idToObjDict_Hash(key);
        var hashKeys = desertPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    desertPool_idToObjDict__keys[index][i] = key;
                    desertPool_idToObjDict__values[index][i] = value;
                    desertPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    desertPool_idToObjDict__keys[index][i] = key;
                    desertPool_idToObjDict__values[index][i] = value;
                    desertPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full " + index);
        var preLen = hashKeys.Length;
        desertPool_idToObjDict_ExpandList(index);
        desertPool_idToObjDict__keys[index][preLen] = key;
        desertPool_idToObjDict__values[index][preLen] = value;
        desertPool_idToObjDict__size++;
        return true;
    }

    const int desertPool_idToObjDict_expand = 10;
    void desertPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = desertPool_idToObjDict__keys[index];
        var hashValues = desertPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + desertPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        desertPool_idToObjDict__keys[index] = newKeys;
        desertPool_idToObjDict__values[index] = newValues;
    }

    public bool desertPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = desertPool_idToObjDict_Hash(key);
        var hashKeys = desertPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    desertPool_idToObjDict__keys[index][i] = key;
                    desertPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    desertPool_idToObjDict__keys[index][i] = key;
                    desertPool_idToObjDict__values[index][i] = value;
                    desertPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    desertPool_idToObjDict__keys[index][i] = key;
                    desertPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    desertPool_idToObjDict__keys[index][i] = key;
                    desertPool_idToObjDict__values[index][i] = value;
                    desertPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        desertPool_idToObjDict_ExpandList(index);
        desertPool_idToObjDict__keys[index][preLen] = key;
        desertPool_idToObjDict__values[index][preLen] = value;
        desertPool_idToObjDict__size++;
        return true;
    }

    public void desertPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = desertPool_idToObjDict_Hash(key);
        var hashKeys = desertPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    desertPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    desertPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject desertPool_idToObjDict_GetValue(int key)
    {
        int index = desertPool_idToObjDict_Hash(key);
        var hashKeys = desertPool_idToObjDict__keys[index];
        var hashValues = desertPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void desertPool_idToObjDict_Remove(int key)
    {
        int index = desertPool_idToObjDict_Hash(key);
        var hashKeys = desertPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    desertPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    desertPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int desertPool_InitGenerateCount = 0;
    [SerializeField]
    int desertPool_Capacity = 100000;
    public bool desertPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        col.enabled = active;
        mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool desertPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return col.enabled && mesh.enabled;
    }

    int desertPool_poolSize;
    private int[] desertPool_notActiveObjQueue__array;
    private int desertPool_notActiveObjQueue__head; // First valid element in the queue.
    private int desertPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int desertPool_notActiveObjQueue__size; // Number of elements.
    private int desertPool_notActiveObjQueue__version;
    private const int desertPool_notActiveObjQueue_MinimumGrow = 100000;
    public int desertPool_notActiveObjQueue_Count => desertPool_notActiveObjQueue__size;
    public int desertPool_notActiveObjQueue_Version => desertPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int desertPool_notActiveObjQueue_GetCount() => desertPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int desertPool_notActiveObjQueue_GetVersion() => desertPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void desertPool_notActiveObjQueue_Clear()
    {
        if (desertPool_notActiveObjQueue__size != 0)
        {
            if (desertPool_notActiveObjQueue__head < desertPool_notActiveObjQueue__tail)
            {
                Array.Clear(desertPool_notActiveObjQueue__array, desertPool_notActiveObjQueue__head, desertPool_notActiveObjQueue__size);
            }
            else
            {
                Array.Clear(desertPool_notActiveObjQueue__array, desertPool_notActiveObjQueue__head, desertPool_notActiveObjQueue__array.Length - desertPool_notActiveObjQueue__head);
                Array.Clear(desertPool_notActiveObjQueue__array, 0, desertPool_notActiveObjQueue__tail);
            }

            desertPool_notActiveObjQueue__size = 0;
        }

        desertPool_notActiveObjQueue__head = 0;
        desertPool_notActiveObjQueue__tail = 0;
        desertPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void desertPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < desertPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = desertPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = desertPool_notActiveObjQueue__array.Length - desertPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(desertPool_notActiveObjQueue__array, desertPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(desertPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void desertPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (desertPool_notActiveObjQueue__array == null)
        {
            desertPool_notActiveObjQueue_SetCapacity(desertPool_notActiveObjQueue_MinimumGrow);
        }
        else if (desertPool_notActiveObjQueue__size == desertPool_notActiveObjQueue__array.Length)
        {
            desertPool_notActiveObjQueue_SetCapacity(desertPool_notActiveObjQueue__array.Length + desertPool_notActiveObjQueue_MinimumGrow);
        }

        desertPool_notActiveObjQueue__array[desertPool_notActiveObjQueue__tail] = obj;
        desertPool_notActiveObjQueue__tail = (desertPool_notActiveObjQueue__tail + 1) % desertPool_notActiveObjQueue__array.Length;
        desertPool_notActiveObjQueue__size++;
        desertPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int desertPool_notActiveObjQueue_Dequeue()
    {
        if (desertPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = desertPool_notActiveObjQueue__array[desertPool_notActiveObjQueue__head];
        desertPool_notActiveObjQueue__array[desertPool_notActiveObjQueue__head] = int.MaxValue;
        desertPool_notActiveObjQueue__head = (desertPool_notActiveObjQueue__head + 1) % desertPool_notActiveObjQueue__array.Length;
        desertPool_notActiveObjQueue__size--;
        desertPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int desertPool_notActiveObjQueue_Peek()
    {
        if (desertPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return desertPool_notActiveObjQueue__array[desertPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] desertPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[desertPool_notActiveObjQueue__size];
        if (desertPool_notActiveObjQueue__size == 0)
        {
        }
        else if (desertPool_notActiveObjQueue__head < desertPool_notActiveObjQueue__tail)
        {
            Array.Copy(desertPool_notActiveObjQueue__array, desertPool_notActiveObjQueue__head, arr, 0, desertPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = desertPool_notActiveObjQueue__array.Length - desertPool_notActiveObjQueue__head;
            Array.Copy(desertPool_notActiveObjQueue__array, desertPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(desertPool_notActiveObjQueue__array, 0, arr, toHead, desertPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void desertPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (desertPool_notActiveObjQueue__size == 0)
        {
        }
        else if (desertPool_notActiveObjQueue__head < desertPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(desertPool_notActiveObjQueue__array, desertPool_notActiveObjQueue__head, newArray, 0, desertPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = desertPool_notActiveObjQueue__array.Length - desertPool_notActiveObjQueue__head;
            Array.Copy(desertPool_notActiveObjQueue__array, desertPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(desertPool_notActiveObjQueue__array, 0, newArray, toHead, desertPool_notActiveObjQueue__tail);
        }

        desertPool_notActiveObjQueue__array = newArray;
        desertPool_notActiveObjQueue__head = 0;
        desertPool_notActiveObjQueue__tail = desertPool_notActiveObjQueue__size == capacity ? 0 : desertPool_notActiveObjQueue__size;
        desertPool_notActiveObjQueue__version++;
    }

    [SerializeField]
    Transform desertPool_parent;
    void desertPool_Start()
    {
        desertPool_poolSize = desertPool_InitGenerateCount;
        desertPool_idToObjDict_SetCapacity(desertPool_Capacity);
        desertPool_notActiveObjQueue_SetCapacity(desertPool_Capacity);
        for (int i = 0; i < desertPool_InitGenerateCount; i++)
        {
            int id;
            GameObject instance;
            do
            {
                instance = GameObject.Instantiate(desertPool_prefab);
                if (instance == null)
                {
                    Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
                }

                id = instance.GetInstanceID().GetHashCode();
            }
            while (!desertPool_idToObjDict_Add(id, instance));
            desertPool_itemOperator_SetActive(instance, false);
            desertPool_notActiveObjQueue_Enqueue(id);
        }
    }

    public bool desertPool_PeekIsInstantiated()
    {
        return desertPool_isInstantiated;
    }

    bool desertPool_isInstantiated = false;
    public void desertPool_Batch(PoolOperatorType[] opes, GameObject[] objs)
    {
        int i = 0;
        foreach (var ope in opes)
        {
            switch (ope)
            {
                case PoolOperatorType.TryToSpawn:
                    desertPool_TryToSpawn();
                    break;
                case PoolOperatorType.Return:
                    desertPool_Return(objs[i]);
                    i++;
                    break;
                case PoolOperatorType.Store:
                    desertPool_Store();
                    break;
                case PoolOperatorType.Clear:
                    desertPool_Clear();
                    break;
            }
        }
    }

    public void desertPool_Store(Transform p = null)
    {
        if (desertPool_idToObjDict_Count > desertPool_idToObjDict_KeyLength)
            return;
        desertPool_isInstantiated = true;
        GameObject instance;
        int id;
        do
        {
            instance = GameObject.Instantiate(desertPool_prefab);
            if (instance == null)
            {
                Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
            }

            id = instance.GetInstanceID().GetHashCode();
            desertPool_itemOperator_SetActive(instance, false);
        }
        while (!desertPool_idToObjDict_Add(id, instance));
        desertPool_notActiveObjQueue_Enqueue(id);
    }

    // falseで出してmeshcombinerで切り替える
    public GameObject desertPool_TryToSpawn(Transform p = null)
    {
        int id;
        desertPool_isInstantiated = true;
        if (desertPool_notActiveObjQueue_Count > 0)
        {
            desertPool_isInstantiated = false;
            id = desertPool_notActiveObjQueue_Dequeue();
            if (desertPool_idToObjDict_HasItem(id))
            {
                var obj = desertPool_idToObjDict_GetValue(id);
                desertPool_itemOperator_SetActive(obj, true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        GameObject instance;
        do
        {
            instance = GameObject.Instantiate(desertPool_prefab);
            if (instance == null)
            {
                Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
            }

            id = instance.GetInstanceID().GetHashCode();
        }
        while (!desertPool_idToObjDict_Add(id, instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return instance;
    }

    public void desertPool_Return(GameObject obj, bool force = false)
    {
        if (obj == null)
            return;
        int id = obj.GetInstanceID().GetHashCode();
        if (!desertPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        desertPool_itemOperator_SetActive(obj, false);
        desertPool_notActiveObjQueue_Enqueue(id);
    }

    public bool desertPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(desertPool_prefab.name);
    }

    public string desertPool_prefabName => desertPool_prefab.name;

    public void desertPool_Clear()
    {
        desertPool_notActiveObjQueue_Clear();
        foreach (var obj in desertPool_idToObjDict_GenerateKeysArray())
        {
            desertPool_itemOperator_SetActive(desertPool_idToObjDict_GetValue(obj), false);
            desertPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject dirtPool_prefab;
    int[][] dirtPool_idToObjDict__keys;
    GameObject[][] dirtPool_idToObjDict__values;
    int dirtPool_idToObjDict__size;
    public int dirtPool_idToObjDict_Count => dirtPool_idToObjDict__size;

    public int[] dirtPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[dirtPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < dirtPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = dirtPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    [SerializeField]
    int dirtPool_idToObjDict_bucketCount = 4;
    public int dirtPool_idToObjDict_KeyLength => dirtPool_idToObjDict__keys.Length;

    public void dirtPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / dirtPool_idToObjDict_bucketCount;
        dirtPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            dirtPool_idToObjDict__keys[i] = new int[dirtPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < dirtPool_idToObjDict_bucketCount; i++)
        {
            dirtPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        dirtPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            dirtPool_idToObjDict__values[i] = new GameObject[dirtPool_idToObjDict_bucketCount];
        }
    }

    public bool dirtPool_idToObjDict_HasItem(int key)
    {
        var index = dirtPool_idToObjDict_Hash(key);
        var hashKeys = dirtPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int dirtPool_idToObjDict_Hash(int key)
    {
        var len = dirtPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool dirtPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = dirtPool_idToObjDict_Hash(key);
        var hashKeys = dirtPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    dirtPool_idToObjDict__keys[index][i] = key;
                    dirtPool_idToObjDict__values[index][i] = value;
                    dirtPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    dirtPool_idToObjDict__keys[index][i] = key;
                    dirtPool_idToObjDict__values[index][i] = value;
                    dirtPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full " + index);
        var preLen = hashKeys.Length;
        dirtPool_idToObjDict_ExpandList(index);
        dirtPool_idToObjDict__keys[index][preLen] = key;
        dirtPool_idToObjDict__values[index][preLen] = value;
        dirtPool_idToObjDict__size++;
        return true;
    }

    const int dirtPool_idToObjDict_expand = 10;
    void dirtPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = dirtPool_idToObjDict__keys[index];
        var hashValues = dirtPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + dirtPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        dirtPool_idToObjDict__keys[index] = newKeys;
        dirtPool_idToObjDict__values[index] = newValues;
    }

    public bool dirtPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = dirtPool_idToObjDict_Hash(key);
        var hashKeys = dirtPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    dirtPool_idToObjDict__keys[index][i] = key;
                    dirtPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    dirtPool_idToObjDict__keys[index][i] = key;
                    dirtPool_idToObjDict__values[index][i] = value;
                    dirtPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    dirtPool_idToObjDict__keys[index][i] = key;
                    dirtPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    dirtPool_idToObjDict__keys[index][i] = key;
                    dirtPool_idToObjDict__values[index][i] = value;
                    dirtPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        dirtPool_idToObjDict_ExpandList(index);
        dirtPool_idToObjDict__keys[index][preLen] = key;
        dirtPool_idToObjDict__values[index][preLen] = value;
        dirtPool_idToObjDict__size++;
        return true;
    }

    public void dirtPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = dirtPool_idToObjDict_Hash(key);
        var hashKeys = dirtPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    dirtPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    dirtPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject dirtPool_idToObjDict_GetValue(int key)
    {
        int index = dirtPool_idToObjDict_Hash(key);
        var hashKeys = dirtPool_idToObjDict__keys[index];
        var hashValues = dirtPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void dirtPool_idToObjDict_Remove(int key)
    {
        int index = dirtPool_idToObjDict_Hash(key);
        var hashKeys = dirtPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    dirtPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    dirtPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int dirtPool_InitGenerateCount = 0;
    [SerializeField]
    int dirtPool_Capacity = 100000;
    public bool dirtPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        col.enabled = active;
        mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool dirtPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return col.enabled && mesh.enabled;
    }

    int dirtPool_poolSize;
    private int[] dirtPool_notActiveObjQueue__array;
    private int dirtPool_notActiveObjQueue__head; // First valid element in the queue.
    private int dirtPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int dirtPool_notActiveObjQueue__size; // Number of elements.
    private int dirtPool_notActiveObjQueue__version;
    private const int dirtPool_notActiveObjQueue_MinimumGrow = 100000;
    public int dirtPool_notActiveObjQueue_Count => dirtPool_notActiveObjQueue__size;
    public int dirtPool_notActiveObjQueue_Version => dirtPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int dirtPool_notActiveObjQueue_GetCount() => dirtPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int dirtPool_notActiveObjQueue_GetVersion() => dirtPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void dirtPool_notActiveObjQueue_Clear()
    {
        if (dirtPool_notActiveObjQueue__size != 0)
        {
            if (dirtPool_notActiveObjQueue__head < dirtPool_notActiveObjQueue__tail)
            {
                Array.Clear(dirtPool_notActiveObjQueue__array, dirtPool_notActiveObjQueue__head, dirtPool_notActiveObjQueue__size);
            }
            else
            {
                Array.Clear(dirtPool_notActiveObjQueue__array, dirtPool_notActiveObjQueue__head, dirtPool_notActiveObjQueue__array.Length - dirtPool_notActiveObjQueue__head);
                Array.Clear(dirtPool_notActiveObjQueue__array, 0, dirtPool_notActiveObjQueue__tail);
            }

            dirtPool_notActiveObjQueue__size = 0;
        }

        dirtPool_notActiveObjQueue__head = 0;
        dirtPool_notActiveObjQueue__tail = 0;
        dirtPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void dirtPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < dirtPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = dirtPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = dirtPool_notActiveObjQueue__array.Length - dirtPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(dirtPool_notActiveObjQueue__array, dirtPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(dirtPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void dirtPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (dirtPool_notActiveObjQueue__array == null)
        {
            dirtPool_notActiveObjQueue_SetCapacity(dirtPool_notActiveObjQueue_MinimumGrow);
        }
        else if (dirtPool_notActiveObjQueue__size == dirtPool_notActiveObjQueue__array.Length)
        {
            dirtPool_notActiveObjQueue_SetCapacity(dirtPool_notActiveObjQueue__array.Length + dirtPool_notActiveObjQueue_MinimumGrow);
        }

        dirtPool_notActiveObjQueue__array[dirtPool_notActiveObjQueue__tail] = obj;
        dirtPool_notActiveObjQueue__tail = (dirtPool_notActiveObjQueue__tail + 1) % dirtPool_notActiveObjQueue__array.Length;
        dirtPool_notActiveObjQueue__size++;
        dirtPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int dirtPool_notActiveObjQueue_Dequeue()
    {
        if (dirtPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = dirtPool_notActiveObjQueue__array[dirtPool_notActiveObjQueue__head];
        dirtPool_notActiveObjQueue__array[dirtPool_notActiveObjQueue__head] = int.MaxValue;
        dirtPool_notActiveObjQueue__head = (dirtPool_notActiveObjQueue__head + 1) % dirtPool_notActiveObjQueue__array.Length;
        dirtPool_notActiveObjQueue__size--;
        dirtPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int dirtPool_notActiveObjQueue_Peek()
    {
        if (dirtPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return dirtPool_notActiveObjQueue__array[dirtPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] dirtPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[dirtPool_notActiveObjQueue__size];
        if (dirtPool_notActiveObjQueue__size == 0)
        {
        }
        else if (dirtPool_notActiveObjQueue__head < dirtPool_notActiveObjQueue__tail)
        {
            Array.Copy(dirtPool_notActiveObjQueue__array, dirtPool_notActiveObjQueue__head, arr, 0, dirtPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = dirtPool_notActiveObjQueue__array.Length - dirtPool_notActiveObjQueue__head;
            Array.Copy(dirtPool_notActiveObjQueue__array, dirtPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(dirtPool_notActiveObjQueue__array, 0, arr, toHead, dirtPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void dirtPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (dirtPool_notActiveObjQueue__size == 0)
        {
        }
        else if (dirtPool_notActiveObjQueue__head < dirtPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(dirtPool_notActiveObjQueue__array, dirtPool_notActiveObjQueue__head, newArray, 0, dirtPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = dirtPool_notActiveObjQueue__array.Length - dirtPool_notActiveObjQueue__head;
            Array.Copy(dirtPool_notActiveObjQueue__array, dirtPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(dirtPool_notActiveObjQueue__array, 0, newArray, toHead, dirtPool_notActiveObjQueue__tail);
        }

        dirtPool_notActiveObjQueue__array = newArray;
        dirtPool_notActiveObjQueue__head = 0;
        dirtPool_notActiveObjQueue__tail = dirtPool_notActiveObjQueue__size == capacity ? 0 : dirtPool_notActiveObjQueue__size;
        dirtPool_notActiveObjQueue__version++;
    }

    [SerializeField]
    Transform dirtPool_parent;
    void dirtPool_Start()
    {
        dirtPool_poolSize = dirtPool_InitGenerateCount;
        dirtPool_idToObjDict_SetCapacity(dirtPool_Capacity);
        dirtPool_notActiveObjQueue_SetCapacity(dirtPool_Capacity);
        for (int i = 0; i < dirtPool_InitGenerateCount; i++)
        {
            int id;
            GameObject instance;
            do
            {
                instance = GameObject.Instantiate(dirtPool_prefab);
                if (instance == null)
                {
                    Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
                }

                id = instance.GetInstanceID().GetHashCode();
            }
            while (!dirtPool_idToObjDict_Add(id, instance));
            dirtPool_itemOperator_SetActive(instance, false);
            dirtPool_notActiveObjQueue_Enqueue(id);
        }
    }

    public bool dirtPool_PeekIsInstantiated()
    {
        return dirtPool_isInstantiated;
    }

    bool dirtPool_isInstantiated = false;
    public void dirtPool_Batch(PoolOperatorType[] opes, GameObject[] objs)
    {
        int i = 0;
        foreach (var ope in opes)
        {
            switch (ope)
            {
                case PoolOperatorType.TryToSpawn:
                    dirtPool_TryToSpawn();
                    break;
                case PoolOperatorType.Return:
                    dirtPool_Return(objs[i]);
                    i++;
                    break;
                case PoolOperatorType.Store:
                    dirtPool_Store();
                    break;
                case PoolOperatorType.Clear:
                    dirtPool_Clear();
                    break;
            }
        }
    }

    public void dirtPool_Store(Transform p = null)
    {
        if (dirtPool_idToObjDict_Count > dirtPool_idToObjDict_KeyLength)
            return;
        dirtPool_isInstantiated = true;
        GameObject instance;
        int id;
        do
        {
            instance = GameObject.Instantiate(dirtPool_prefab);
            if (instance == null)
            {
                Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
            }

            id = instance.GetInstanceID().GetHashCode();
            dirtPool_itemOperator_SetActive(instance, false);
        }
        while (!dirtPool_idToObjDict_Add(id, instance));
        dirtPool_notActiveObjQueue_Enqueue(id);
    }

    // falseで出してmeshcombinerで切り替える
    public GameObject dirtPool_TryToSpawn(Transform p = null)
    {
        int id;
        dirtPool_isInstantiated = true;
        if (dirtPool_notActiveObjQueue_Count > 0)
        {
            dirtPool_isInstantiated = false;
            id = dirtPool_notActiveObjQueue_Dequeue();
            if (dirtPool_idToObjDict_HasItem(id))
            {
                var obj = dirtPool_idToObjDict_GetValue(id);
                dirtPool_itemOperator_SetActive(obj, true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        GameObject instance;
        do
        {
            instance = GameObject.Instantiate(dirtPool_prefab);
            if (instance == null)
            {
                Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
            }

            id = instance.GetInstanceID().GetHashCode();
        }
        while (!dirtPool_idToObjDict_Add(id, instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return instance;
    }

    public void dirtPool_Return(GameObject obj, bool force = false)
    {
        if (obj == null)
            return;
        int id = obj.GetInstanceID().GetHashCode();
        if (!dirtPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        dirtPool_itemOperator_SetActive(obj, false);
        dirtPool_notActiveObjQueue_Enqueue(id);
    }

    public bool dirtPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(dirtPool_prefab.name);
    }

    public string dirtPool_prefabName => dirtPool_prefab.name;

    public void dirtPool_Clear()
    {
        dirtPool_notActiveObjQueue_Clear();
        foreach (var obj in dirtPool_idToObjDict_GenerateKeysArray())
        {
            dirtPool_itemOperator_SetActive(dirtPool_idToObjDict_GetValue(obj), false);
            dirtPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject rockPool_prefab;
    int[][] rockPool_idToObjDict__keys;
    GameObject[][] rockPool_idToObjDict__values;
    int rockPool_idToObjDict__size;
    public int rockPool_idToObjDict_Count => rockPool_idToObjDict__size;

    public int[] rockPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[rockPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < rockPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = rockPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    [SerializeField]
    int rockPool_idToObjDict_bucketCount = 4;
    public int rockPool_idToObjDict_KeyLength => rockPool_idToObjDict__keys.Length;

    public void rockPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / rockPool_idToObjDict_bucketCount;
        rockPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            rockPool_idToObjDict__keys[i] = new int[rockPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < rockPool_idToObjDict_bucketCount; i++)
        {
            rockPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        rockPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            rockPool_idToObjDict__values[i] = new GameObject[rockPool_idToObjDict_bucketCount];
        }
    }

    public bool rockPool_idToObjDict_HasItem(int key)
    {
        var index = rockPool_idToObjDict_Hash(key);
        var hashKeys = rockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int rockPool_idToObjDict_Hash(int key)
    {
        var len = rockPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool rockPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = rockPool_idToObjDict_Hash(key);
        var hashKeys = rockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    rockPool_idToObjDict__keys[index][i] = key;
                    rockPool_idToObjDict__values[index][i] = value;
                    rockPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    rockPool_idToObjDict__keys[index][i] = key;
                    rockPool_idToObjDict__values[index][i] = value;
                    rockPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full " + index);
        var preLen = hashKeys.Length;
        rockPool_idToObjDict_ExpandList(index);
        rockPool_idToObjDict__keys[index][preLen] = key;
        rockPool_idToObjDict__values[index][preLen] = value;
        rockPool_idToObjDict__size++;
        return true;
    }

    const int rockPool_idToObjDict_expand = 10;
    void rockPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = rockPool_idToObjDict__keys[index];
        var hashValues = rockPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + rockPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        rockPool_idToObjDict__keys[index] = newKeys;
        rockPool_idToObjDict__values[index] = newValues;
    }

    public bool rockPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = rockPool_idToObjDict_Hash(key);
        var hashKeys = rockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    rockPool_idToObjDict__keys[index][i] = key;
                    rockPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    rockPool_idToObjDict__keys[index][i] = key;
                    rockPool_idToObjDict__values[index][i] = value;
                    rockPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    rockPool_idToObjDict__keys[index][i] = key;
                    rockPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    rockPool_idToObjDict__keys[index][i] = key;
                    rockPool_idToObjDict__values[index][i] = value;
                    rockPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        rockPool_idToObjDict_ExpandList(index);
        rockPool_idToObjDict__keys[index][preLen] = key;
        rockPool_idToObjDict__values[index][preLen] = value;
        rockPool_idToObjDict__size++;
        return true;
    }

    public void rockPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = rockPool_idToObjDict_Hash(key);
        var hashKeys = rockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    rockPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    rockPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject rockPool_idToObjDict_GetValue(int key)
    {
        int index = rockPool_idToObjDict_Hash(key);
        var hashKeys = rockPool_idToObjDict__keys[index];
        var hashValues = rockPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void rockPool_idToObjDict_Remove(int key)
    {
        int index = rockPool_idToObjDict_Hash(key);
        var hashKeys = rockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    rockPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    rockPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int rockPool_InitGenerateCount = 0;
    [SerializeField]
    int rockPool_Capacity = 100000;
    public bool rockPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        col.enabled = active;
        mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool rockPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return col.enabled && mesh.enabled;
    }

    int rockPool_poolSize;
    private int[] rockPool_notActiveObjQueue__array;
    private int rockPool_notActiveObjQueue__head; // First valid element in the queue.
    private int rockPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int rockPool_notActiveObjQueue__size; // Number of elements.
    private int rockPool_notActiveObjQueue__version;
    private const int rockPool_notActiveObjQueue_MinimumGrow = 100000;
    public int rockPool_notActiveObjQueue_Count => rockPool_notActiveObjQueue__size;
    public int rockPool_notActiveObjQueue_Version => rockPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int rockPool_notActiveObjQueue_GetCount() => rockPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int rockPool_notActiveObjQueue_GetVersion() => rockPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void rockPool_notActiveObjQueue_Clear()
    {
        if (rockPool_notActiveObjQueue__size != 0)
        {
            if (rockPool_notActiveObjQueue__head < rockPool_notActiveObjQueue__tail)
            {
                Array.Clear(rockPool_notActiveObjQueue__array, rockPool_notActiveObjQueue__head, rockPool_notActiveObjQueue__size);
            }
            else
            {
                Array.Clear(rockPool_notActiveObjQueue__array, rockPool_notActiveObjQueue__head, rockPool_notActiveObjQueue__array.Length - rockPool_notActiveObjQueue__head);
                Array.Clear(rockPool_notActiveObjQueue__array, 0, rockPool_notActiveObjQueue__tail);
            }

            rockPool_notActiveObjQueue__size = 0;
        }

        rockPool_notActiveObjQueue__head = 0;
        rockPool_notActiveObjQueue__tail = 0;
        rockPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void rockPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < rockPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = rockPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = rockPool_notActiveObjQueue__array.Length - rockPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(rockPool_notActiveObjQueue__array, rockPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(rockPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void rockPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (rockPool_notActiveObjQueue__array == null)
        {
            rockPool_notActiveObjQueue_SetCapacity(rockPool_notActiveObjQueue_MinimumGrow);
        }
        else if (rockPool_notActiveObjQueue__size == rockPool_notActiveObjQueue__array.Length)
        {
            rockPool_notActiveObjQueue_SetCapacity(rockPool_notActiveObjQueue__array.Length + rockPool_notActiveObjQueue_MinimumGrow);
        }

        rockPool_notActiveObjQueue__array[rockPool_notActiveObjQueue__tail] = obj;
        rockPool_notActiveObjQueue__tail = (rockPool_notActiveObjQueue__tail + 1) % rockPool_notActiveObjQueue__array.Length;
        rockPool_notActiveObjQueue__size++;
        rockPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int rockPool_notActiveObjQueue_Dequeue()
    {
        if (rockPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = rockPool_notActiveObjQueue__array[rockPool_notActiveObjQueue__head];
        rockPool_notActiveObjQueue__array[rockPool_notActiveObjQueue__head] = int.MaxValue;
        rockPool_notActiveObjQueue__head = (rockPool_notActiveObjQueue__head + 1) % rockPool_notActiveObjQueue__array.Length;
        rockPool_notActiveObjQueue__size--;
        rockPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int rockPool_notActiveObjQueue_Peek()
    {
        if (rockPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return rockPool_notActiveObjQueue__array[rockPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] rockPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[rockPool_notActiveObjQueue__size];
        if (rockPool_notActiveObjQueue__size == 0)
        {
        }
        else if (rockPool_notActiveObjQueue__head < rockPool_notActiveObjQueue__tail)
        {
            Array.Copy(rockPool_notActiveObjQueue__array, rockPool_notActiveObjQueue__head, arr, 0, rockPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = rockPool_notActiveObjQueue__array.Length - rockPool_notActiveObjQueue__head;
            Array.Copy(rockPool_notActiveObjQueue__array, rockPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(rockPool_notActiveObjQueue__array, 0, arr, toHead, rockPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void rockPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (rockPool_notActiveObjQueue__size == 0)
        {
        }
        else if (rockPool_notActiveObjQueue__head < rockPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(rockPool_notActiveObjQueue__array, rockPool_notActiveObjQueue__head, newArray, 0, rockPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = rockPool_notActiveObjQueue__array.Length - rockPool_notActiveObjQueue__head;
            Array.Copy(rockPool_notActiveObjQueue__array, rockPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(rockPool_notActiveObjQueue__array, 0, newArray, toHead, rockPool_notActiveObjQueue__tail);
        }

        rockPool_notActiveObjQueue__array = newArray;
        rockPool_notActiveObjQueue__head = 0;
        rockPool_notActiveObjQueue__tail = rockPool_notActiveObjQueue__size == capacity ? 0 : rockPool_notActiveObjQueue__size;
        rockPool_notActiveObjQueue__version++;
    }

    [SerializeField]
    Transform rockPool_parent;
    void rockPool_Start()
    {
        rockPool_poolSize = rockPool_InitGenerateCount;
        rockPool_idToObjDict_SetCapacity(rockPool_Capacity);
        rockPool_notActiveObjQueue_SetCapacity(rockPool_Capacity);
        for (int i = 0; i < rockPool_InitGenerateCount; i++)
        {
            int id;
            GameObject instance;
            do
            {
                instance = GameObject.Instantiate(rockPool_prefab);
                if (instance == null)
                {
                    Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
                }

                id = instance.GetInstanceID().GetHashCode();
            }
            while (!rockPool_idToObjDict_Add(id, instance));
            rockPool_itemOperator_SetActive(instance, false);
            rockPool_notActiveObjQueue_Enqueue(id);
        }
    }

    public bool rockPool_PeekIsInstantiated()
    {
        return rockPool_isInstantiated;
    }

    bool rockPool_isInstantiated = false;
    public void rockPool_Batch(PoolOperatorType[] opes, GameObject[] objs)
    {
        int i = 0;
        foreach (var ope in opes)
        {
            switch (ope)
            {
                case PoolOperatorType.TryToSpawn:
                    rockPool_TryToSpawn();
                    break;
                case PoolOperatorType.Return:
                    rockPool_Return(objs[i]);
                    i++;
                    break;
                case PoolOperatorType.Store:
                    rockPool_Store();
                    break;
                case PoolOperatorType.Clear:
                    rockPool_Clear();
                    break;
            }
        }
    }

    public void rockPool_Store(Transform p = null)
    {
        if (rockPool_idToObjDict_Count > rockPool_idToObjDict_KeyLength)
            return;
        rockPool_isInstantiated = true;
        GameObject instance;
        int id;
        do
        {
            instance = GameObject.Instantiate(rockPool_prefab);
            if (instance == null)
            {
                Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
            }

            id = instance.GetInstanceID().GetHashCode();
            rockPool_itemOperator_SetActive(instance, false);
        }
        while (!rockPool_idToObjDict_Add(id, instance));
        rockPool_notActiveObjQueue_Enqueue(id);
    }

    // falseで出してmeshcombinerで切り替える
    public GameObject rockPool_TryToSpawn(Transform p = null)
    {
        int id;
        rockPool_isInstantiated = true;
        if (rockPool_notActiveObjQueue_Count > 0)
        {
            rockPool_isInstantiated = false;
            id = rockPool_notActiveObjQueue_Dequeue();
            if (rockPool_idToObjDict_HasItem(id))
            {
                var obj = rockPool_idToObjDict_GetValue(id);
                rockPool_itemOperator_SetActive(obj, true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        GameObject instance;
        do
        {
            instance = GameObject.Instantiate(rockPool_prefab);
            if (instance == null)
            {
                Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
            }

            id = instance.GetInstanceID().GetHashCode();
        }
        while (!rockPool_idToObjDict_Add(id, instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return instance;
    }

    public void rockPool_Return(GameObject obj, bool force = false)
    {
        if (obj == null)
            return;
        int id = obj.GetInstanceID().GetHashCode();
        if (!rockPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        rockPool_itemOperator_SetActive(obj, false);
        rockPool_notActiveObjQueue_Enqueue(id);
    }

    public bool rockPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(rockPool_prefab.name);
    }

    public string rockPool_prefabName => rockPool_prefab.name;

    public void rockPool_Clear()
    {
        rockPool_notActiveObjQueue_Clear();
        foreach (var obj in rockPool_idToObjDict_GenerateKeysArray())
        {
            rockPool_itemOperator_SetActive(rockPool_idToObjDict_GetValue(obj), false);
            rockPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject sandPool_prefab;
    int[][] sandPool_idToObjDict__keys;
    GameObject[][] sandPool_idToObjDict__values;
    int sandPool_idToObjDict__size;
    public int sandPool_idToObjDict_Count => sandPool_idToObjDict__size;

    public int[] sandPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[sandPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < sandPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = sandPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    [SerializeField]
    int sandPool_idToObjDict_bucketCount = 4;
    public int sandPool_idToObjDict_KeyLength => sandPool_idToObjDict__keys.Length;

    public void sandPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / sandPool_idToObjDict_bucketCount;
        sandPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            sandPool_idToObjDict__keys[i] = new int[sandPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < sandPool_idToObjDict_bucketCount; i++)
        {
            sandPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        sandPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            sandPool_idToObjDict__values[i] = new GameObject[sandPool_idToObjDict_bucketCount];
        }
    }

    public bool sandPool_idToObjDict_HasItem(int key)
    {
        var index = sandPool_idToObjDict_Hash(key);
        var hashKeys = sandPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int sandPool_idToObjDict_Hash(int key)
    {
        var len = sandPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool sandPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = sandPool_idToObjDict_Hash(key);
        var hashKeys = sandPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    sandPool_idToObjDict__keys[index][i] = key;
                    sandPool_idToObjDict__values[index][i] = value;
                    sandPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    sandPool_idToObjDict__keys[index][i] = key;
                    sandPool_idToObjDict__values[index][i] = value;
                    sandPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full " + index);
        var preLen = hashKeys.Length;
        sandPool_idToObjDict_ExpandList(index);
        sandPool_idToObjDict__keys[index][preLen] = key;
        sandPool_idToObjDict__values[index][preLen] = value;
        sandPool_idToObjDict__size++;
        return true;
    }

    const int sandPool_idToObjDict_expand = 10;
    void sandPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = sandPool_idToObjDict__keys[index];
        var hashValues = sandPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + sandPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        sandPool_idToObjDict__keys[index] = newKeys;
        sandPool_idToObjDict__values[index] = newValues;
    }

    public bool sandPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = sandPool_idToObjDict_Hash(key);
        var hashKeys = sandPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    sandPool_idToObjDict__keys[index][i] = key;
                    sandPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    sandPool_idToObjDict__keys[index][i] = key;
                    sandPool_idToObjDict__values[index][i] = value;
                    sandPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    sandPool_idToObjDict__keys[index][i] = key;
                    sandPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    sandPool_idToObjDict__keys[index][i] = key;
                    sandPool_idToObjDict__values[index][i] = value;
                    sandPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        sandPool_idToObjDict_ExpandList(index);
        sandPool_idToObjDict__keys[index][preLen] = key;
        sandPool_idToObjDict__values[index][preLen] = value;
        sandPool_idToObjDict__size++;
        return true;
    }

    public void sandPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = sandPool_idToObjDict_Hash(key);
        var hashKeys = sandPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    sandPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    sandPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject sandPool_idToObjDict_GetValue(int key)
    {
        int index = sandPool_idToObjDict_Hash(key);
        var hashKeys = sandPool_idToObjDict__keys[index];
        var hashValues = sandPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void sandPool_idToObjDict_Remove(int key)
    {
        int index = sandPool_idToObjDict_Hash(key);
        var hashKeys = sandPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    sandPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    sandPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int sandPool_InitGenerateCount = 0;
    [SerializeField]
    int sandPool_Capacity = 100000;
    public bool sandPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        col.enabled = active;
        mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool sandPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return col.enabled && mesh.enabled;
    }

    int sandPool_poolSize;
    private int[] sandPool_notActiveObjQueue__array;
    private int sandPool_notActiveObjQueue__head; // First valid element in the queue.
    private int sandPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int sandPool_notActiveObjQueue__size; // Number of elements.
    private int sandPool_notActiveObjQueue__version;
    private const int sandPool_notActiveObjQueue_MinimumGrow = 100000;
    public int sandPool_notActiveObjQueue_Count => sandPool_notActiveObjQueue__size;
    public int sandPool_notActiveObjQueue_Version => sandPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int sandPool_notActiveObjQueue_GetCount() => sandPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int sandPool_notActiveObjQueue_GetVersion() => sandPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void sandPool_notActiveObjQueue_Clear()
    {
        if (sandPool_notActiveObjQueue__size != 0)
        {
            if (sandPool_notActiveObjQueue__head < sandPool_notActiveObjQueue__tail)
            {
                Array.Clear(sandPool_notActiveObjQueue__array, sandPool_notActiveObjQueue__head, sandPool_notActiveObjQueue__size);
            }
            else
            {
                Array.Clear(sandPool_notActiveObjQueue__array, sandPool_notActiveObjQueue__head, sandPool_notActiveObjQueue__array.Length - sandPool_notActiveObjQueue__head);
                Array.Clear(sandPool_notActiveObjQueue__array, 0, sandPool_notActiveObjQueue__tail);
            }

            sandPool_notActiveObjQueue__size = 0;
        }

        sandPool_notActiveObjQueue__head = 0;
        sandPool_notActiveObjQueue__tail = 0;
        sandPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void sandPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < sandPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = sandPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = sandPool_notActiveObjQueue__array.Length - sandPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(sandPool_notActiveObjQueue__array, sandPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(sandPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void sandPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (sandPool_notActiveObjQueue__array == null)
        {
            sandPool_notActiveObjQueue_SetCapacity(sandPool_notActiveObjQueue_MinimumGrow);
        }
        else if (sandPool_notActiveObjQueue__size == sandPool_notActiveObjQueue__array.Length)
        {
            sandPool_notActiveObjQueue_SetCapacity(sandPool_notActiveObjQueue__array.Length + sandPool_notActiveObjQueue_MinimumGrow);
        }

        sandPool_notActiveObjQueue__array[sandPool_notActiveObjQueue__tail] = obj;
        sandPool_notActiveObjQueue__tail = (sandPool_notActiveObjQueue__tail + 1) % sandPool_notActiveObjQueue__array.Length;
        sandPool_notActiveObjQueue__size++;
        sandPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int sandPool_notActiveObjQueue_Dequeue()
    {
        if (sandPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = sandPool_notActiveObjQueue__array[sandPool_notActiveObjQueue__head];
        sandPool_notActiveObjQueue__array[sandPool_notActiveObjQueue__head] = int.MaxValue;
        sandPool_notActiveObjQueue__head = (sandPool_notActiveObjQueue__head + 1) % sandPool_notActiveObjQueue__array.Length;
        sandPool_notActiveObjQueue__size--;
        sandPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int sandPool_notActiveObjQueue_Peek()
    {
        if (sandPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return sandPool_notActiveObjQueue__array[sandPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] sandPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[sandPool_notActiveObjQueue__size];
        if (sandPool_notActiveObjQueue__size == 0)
        {
        }
        else if (sandPool_notActiveObjQueue__head < sandPool_notActiveObjQueue__tail)
        {
            Array.Copy(sandPool_notActiveObjQueue__array, sandPool_notActiveObjQueue__head, arr, 0, sandPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = sandPool_notActiveObjQueue__array.Length - sandPool_notActiveObjQueue__head;
            Array.Copy(sandPool_notActiveObjQueue__array, sandPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(sandPool_notActiveObjQueue__array, 0, arr, toHead, sandPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void sandPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (sandPool_notActiveObjQueue__size == 0)
        {
        }
        else if (sandPool_notActiveObjQueue__head < sandPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(sandPool_notActiveObjQueue__array, sandPool_notActiveObjQueue__head, newArray, 0, sandPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = sandPool_notActiveObjQueue__array.Length - sandPool_notActiveObjQueue__head;
            Array.Copy(sandPool_notActiveObjQueue__array, sandPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(sandPool_notActiveObjQueue__array, 0, newArray, toHead, sandPool_notActiveObjQueue__tail);
        }

        sandPool_notActiveObjQueue__array = newArray;
        sandPool_notActiveObjQueue__head = 0;
        sandPool_notActiveObjQueue__tail = sandPool_notActiveObjQueue__size == capacity ? 0 : sandPool_notActiveObjQueue__size;
        sandPool_notActiveObjQueue__version++;
    }

    [SerializeField]
    Transform sandPool_parent;
    void sandPool_Start()
    {
        sandPool_poolSize = sandPool_InitGenerateCount;
        sandPool_idToObjDict_SetCapacity(sandPool_Capacity);
        sandPool_notActiveObjQueue_SetCapacity(sandPool_Capacity);
        for (int i = 0; i < sandPool_InitGenerateCount; i++)
        {
            int id;
            GameObject instance;
            do
            {
                instance = GameObject.Instantiate(sandPool_prefab);
                if (instance == null)
                {
                    Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
                }

                id = instance.GetInstanceID().GetHashCode();
            }
            while (!sandPool_idToObjDict_Add(id, instance));
            sandPool_itemOperator_SetActive(instance, false);
            sandPool_notActiveObjQueue_Enqueue(id);
        }
    }

    public bool sandPool_PeekIsInstantiated()
    {
        return sandPool_isInstantiated;
    }

    bool sandPool_isInstantiated = false;
    public void sandPool_Batch(PoolOperatorType[] opes, GameObject[] objs)
    {
        int i = 0;
        foreach (var ope in opes)
        {
            switch (ope)
            {
                case PoolOperatorType.TryToSpawn:
                    sandPool_TryToSpawn();
                    break;
                case PoolOperatorType.Return:
                    sandPool_Return(objs[i]);
                    i++;
                    break;
                case PoolOperatorType.Store:
                    sandPool_Store();
                    break;
                case PoolOperatorType.Clear:
                    sandPool_Clear();
                    break;
            }
        }
    }

    public void sandPool_Store(Transform p = null)
    {
        if (sandPool_idToObjDict_Count > sandPool_idToObjDict_KeyLength)
            return;
        sandPool_isInstantiated = true;
        GameObject instance;
        int id;
        do
        {
            instance = GameObject.Instantiate(sandPool_prefab);
            if (instance == null)
            {
                Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
            }

            id = instance.GetInstanceID().GetHashCode();
            sandPool_itemOperator_SetActive(instance, false);
        }
        while (!sandPool_idToObjDict_Add(id, instance));
        sandPool_notActiveObjQueue_Enqueue(id);
    }

    // falseで出してmeshcombinerで切り替える
    public GameObject sandPool_TryToSpawn(Transform p = null)
    {
        int id;
        sandPool_isInstantiated = true;
        if (sandPool_notActiveObjQueue_Count > 0)
        {
            sandPool_isInstantiated = false;
            id = sandPool_notActiveObjQueue_Dequeue();
            if (sandPool_idToObjDict_HasItem(id))
            {
                var obj = sandPool_idToObjDict_GetValue(id);
                sandPool_itemOperator_SetActive(obj, true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        GameObject instance;
        do
        {
            instance = GameObject.Instantiate(sandPool_prefab);
            if (instance == null)
            {
                Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
            }

            id = instance.GetInstanceID().GetHashCode();
        }
        while (!sandPool_idToObjDict_Add(id, instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return instance;
    }

    public void sandPool_Return(GameObject obj, bool force = false)
    {
        if (obj == null)
            return;
        int id = obj.GetInstanceID().GetHashCode();
        if (!sandPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        sandPool_itemOperator_SetActive(obj, false);
        sandPool_notActiveObjQueue_Enqueue(id);
    }

    public bool sandPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(sandPool_prefab.name);
    }

    public string sandPool_prefabName => sandPool_prefab.name;

    public void sandPool_Clear()
    {
        sandPool_notActiveObjQueue_Clear();
        foreach (var obj in sandPool_idToObjDict_GenerateKeysArray())
        {
            sandPool_itemOperator_SetActive(sandPool_idToObjDict_GetValue(obj), false);
            sandPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject waterPool_prefab;
    int[][] waterPool_idToObjDict__keys;
    GameObject[][] waterPool_idToObjDict__values;
    int waterPool_idToObjDict__size;
    public int waterPool_idToObjDict_Count => waterPool_idToObjDict__size;

    public int[] waterPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[waterPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < waterPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = waterPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    [SerializeField]
    int waterPool_idToObjDict_bucketCount = 4;
    public int waterPool_idToObjDict_KeyLength => waterPool_idToObjDict__keys.Length;

    public void waterPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / waterPool_idToObjDict_bucketCount;
        waterPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            waterPool_idToObjDict__keys[i] = new int[waterPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < waterPool_idToObjDict_bucketCount; i++)
        {
            waterPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        waterPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            waterPool_idToObjDict__values[i] = new GameObject[waterPool_idToObjDict_bucketCount];
        }
    }

    public bool waterPool_idToObjDict_HasItem(int key)
    {
        var index = waterPool_idToObjDict_Hash(key);
        var hashKeys = waterPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int waterPool_idToObjDict_Hash(int key)
    {
        var len = waterPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool waterPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = waterPool_idToObjDict_Hash(key);
        var hashKeys = waterPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    waterPool_idToObjDict__keys[index][i] = key;
                    waterPool_idToObjDict__values[index][i] = value;
                    waterPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    waterPool_idToObjDict__keys[index][i] = key;
                    waterPool_idToObjDict__values[index][i] = value;
                    waterPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full " + index);
        var preLen = hashKeys.Length;
        waterPool_idToObjDict_ExpandList(index);
        waterPool_idToObjDict__keys[index][preLen] = key;
        waterPool_idToObjDict__values[index][preLen] = value;
        waterPool_idToObjDict__size++;
        return true;
    }

    const int waterPool_idToObjDict_expand = 10;
    void waterPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = waterPool_idToObjDict__keys[index];
        var hashValues = waterPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + waterPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        waterPool_idToObjDict__keys[index] = newKeys;
        waterPool_idToObjDict__values[index] = newValues;
    }

    public bool waterPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = waterPool_idToObjDict_Hash(key);
        var hashKeys = waterPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    waterPool_idToObjDict__keys[index][i] = key;
                    waterPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    waterPool_idToObjDict__keys[index][i] = key;
                    waterPool_idToObjDict__values[index][i] = value;
                    waterPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    waterPool_idToObjDict__keys[index][i] = key;
                    waterPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    waterPool_idToObjDict__keys[index][i] = key;
                    waterPool_idToObjDict__values[index][i] = value;
                    waterPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        waterPool_idToObjDict_ExpandList(index);
        waterPool_idToObjDict__keys[index][preLen] = key;
        waterPool_idToObjDict__values[index][preLen] = value;
        waterPool_idToObjDict__size++;
        return true;
    }

    public void waterPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = waterPool_idToObjDict_Hash(key);
        var hashKeys = waterPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    waterPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    waterPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject waterPool_idToObjDict_GetValue(int key)
    {
        int index = waterPool_idToObjDict_Hash(key);
        var hashKeys = waterPool_idToObjDict__keys[index];
        var hashValues = waterPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void waterPool_idToObjDict_Remove(int key)
    {
        int index = waterPool_idToObjDict_Hash(key);
        var hashKeys = waterPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    waterPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    waterPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int waterPool_InitGenerateCount = 0;
    [SerializeField]
    int waterPool_Capacity = 100000;
    public bool waterPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        col.enabled = active;
        mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool waterPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return col.enabled && mesh.enabled;
    }

    int waterPool_poolSize;
    private int[] waterPool_notActiveObjQueue__array;
    private int waterPool_notActiveObjQueue__head; // First valid element in the queue.
    private int waterPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int waterPool_notActiveObjQueue__size; // Number of elements.
    private int waterPool_notActiveObjQueue__version;
    private const int waterPool_notActiveObjQueue_MinimumGrow = 100000;
    public int waterPool_notActiveObjQueue_Count => waterPool_notActiveObjQueue__size;
    public int waterPool_notActiveObjQueue_Version => waterPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int waterPool_notActiveObjQueue_GetCount() => waterPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int waterPool_notActiveObjQueue_GetVersion() => waterPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void waterPool_notActiveObjQueue_Clear()
    {
        if (waterPool_notActiveObjQueue__size != 0)
        {
            if (waterPool_notActiveObjQueue__head < waterPool_notActiveObjQueue__tail)
            {
                Array.Clear(waterPool_notActiveObjQueue__array, waterPool_notActiveObjQueue__head, waterPool_notActiveObjQueue__size);
            }
            else
            {
                Array.Clear(waterPool_notActiveObjQueue__array, waterPool_notActiveObjQueue__head, waterPool_notActiveObjQueue__array.Length - waterPool_notActiveObjQueue__head);
                Array.Clear(waterPool_notActiveObjQueue__array, 0, waterPool_notActiveObjQueue__tail);
            }

            waterPool_notActiveObjQueue__size = 0;
        }

        waterPool_notActiveObjQueue__head = 0;
        waterPool_notActiveObjQueue__tail = 0;
        waterPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void waterPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < waterPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = waterPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = waterPool_notActiveObjQueue__array.Length - waterPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(waterPool_notActiveObjQueue__array, waterPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(waterPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void waterPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (waterPool_notActiveObjQueue__array == null)
        {
            waterPool_notActiveObjQueue_SetCapacity(waterPool_notActiveObjQueue_MinimumGrow);
        }
        else if (waterPool_notActiveObjQueue__size == waterPool_notActiveObjQueue__array.Length)
        {
            waterPool_notActiveObjQueue_SetCapacity(waterPool_notActiveObjQueue__array.Length + waterPool_notActiveObjQueue_MinimumGrow);
        }

        waterPool_notActiveObjQueue__array[waterPool_notActiveObjQueue__tail] = obj;
        waterPool_notActiveObjQueue__tail = (waterPool_notActiveObjQueue__tail + 1) % waterPool_notActiveObjQueue__array.Length;
        waterPool_notActiveObjQueue__size++;
        waterPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int waterPool_notActiveObjQueue_Dequeue()
    {
        if (waterPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = waterPool_notActiveObjQueue__array[waterPool_notActiveObjQueue__head];
        waterPool_notActiveObjQueue__array[waterPool_notActiveObjQueue__head] = int.MaxValue;
        waterPool_notActiveObjQueue__head = (waterPool_notActiveObjQueue__head + 1) % waterPool_notActiveObjQueue__array.Length;
        waterPool_notActiveObjQueue__size--;
        waterPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int waterPool_notActiveObjQueue_Peek()
    {
        if (waterPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return waterPool_notActiveObjQueue__array[waterPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] waterPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[waterPool_notActiveObjQueue__size];
        if (waterPool_notActiveObjQueue__size == 0)
        {
        }
        else if (waterPool_notActiveObjQueue__head < waterPool_notActiveObjQueue__tail)
        {
            Array.Copy(waterPool_notActiveObjQueue__array, waterPool_notActiveObjQueue__head, arr, 0, waterPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = waterPool_notActiveObjQueue__array.Length - waterPool_notActiveObjQueue__head;
            Array.Copy(waterPool_notActiveObjQueue__array, waterPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(waterPool_notActiveObjQueue__array, 0, arr, toHead, waterPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void waterPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (waterPool_notActiveObjQueue__size == 0)
        {
        }
        else if (waterPool_notActiveObjQueue__head < waterPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(waterPool_notActiveObjQueue__array, waterPool_notActiveObjQueue__head, newArray, 0, waterPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = waterPool_notActiveObjQueue__array.Length - waterPool_notActiveObjQueue__head;
            Array.Copy(waterPool_notActiveObjQueue__array, waterPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(waterPool_notActiveObjQueue__array, 0, newArray, toHead, waterPool_notActiveObjQueue__tail);
        }

        waterPool_notActiveObjQueue__array = newArray;
        waterPool_notActiveObjQueue__head = 0;
        waterPool_notActiveObjQueue__tail = waterPool_notActiveObjQueue__size == capacity ? 0 : waterPool_notActiveObjQueue__size;
        waterPool_notActiveObjQueue__version++;
    }

    [SerializeField]
    Transform waterPool_parent;
    void waterPool_Start()
    {
        waterPool_poolSize = waterPool_InitGenerateCount;
        waterPool_idToObjDict_SetCapacity(waterPool_Capacity);
        waterPool_notActiveObjQueue_SetCapacity(waterPool_Capacity);
        for (int i = 0; i < waterPool_InitGenerateCount; i++)
        {
            int id;
            GameObject instance;
            do
            {
                instance = GameObject.Instantiate(waterPool_prefab);
                if (instance == null)
                {
                    Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
                }

                id = instance.GetInstanceID().GetHashCode();
            }
            while (!waterPool_idToObjDict_Add(id, instance));
            waterPool_itemOperator_SetActive(instance, false);
            waterPool_notActiveObjQueue_Enqueue(id);
        }
    }

    public bool waterPool_PeekIsInstantiated()
    {
        return waterPool_isInstantiated;
    }

    bool waterPool_isInstantiated = false;
    public void waterPool_Batch(PoolOperatorType[] opes, GameObject[] objs)
    {
        int i = 0;
        foreach (var ope in opes)
        {
            switch (ope)
            {
                case PoolOperatorType.TryToSpawn:
                    waterPool_TryToSpawn();
                    break;
                case PoolOperatorType.Return:
                    waterPool_Return(objs[i]);
                    i++;
                    break;
                case PoolOperatorType.Store:
                    waterPool_Store();
                    break;
                case PoolOperatorType.Clear:
                    waterPool_Clear();
                    break;
            }
        }
    }

    public void waterPool_Store(Transform p = null)
    {
        if (waterPool_idToObjDict_Count > waterPool_idToObjDict_KeyLength)
            return;
        waterPool_isInstantiated = true;
        GameObject instance;
        int id;
        do
        {
            instance = GameObject.Instantiate(waterPool_prefab);
            if (instance == null)
            {
                Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
            }

            id = instance.GetInstanceID().GetHashCode();
            waterPool_itemOperator_SetActive(instance, false);
        }
        while (!waterPool_idToObjDict_Add(id, instance));
        waterPool_notActiveObjQueue_Enqueue(id);
    }

    // falseで出してmeshcombinerで切り替える
    public GameObject waterPool_TryToSpawn(Transform p = null)
    {
        int id;
        waterPool_isInstantiated = true;
        if (waterPool_notActiveObjQueue_Count > 0)
        {
            waterPool_isInstantiated = false;
            id = waterPool_notActiveObjQueue_Dequeue();
            if (waterPool_idToObjDict_HasItem(id))
            {
                var obj = waterPool_idToObjDict_GetValue(id);
                waterPool_itemOperator_SetActive(obj, true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        GameObject instance;
        do
        {
            instance = GameObject.Instantiate(waterPool_prefab);
            if (instance == null)
            {
                Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
            }

            id = instance.GetInstanceID().GetHashCode();
        }
        while (!waterPool_idToObjDict_Add(id, instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return instance;
    }

    public void waterPool_Return(GameObject obj, bool force = false)
    {
        if (obj == null)
            return;
        int id = obj.GetInstanceID().GetHashCode();
        if (!waterPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        waterPool_itemOperator_SetActive(obj, false);
        waterPool_notActiveObjQueue_Enqueue(id);
    }

    public bool waterPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(waterPool_prefab.name);
    }

    public string waterPool_prefabName => waterPool_prefab.name;

    public void waterPool_Clear()
    {
        waterPool_notActiveObjQueue_Clear();
        foreach (var obj in waterPool_idToObjDict_GenerateKeysArray())
        {
            waterPool_itemOperator_SetActive(waterPool_idToObjDict_GetValue(obj), false);
            waterPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject darkPool_prefab;
    int[][] darkPool_idToObjDict__keys;
    GameObject[][] darkPool_idToObjDict__values;
    int darkPool_idToObjDict__size;
    public int darkPool_idToObjDict_Count => darkPool_idToObjDict__size;

    public int[] darkPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[darkPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < darkPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = darkPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    [SerializeField]
    int darkPool_idToObjDict_bucketCount = 4;
    public int darkPool_idToObjDict_KeyLength => darkPool_idToObjDict__keys.Length;

    public void darkPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / darkPool_idToObjDict_bucketCount;
        darkPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            darkPool_idToObjDict__keys[i] = new int[darkPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < darkPool_idToObjDict_bucketCount; i++)
        {
            darkPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        darkPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            darkPool_idToObjDict__values[i] = new GameObject[darkPool_idToObjDict_bucketCount];
        }
    }

    public bool darkPool_idToObjDict_HasItem(int key)
    {
        var index = darkPool_idToObjDict_Hash(key);
        var hashKeys = darkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int darkPool_idToObjDict_Hash(int key)
    {
        var len = darkPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool darkPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = darkPool_idToObjDict_Hash(key);
        var hashKeys = darkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    darkPool_idToObjDict__keys[index][i] = key;
                    darkPool_idToObjDict__values[index][i] = value;
                    darkPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    darkPool_idToObjDict__keys[index][i] = key;
                    darkPool_idToObjDict__values[index][i] = value;
                    darkPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full " + index);
        var preLen = hashKeys.Length;
        darkPool_idToObjDict_ExpandList(index);
        darkPool_idToObjDict__keys[index][preLen] = key;
        darkPool_idToObjDict__values[index][preLen] = value;
        darkPool_idToObjDict__size++;
        return true;
    }

    const int darkPool_idToObjDict_expand = 10;
    void darkPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = darkPool_idToObjDict__keys[index];
        var hashValues = darkPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + darkPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        darkPool_idToObjDict__keys[index] = newKeys;
        darkPool_idToObjDict__values[index] = newValues;
    }

    public bool darkPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = darkPool_idToObjDict_Hash(key);
        var hashKeys = darkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    darkPool_idToObjDict__keys[index][i] = key;
                    darkPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    darkPool_idToObjDict__keys[index][i] = key;
                    darkPool_idToObjDict__values[index][i] = value;
                    darkPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    darkPool_idToObjDict__keys[index][i] = key;
                    darkPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    darkPool_idToObjDict__keys[index][i] = key;
                    darkPool_idToObjDict__values[index][i] = value;
                    darkPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        darkPool_idToObjDict_ExpandList(index);
        darkPool_idToObjDict__keys[index][preLen] = key;
        darkPool_idToObjDict__values[index][preLen] = value;
        darkPool_idToObjDict__size++;
        return true;
    }

    public void darkPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = darkPool_idToObjDict_Hash(key);
        var hashKeys = darkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    darkPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    darkPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject darkPool_idToObjDict_GetValue(int key)
    {
        int index = darkPool_idToObjDict_Hash(key);
        var hashKeys = darkPool_idToObjDict__keys[index];
        var hashValues = darkPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void darkPool_idToObjDict_Remove(int key)
    {
        int index = darkPool_idToObjDict_Hash(key);
        var hashKeys = darkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    darkPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    darkPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int darkPool_InitGenerateCount = 0;
    [SerializeField]
    int darkPool_Capacity = 100000;
    public bool darkPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        col.enabled = active;
        mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool darkPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return col.enabled && mesh.enabled;
    }

    int darkPool_poolSize;
    private int[] darkPool_notActiveObjQueue__array;
    private int darkPool_notActiveObjQueue__head; // First valid element in the queue.
    private int darkPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int darkPool_notActiveObjQueue__size; // Number of elements.
    private int darkPool_notActiveObjQueue__version;
    private const int darkPool_notActiveObjQueue_MinimumGrow = 100000;
    public int darkPool_notActiveObjQueue_Count => darkPool_notActiveObjQueue__size;
    public int darkPool_notActiveObjQueue_Version => darkPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int darkPool_notActiveObjQueue_GetCount() => darkPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int darkPool_notActiveObjQueue_GetVersion() => darkPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void darkPool_notActiveObjQueue_Clear()
    {
        if (darkPool_notActiveObjQueue__size != 0)
        {
            if (darkPool_notActiveObjQueue__head < darkPool_notActiveObjQueue__tail)
            {
                Array.Clear(darkPool_notActiveObjQueue__array, darkPool_notActiveObjQueue__head, darkPool_notActiveObjQueue__size);
            }
            else
            {
                Array.Clear(darkPool_notActiveObjQueue__array, darkPool_notActiveObjQueue__head, darkPool_notActiveObjQueue__array.Length - darkPool_notActiveObjQueue__head);
                Array.Clear(darkPool_notActiveObjQueue__array, 0, darkPool_notActiveObjQueue__tail);
            }

            darkPool_notActiveObjQueue__size = 0;
        }

        darkPool_notActiveObjQueue__head = 0;
        darkPool_notActiveObjQueue__tail = 0;
        darkPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void darkPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < darkPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = darkPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = darkPool_notActiveObjQueue__array.Length - darkPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(darkPool_notActiveObjQueue__array, darkPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(darkPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void darkPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (darkPool_notActiveObjQueue__array == null)
        {
            darkPool_notActiveObjQueue_SetCapacity(darkPool_notActiveObjQueue_MinimumGrow);
        }
        else if (darkPool_notActiveObjQueue__size == darkPool_notActiveObjQueue__array.Length)
        {
            darkPool_notActiveObjQueue_SetCapacity(darkPool_notActiveObjQueue__array.Length + darkPool_notActiveObjQueue_MinimumGrow);
        }

        darkPool_notActiveObjQueue__array[darkPool_notActiveObjQueue__tail] = obj;
        darkPool_notActiveObjQueue__tail = (darkPool_notActiveObjQueue__tail + 1) % darkPool_notActiveObjQueue__array.Length;
        darkPool_notActiveObjQueue__size++;
        darkPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int darkPool_notActiveObjQueue_Dequeue()
    {
        if (darkPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = darkPool_notActiveObjQueue__array[darkPool_notActiveObjQueue__head];
        darkPool_notActiveObjQueue__array[darkPool_notActiveObjQueue__head] = int.MaxValue;
        darkPool_notActiveObjQueue__head = (darkPool_notActiveObjQueue__head + 1) % darkPool_notActiveObjQueue__array.Length;
        darkPool_notActiveObjQueue__size--;
        darkPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int darkPool_notActiveObjQueue_Peek()
    {
        if (darkPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return darkPool_notActiveObjQueue__array[darkPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] darkPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[darkPool_notActiveObjQueue__size];
        if (darkPool_notActiveObjQueue__size == 0)
        {
        }
        else if (darkPool_notActiveObjQueue__head < darkPool_notActiveObjQueue__tail)
        {
            Array.Copy(darkPool_notActiveObjQueue__array, darkPool_notActiveObjQueue__head, arr, 0, darkPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = darkPool_notActiveObjQueue__array.Length - darkPool_notActiveObjQueue__head;
            Array.Copy(darkPool_notActiveObjQueue__array, darkPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(darkPool_notActiveObjQueue__array, 0, arr, toHead, darkPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void darkPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (darkPool_notActiveObjQueue__size == 0)
        {
        }
        else if (darkPool_notActiveObjQueue__head < darkPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(darkPool_notActiveObjQueue__array, darkPool_notActiveObjQueue__head, newArray, 0, darkPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = darkPool_notActiveObjQueue__array.Length - darkPool_notActiveObjQueue__head;
            Array.Copy(darkPool_notActiveObjQueue__array, darkPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(darkPool_notActiveObjQueue__array, 0, newArray, toHead, darkPool_notActiveObjQueue__tail);
        }

        darkPool_notActiveObjQueue__array = newArray;
        darkPool_notActiveObjQueue__head = 0;
        darkPool_notActiveObjQueue__tail = darkPool_notActiveObjQueue__size == capacity ? 0 : darkPool_notActiveObjQueue__size;
        darkPool_notActiveObjQueue__version++;
    }

    [SerializeField]
    Transform darkPool_parent;
    void darkPool_Start()
    {
        darkPool_poolSize = darkPool_InitGenerateCount;
        darkPool_idToObjDict_SetCapacity(darkPool_Capacity);
        darkPool_notActiveObjQueue_SetCapacity(darkPool_Capacity);
        for (int i = 0; i < darkPool_InitGenerateCount; i++)
        {
            int id;
            GameObject instance;
            do
            {
                instance = GameObject.Instantiate(darkPool_prefab);
                if (instance == null)
                {
                    Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
                }

                id = instance.GetInstanceID().GetHashCode();
            }
            while (!darkPool_idToObjDict_Add(id, instance));
            darkPool_itemOperator_SetActive(instance, false);
            darkPool_notActiveObjQueue_Enqueue(id);
        }
    }

    public bool darkPool_PeekIsInstantiated()
    {
        return darkPool_isInstantiated;
    }

    bool darkPool_isInstantiated = false;
    public void darkPool_Batch(PoolOperatorType[] opes, GameObject[] objs)
    {
        int i = 0;
        foreach (var ope in opes)
        {
            switch (ope)
            {
                case PoolOperatorType.TryToSpawn:
                    darkPool_TryToSpawn();
                    break;
                case PoolOperatorType.Return:
                    darkPool_Return(objs[i]);
                    i++;
                    break;
                case PoolOperatorType.Store:
                    darkPool_Store();
                    break;
                case PoolOperatorType.Clear:
                    darkPool_Clear();
                    break;
            }
        }
    }

    public void darkPool_Store(Transform p = null)
    {
        if (darkPool_idToObjDict_Count > darkPool_idToObjDict_KeyLength)
            return;
        darkPool_isInstantiated = true;
        GameObject instance;
        int id;
        do
        {
            instance = GameObject.Instantiate(darkPool_prefab);
            if (instance == null)
            {
                Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
            }

            id = instance.GetInstanceID().GetHashCode();
            darkPool_itemOperator_SetActive(instance, false);
        }
        while (!darkPool_idToObjDict_Add(id, instance));
        darkPool_notActiveObjQueue_Enqueue(id);
    }

    // falseで出してmeshcombinerで切り替える
    public GameObject darkPool_TryToSpawn(Transform p = null)
    {
        int id;
        darkPool_isInstantiated = true;
        if (darkPool_notActiveObjQueue_Count > 0)
        {
            darkPool_isInstantiated = false;
            id = darkPool_notActiveObjQueue_Dequeue();
            if (darkPool_idToObjDict_HasItem(id))
            {
                var obj = darkPool_idToObjDict_GetValue(id);
                darkPool_itemOperator_SetActive(obj, true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        GameObject instance;
        do
        {
            instance = GameObject.Instantiate(darkPool_prefab);
            if (instance == null)
            {
                Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
            }

            id = instance.GetInstanceID().GetHashCode();
        }
        while (!darkPool_idToObjDict_Add(id, instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return instance;
    }

    public void darkPool_Return(GameObject obj, bool force = false)
    {
        if (obj == null)
            return;
        int id = obj.GetInstanceID().GetHashCode();
        if (!darkPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        darkPool_itemOperator_SetActive(obj, false);
        darkPool_notActiveObjQueue_Enqueue(id);
    }

    public bool darkPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(darkPool_prefab.name);
    }

    public string darkPool_prefabName => darkPool_prefab.name;

    public void darkPool_Clear()
    {
        darkPool_notActiveObjQueue_Clear();
        foreach (var obj in darkPool_idToObjDict_GenerateKeysArray())
        {
            darkPool_itemOperator_SetActive(darkPool_idToObjDict_GetValue(obj), false);
            darkPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    public int settings_chunkSize = 3;
    public int settings_batchCount = 1000;
    public int settings_chunkWidth = 100;
    public int settings_chunkDepth = 100;
    public int settings_fieldHeight = 3;
    public float settings_scale = 0.015f;
    public float settings_scaleT = 0.003f;
    public float settings_scaleH = 0.003f;
    public float settings_cellAnimationTime = 1f;
    public float settings_TileScale = 1.5f;
    public float settings_chunkLoadRange = 6f;
    public float settings_chunkUnLoadRange = 12f;
    public float settings_chunkDetailRange = 1f;
    public float settings_generateAdditionalInterval = 5f;
    public float settings_searchAdditionalInterval = 3f;
    public float settings_removeBatchCount = 100;
    public float settings_removeInterval = 0.1f;
    public float settings_waterPercentage = 0.2f;
    public int settings_operationBatchCount = 1;
    public int settings_searchBatchCount = 30;
    public bool settings_removeOn = true;
    public bool settings_searchOn = true;
    Biome[][] biomeMap = new Biome[][]
    {
        new Biome[]
        {
            Biome.Dirt,
            Biome.Dirt,
            Biome.Dark,
            Biome.Dark,
            Biome.Rock
        },
        new Biome[]
        {
            Biome.Dirt,
            Biome.Dirt,
            Biome.Dark,
            Biome.Grass,
            Biome.Rock
        },
        new Biome[]
        {
            Biome.Tundra,
            Biome.Dark,
            Biome.Grass,
            Biome.Rock,
            Biome.Sand
        },
        new Biome[]
        {
            Biome.Tundra,
            Biome.Grass,
            Biome.Rock,
            Biome.Desert,
            Biome.Sand
        },
        new Biome[]
        {
            Biome.Tundra,
            Biome.Grass,
            Biome.Desert,
            Biome.Desert,
            Biome.Sand
        },
    };
    bool BiomePeekIsInstantiated(Biome biome)
    {
        switch (biome)
        {
            case Biome.Grass:
                return grassPool_PeekIsInstantiated();
            case Biome.Tundra:
                return tundraPool_PeekIsInstantiated();
            case Biome.Desert:
                return desertPool_PeekIsInstantiated();
            case Biome.Rock:
                return rockPool_PeekIsInstantiated();
            case Biome.Sand:
                return sandPool_PeekIsInstantiated();
            case Biome.Water:
                return waterPool_PeekIsInstantiated();
            case Biome.Dirt:
                return dirtPool_PeekIsInstantiated();
            case Biome.Dark:
                return darkPool_PeekIsInstantiated();
            default:
                Debug.LogError("Invalid biome: " + biome);
                return false;
        }
    }

    GameObject BiomeTryToSpawn(Biome biome)
    {
        switch (biome)
        {
            case Biome.Grass:
                return grassPool_TryToSpawn();
            case Biome.Tundra:
                return tundraPool_TryToSpawn();
            case Biome.Desert:
                return desertPool_TryToSpawn();
            case Biome.Rock:
                return rockPool_TryToSpawn();
            case Biome.Sand:
                return sandPool_TryToSpawn();
            case Biome.Water:
                return waterPool_TryToSpawn();
            case Biome.Dirt:
                return dirtPool_TryToSpawn();
            case Biome.Dark:
                return darkPool_TryToSpawn();
            default:
                Debug.LogError("Invalid biome: " + biome);
                return null;
        }
    }

    void BiomeStore(int biomeIndex)
    {
        switch (biomeIndex)
        {
            case (int)Biome.Grass:
                grassPool_Store();
                return;
            case (int)Biome.Tundra:
                tundraPool_Store();
                return;
            case (int)Biome.Desert:
                desertPool_Store();
                return;
            case (int)Biome.Rock:
                rockPool_Store();
                return;
            case (int)Biome.Sand:
                sandPool_Store();
                return;
            case (int)Biome.Water:
                waterPool_Store();
                return;
            case (int)Biome.Dirt:
                dirtPool_Store();
                return;
            case (int)Biome.Dark:
                darkPool_Store();
                return;
            default:
                Debug.LogError("Invalid biome: " + biomeIndex);
                return;
        }
    }

    bool BiomePeekIsInstantiated(int biomeIndex)
    {
        switch (biomeIndex)
        {
            case (int)Biome.Grass:
                return grassPool_PeekIsInstantiated();
            case (int)Biome.Tundra:
                return tundraPool_PeekIsInstantiated();
            case (int)Biome.Desert:
                return desertPool_PeekIsInstantiated();
            case (int)Biome.Rock:
                return rockPool_PeekIsInstantiated();
            case (int)Biome.Sand:
                return sandPool_PeekIsInstantiated();
            case (int)Biome.Water:
                return waterPool_PeekIsInstantiated();
            case (int)Biome.Dirt:
                return dirtPool_PeekIsInstantiated();
            case (int)Biome.Dark:
                return darkPool_PeekIsInstantiated();
            default:
                Debug.LogError("Invalid biome: " + biomeIndex);
                return false;
        }
    }

    int chunkSize => settings_chunkSize;

    int chunkWidth => settings_chunkWidth;

    int chunkDepth => settings_chunkDepth;

    int fieldHeight => settings_fieldHeight;

    int xStartChunkIndex, zStartChunkIndex;
    int xEndChunkIndex, zEndChunkIndex;
    int xSearchStartChunkIndex, zSearchStartChunkIndex;
    int xSearchEndChunkIndex, zSearchEndChunkIndex;
    int batchCount => settings_batchCount;

    float chunkLoadRange => settings_chunkLoadRange;

    float generateAdditionalInterval => settings_generateAdditionalInterval * 2.5f / Networking.LocalPlayer.GetWalkSpeed();

    float cellAnimationTime => settings_cellAnimationTime;

    float removeBatchCount => settings_removeBatchCount;

    float removeInterval => settings_removeInterval;

    float waterPercentage => settings_waterPercentage;

    float chunkUnLoadRange => settings_chunkUnLoadRange;

    float chunkDetailRange => settings_chunkDetailRange;

    float operationBatchCount => settings_operationBatchCount;

    [SerializeField]
    int chunkCapacity = 15000;
    public void OnDeserialization()
    {
        isSynced = true;
    }

    bool isSynced = false;
    void Assert(bool b)
    {
        if (!b)
        {
            Debug.LogError("Assertion failed!");
        }
    }

    void Start()
    {
        chunkPool_Start();
        meshCombiner_Start();
        darkPool_Start();
        waterPool_Start();
        sandPool_Start();
        rockPool_Start();
        dirtPool_Start();
        desertPool_Start();
        tundraPool_Start();
        grassPool_Start();
        outlineDict_SetCapacity(chunkCapacity);
        removedChunkIndexDict_SetCapacity(chunkCapacity);
        loadedChunkIndexDict_SetCapacity(chunkCapacity);
        chunkToCellsDict_SetCapacity(chunkCapacity);
        detailChunkIndexDict_SetCapacity(chunkCapacity);
        searchQueue_SetCapacity(1000);
        detailQueue_SetCapacity(1000);
        tempBreakCellDictionary_SetCapacity(chunkCapacity);
        permanentBreakCellDictionary_SetCapacity(150000);
        brokenArr = new bool[chunkSize * chunkSize * chunkSize];
        _seedX = UnityEngine.Random.value * (float)Int16.MaxValue;
        _seedZ = UnityEngine.Random.value * (float)Int16.MaxValue;
        _seedTX = UnityEngine.Random.value * (float)Int16.MaxValue;
        _seedTZ = UnityEngine.Random.value * (float)Int16.MaxValue;
        _seedHX = UnityEngine.Random.value * (float)Int16.MaxValue;
        _seedHZ = UnityEngine.Random.value * (float)Int16.MaxValue;
        isSynced = true;
        RequestSerialization();
        /*chunkWidth=settings.chunkWidth;
        chunkDepth=settings.chunkDepth;
        chunkSize=settings.chunkSize;
        batchCount=settings.batchCount;
        generateInterval=settings.generateInterval;
        chunkLoadRange=settings.chunkLoadRange;
        generateAdditionalInterval=settings.generateAdditionalInterval *2.5f / Networking.LocalPlayer.GetWalkSpeed();
        cellAnimationTime=settings.cellAnimationTime;*/
        meshFilters = new MeshFilter[chunkSize * chunkSize * chunkSize];
        XSTARTINDEX = -chunkWidth / 2;
        XENDINDEX = chunkWidth - 1 - chunkWidth / 2;
        ZSTARTINDEX = 0;
        ZENDINDEX = chunkDepth;
    }

    int XSTARTINDEX, XENDINDEX, ZSTARTINDEX, ZENDINDEX;
    public void GenerateInit()
    {
        if (!isSynced)
            return;
        if (isGenerating)
            return;
        isGenerating = true;
        playerPos = Networking.LocalPlayer.GetPosition() / (chunkSize * TileScale);
        CalcPosCorrection();
        zStartChunkIndex = GetInRangeStartZChunkIndex(playerPos + posCorrection, chunkLoadRange);
        zEndChunkIndex = GetInRangeEndZChunkIndex(playerPos + posCorrection, chunkLoadRange);
        xStartChunkIndex = GetInRangeStartXChunkIndex(playerPos + posCorrection, zStartChunkIndex, chunkLoadRange);
        xEndChunkIndex = GetInRangeEndXChunkIndex(playerPos + posCorrection, zStartChunkIndex, chunkLoadRange);
        //GenerateInitCellInterval();
        removeXIndex = XSTARTINDEX;
        removeZIndex = ZSTARTINDEX;
        chunkXIndex = 0;
        chunkZIndex = 0;
        chunkYIndex = 0;
        isRemoving = true;
        isSearching = true;
    //RemoveChunkInterval();
    }

    float searchAdditionalInterval => settings_searchAdditionalInterval;

    Vector3 posCorrection = Vector3.zero;
    Vector3 GetPlayerPosition()
    {
        return Networking.LocalPlayer.GetPosition() / (chunkSize * TileScale);
    }

    void CalcPosCorrection()
    {
        playerRot = Networking.LocalPlayer.GetTrackingData(VRCPlayerApi.TrackingDataType.Head).rotation;
        // 極座標へ変換
        float r = 2.5f; // 半径は通常1とするか、必要に応じて変更
        var rad = Mathf.PI / 2 - playerRot.eulerAngles.y * Mathf.Deg2Rad;
        posCorrection.x = Mathf.Cos(rad) * r;
        posCorrection.z = Mathf.Sin(rad) * r;
        Debug.Log("posCorrection: " + posCorrection);
    }

    void GenerateAdditional()
    {
        if (isGenerating)
            return;
        prePlayerPos = playerPos;
        playerPos = GetPlayerPosition(); //Networking.LocalPlayer.GetPosition() / (chunkSize*TileScale);
        CalcPosCorrection();
        //Debug.Log("GenerateAdditional");
        //Debug.Log("player pos: "+playerPos);
        zStartChunkIndex = GetInRangeStartZChunkIndex(playerPos + posCorrection, chunkLoadRange);
        zEndChunkIndex = GetInRangeEndZChunkIndex(playerPos + posCorrection, chunkLoadRange);
        xStartChunkIndex = GetInRangeStartXChunkIndex(playerPos + posCorrection, zStartChunkIndex, chunkLoadRange); //-1;
        xEndChunkIndex = GetInRangeEndXChunkIndex(playerPos + posCorrection, zStartChunkIndex, chunkLoadRange); //-1;
        //exceptXStartChunkIndex=GetInRangeStartXChunkIndex(prePlayerPos+posCorrection,zStartChunkIndex,chunkLoadRange);
        //exceptXEndChunkIndex=GetInRangeEndXChunkIndex(prePlayerPos+posCorrection,zStartChunkIndex,chunkLoadRange);
        isGenerating = true;
    //GenerateCellInterval();
    }

    void SearchAdditional()
    {
        if (searchOn)
        {
            if (isSearching)
            {
                Debug.LogWarning("already searching");
            }

            zSearchStartChunkIndex = GetInRangeStartZChunkIndex(playerPos, chunkUnLoadRange + searchMargin);
            ;
            zSearchEndChunkIndex = GetInRangeEndZChunkIndex(playerPos, chunkUnLoadRange + searchMargin);
            ;
            xSearchStartChunkIndex = GetInRangeStartXChunkIndex(playerPos, zSearchStartChunkIndex, chunkUnLoadRange + searchMargin);
            xSearchEndChunkIndex = GetInRangeEndXChunkIndex(playerPos, zSearchStartChunkIndex, chunkUnLoadRange + searchMargin);
            isSearching = true;
        }
    }

    Vector3 playerPos;
    Quaternion playerRot;
    Vector3 prePlayerPos;
    float ellipseZ = 1f;
    public int GetInRangeStartXChunkIndex(Vector3 pos, float z, float range)
    {
        float diff = range * range - (pos.z - z) * (pos.z - z) / (ellipseZ * ellipseZ);
        if (diff <= 0)
            return chunkWidth / 2;
        return Math.Max(XSTARTINDEX, (int)(pos.x - Mathf.Sqrt(diff)));
    }

    public int GetInRangeEndXChunkIndex(Vector3 pos, float z, float range)
    {
        float diff = Math.Max(0, range * range - (pos.z - z) * (pos.z - z) / (ellipseZ * ellipseZ));
        if (diff == 0)
            return -chunkWidth / 2;
        return Math.Min(XENDINDEX, (int)(pos.x + Mathf.Sqrt(diff)));
    }

    public int GetInRangeStartZChunkIndex(Vector3 pos, float range)
    {
        return Math.Max(ZSTARTINDEX, (int)(pos.z - range * ellipseZ));
    }

    public int GetInRangeEndZChunkIndex(Vector3 pos, float range)
    {
        return Math.Min(ZENDINDEX, (int)(pos.z + range * ellipseZ));
    }

    bool IsInDetailRange(Vector3 pPos, int x, int z)
    {
        return (pPos.x - x) * (pPos.x - x) + (pPos.z - z) * (pPos.z - z) / (ellipseZ * ellipseZ) < chunkDetailRange * chunkDetailRange;
    }

    int exceptXStartChunkIndex;
    int exceptXEndChunkIndex;
    int exceptZStartChunkIndex;
    int exceptZEndChunkIndex;
    bool isGenerating = false;
    int[][] outlineDict__keys;
    GameObject[][][] outlineDict__values;
    int outlineDict__size;
    public int outlineDict_Count => outlineDict__size;

    const int outlineDict_bucketCount = 3;
    public void outlineDict_SetCapacity(int capacity)
    {
        int len = capacity / outlineDict_bucketCount;
        outlineDict__keys = new int[len][];
        for (int i = 0; i < outlineDict__keys.Length; i++)
        {
            outlineDict__keys[i] = new int[outlineDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < outlineDict_bucketCount; i++)
        {
            outlineDict__keys[0][i] = int.MaxValue;
        }

        outlineDict__values = new GameObject[len][][];
        for (int i = 0; i < outlineDict__values.Length; i++)
        {
            outlineDict__values[i] = new GameObject[outlineDict_bucketCount][];
        }
    }

    public bool outlineDict_HasItem(int key)
    {
        var index = outlineDict_Hash(key);
        var hashKeys = outlineDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int outlineDict_Hash(int key)
    {
        var len = outlineDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public int[] outlineDict_GenerateKeysArray()
    {
        int[] keys = new int[outlineDict__size];
        int index = 0;
        for (int i = 0; i < outlineDict__keys.Length; i++)
        {
            var hashKeys = outlineDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    public bool outlineDict_Add(int key, GameObject[] value)
    {
        int index = outlineDict_Hash(key);
        var hashKeys = outlineDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    outlineDict__keys[index][i] = key;
                    outlineDict__values[index][i] = value;
                    outlineDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    outlineDict__keys[index][i] = key;
                    outlineDict__values[index][i] = value;
                    outlineDict__size++;
                    return true;
                }
            }
        }

        outlineDict_ExpandList(index);
        var preLen = hashKeys.Length;
        Debug.LogWarning("InkEyGameObjectArrDictionary Add: Dictionary is full");
        outlineDict__keys[index][preLen] = key;
        outlineDict__values[index][preLen] = value;
        outlineDict__size++;
        return true;
    }

    const int outlineDict_expand = 10;
    void outlineDict_ExpandList(int index)
    {
        var hashKeys = outlineDict__keys[index];
        var hashValues = outlineDict__values[index];
        var len = outlineDict__keys[index].Length + outlineDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len][];
        for (int i = 0; i < outlineDict__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = outlineDict__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        outlineDict__keys[index] = newKeys;
        outlineDict__values[index] = newValues;
    }

    public void outlineDict_AddOrSetValue(int key, GameObject[] value)
    {
        int index = outlineDict_Hash(key);
        var hashKeys = outlineDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    outlineDict__keys[index][i] = key;
                    outlineDict__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    outlineDict__keys[index][i] = key;
                    outlineDict__values[index][i] = value;
                    outlineDict__size++;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    outlineDict__keys[index][i] = key;
                    outlineDict__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == default)
                {
                    outlineDict__keys[index][i] = key;
                    outlineDict__values[index][i] = value;
                    outlineDict__size++;
                    return;
                }
            }
        }

        var preLen = hashKeys.Length;
        outlineDict_ExpandList(index);
        Debug.LogWarning("InkEyGameObjectArrDictionary AddOrSet: Dictionary is full");
        outlineDict__keys[index][preLen] = key;
        outlineDict__values[index][preLen] = value;
        outlineDict__size++;
    }

    public void outlineDict_SetValue(int key, GameObject[] value)
    {
        int index = outlineDict_Hash(key);
        var hashKeys = outlineDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    outlineDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    outlineDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject[] outlineDict_GetValue(int key)
    {
        int index = outlineDict_Hash(key);
        var hashKeys = outlineDict__keys[index];
        var hashValues = outlineDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void outlineDict_Remove(int key)
    {
        int index = outlineDict_Hash(key);
        var hashKeys = outlineDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    outlineDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    outlineDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    int[][] removedChunkIndexDict__keys;
    bool[][] removedChunkIndexDict__values;
    int removedChunkIndexDict__size;
    public int removedChunkIndexDict_Count => removedChunkIndexDict__size;

    public int[] removedChunkIndexDict_GenerateKeysArray()
    {
        int[] keys = new int[removedChunkIndexDict__size];
        int index = 0;
        for (int i = 0; i < removedChunkIndexDict__keys.Length; i++)
        {
            var hashKeys = removedChunkIndexDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int removedChunkIndexDict_bucketCount = 3;
    public void removedChunkIndexDict_SetCapacity(int capacity)
    {
        int len = capacity / removedChunkIndexDict_bucketCount;
        removedChunkIndexDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            removedChunkIndexDict__keys[i] = new int[removedChunkIndexDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < removedChunkIndexDict_bucketCount; i++)
        {
            removedChunkIndexDict__keys[0][i] = int.MaxValue;
        }

        removedChunkIndexDict__values = new bool[len][];
        for (int i = 0; i < len; i++)
        {
            removedChunkIndexDict__values[i] = new bool[removedChunkIndexDict_bucketCount];
        }
    }

    public bool removedChunkIndexDict_HasItem(int key)
    {
        var index = removedChunkIndexDict_Hash(key);
        var hashKeys = removedChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int removedChunkIndexDict_Hash(int key)
    {
        var len = removedChunkIndexDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool removedChunkIndexDict_Add(int key, bool value)
    {
        int index = removedChunkIndexDict_Hash(key);
        var hashKeys = removedChunkIndexDict__keys[index];
        if (key == int.MaxValue)
        {
            Debug.LogError("not allowed key value");
        }

        if (index == 0)
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    removedChunkIndexDict__keys[index][i] = key;
                    removedChunkIndexDict__values[index][i] = value;
                    removedChunkIndexDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    removedChunkIndexDict__keys[index][i] = key;
                    removedChunkIndexDict__values[index][i] = value;
                    removedChunkIndexDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyBoolDictionary Add: Dictionary is full");
        var preLen = hashKeys.Length;
        removedChunkIndexDict_ExpandList(index);
        removedChunkIndexDict__keys[index][preLen] = key;
        removedChunkIndexDict__values[index][preLen] = value;
        removedChunkIndexDict__size++;
        return true;
    }

    const int removedChunkIndexDict_expand = 10;
    void removedChunkIndexDict_ExpandList(int index)
    {
        var hashKeys = removedChunkIndexDict__keys[index];
        var hashValues = removedChunkIndexDict__values[index];
        var len = removedChunkIndexDict__keys[index].Length + removedChunkIndexDict_expand;
        var newKeys = new int[len];
        var newValues = new bool[len];
        for (int i = 0; i < removedChunkIndexDict__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = removedChunkIndexDict__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        removedChunkIndexDict__keys[index] = newKeys;
        removedChunkIndexDict__values[index] = newValues;
    }

    public bool removedChunkIndexDict_AddOrSetValue(int key, bool value)
    {
        int index = removedChunkIndexDict_Hash(key);
        var hashKeys = removedChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    removedChunkIndexDict__keys[index][i] = key;
                    removedChunkIndexDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    removedChunkIndexDict__keys[index][i] = key;
                    removedChunkIndexDict__values[index][i] = value;
                    removedChunkIndexDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    removedChunkIndexDict__keys[index][i] = key;
                    removedChunkIndexDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    removedChunkIndexDict__keys[index][i] = key;
                    removedChunkIndexDict__values[index][i] = value;
                    removedChunkIndexDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogError("InkEyBoolDictionary AddOrSetValue: Dictionary is full");
        //return false;
        var preLen = hashKeys.Length;
        removedChunkIndexDict_ExpandList(index);
        removedChunkIndexDict__keys[index][preLen] = key;
        removedChunkIndexDict__values[index][preLen] = value;
        removedChunkIndexDict__size++;
        return true;
    }

    public void removedChunkIndexDict_SetValue(int key, bool value)
    {
        int index = removedChunkIndexDict_Hash(key);
        var hashKeys = removedChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    removedChunkIndexDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    removedChunkIndexDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public bool removedChunkIndexDict_GetValueOrDefault(int key, bool defaultValue)
    {
        int index = removedChunkIndexDict_Hash(key);
        var hashKeys = removedChunkIndexDict__keys[index];
        var hashValues = removedChunkIndexDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return defaultValue;
    }

    public bool removedChunkIndexDict_GetValue(int key)
    {
        int index = removedChunkIndexDict_Hash(key);
        var hashKeys = removedChunkIndexDict__keys[index];
        var hashValues = removedChunkIndexDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void removedChunkIndexDict_TryRemoveBatch(int[] keys, bool[] result)
    {
        for (int i = 0; i < keys.Length; i++)
        {
            result[i] = removedChunkIndexDict_TryRemove(keys[i]);
        }
    }

    public bool removedChunkIndexDict_TryRemove(int key)
    {
        int index = removedChunkIndexDict_Hash(key);
        var hashKeys = removedChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    removedChunkIndexDict__size--;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    removedChunkIndexDict__size--;
                    return true;
                }
            }
        }

        return false;
    }

    public void removedChunkIndexDict_Remove(int key)
    {
        if (!removedChunkIndexDict_TryRemove(key))
            Debug.LogError("Key not found");
    }

    int[][] loadedChunkIndexDict__keys;
    bool[][] loadedChunkIndexDict__values;
    int loadedChunkIndexDict__size;
    public int loadedChunkIndexDict_Count => loadedChunkIndexDict__size;

    public int[] loadedChunkIndexDict_GenerateKeysArray()
    {
        int[] keys = new int[loadedChunkIndexDict__size];
        int index = 0;
        for (int i = 0; i < loadedChunkIndexDict__keys.Length; i++)
        {
            var hashKeys = loadedChunkIndexDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int loadedChunkIndexDict_bucketCount = 3;
    public void loadedChunkIndexDict_SetCapacity(int capacity)
    {
        int len = capacity / loadedChunkIndexDict_bucketCount;
        loadedChunkIndexDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            loadedChunkIndexDict__keys[i] = new int[loadedChunkIndexDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < loadedChunkIndexDict_bucketCount; i++)
        {
            loadedChunkIndexDict__keys[0][i] = int.MaxValue;
        }

        loadedChunkIndexDict__values = new bool[len][];
        for (int i = 0; i < len; i++)
        {
            loadedChunkIndexDict__values[i] = new bool[loadedChunkIndexDict_bucketCount];
        }
    }

    public bool loadedChunkIndexDict_HasItem(int key)
    {
        var index = loadedChunkIndexDict_Hash(key);
        var hashKeys = loadedChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int loadedChunkIndexDict_Hash(int key)
    {
        var len = loadedChunkIndexDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool loadedChunkIndexDict_Add(int key, bool value)
    {
        int index = loadedChunkIndexDict_Hash(key);
        var hashKeys = loadedChunkIndexDict__keys[index];
        if (key == int.MaxValue)
        {
            Debug.LogError("not allowed key value");
        }

        if (index == 0)
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    loadedChunkIndexDict__keys[index][i] = key;
                    loadedChunkIndexDict__values[index][i] = value;
                    loadedChunkIndexDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    loadedChunkIndexDict__keys[index][i] = key;
                    loadedChunkIndexDict__values[index][i] = value;
                    loadedChunkIndexDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyBoolDictionary Add: Dictionary is full");
        var preLen = hashKeys.Length;
        loadedChunkIndexDict_ExpandList(index);
        loadedChunkIndexDict__keys[index][preLen] = key;
        loadedChunkIndexDict__values[index][preLen] = value;
        loadedChunkIndexDict__size++;
        return true;
    }

    const int loadedChunkIndexDict_expand = 10;
    void loadedChunkIndexDict_ExpandList(int index)
    {
        var hashKeys = loadedChunkIndexDict__keys[index];
        var hashValues = loadedChunkIndexDict__values[index];
        var len = loadedChunkIndexDict__keys[index].Length + loadedChunkIndexDict_expand;
        var newKeys = new int[len];
        var newValues = new bool[len];
        for (int i = 0; i < loadedChunkIndexDict__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = loadedChunkIndexDict__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        loadedChunkIndexDict__keys[index] = newKeys;
        loadedChunkIndexDict__values[index] = newValues;
    }

    public bool loadedChunkIndexDict_AddOrSetValue(int key, bool value)
    {
        int index = loadedChunkIndexDict_Hash(key);
        var hashKeys = loadedChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    loadedChunkIndexDict__keys[index][i] = key;
                    loadedChunkIndexDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    loadedChunkIndexDict__keys[index][i] = key;
                    loadedChunkIndexDict__values[index][i] = value;
                    loadedChunkIndexDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    loadedChunkIndexDict__keys[index][i] = key;
                    loadedChunkIndexDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    loadedChunkIndexDict__keys[index][i] = key;
                    loadedChunkIndexDict__values[index][i] = value;
                    loadedChunkIndexDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogError("InkEyBoolDictionary AddOrSetValue: Dictionary is full");
        //return false;
        var preLen = hashKeys.Length;
        loadedChunkIndexDict_ExpandList(index);
        loadedChunkIndexDict__keys[index][preLen] = key;
        loadedChunkIndexDict__values[index][preLen] = value;
        loadedChunkIndexDict__size++;
        return true;
    }

    public void loadedChunkIndexDict_SetValue(int key, bool value)
    {
        int index = loadedChunkIndexDict_Hash(key);
        var hashKeys = loadedChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    loadedChunkIndexDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    loadedChunkIndexDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public bool loadedChunkIndexDict_GetValueOrDefault(int key, bool defaultValue)
    {
        int index = loadedChunkIndexDict_Hash(key);
        var hashKeys = loadedChunkIndexDict__keys[index];
        var hashValues = loadedChunkIndexDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return defaultValue;
    }

    public bool loadedChunkIndexDict_GetValue(int key)
    {
        int index = loadedChunkIndexDict_Hash(key);
        var hashKeys = loadedChunkIndexDict__keys[index];
        var hashValues = loadedChunkIndexDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void loadedChunkIndexDict_TryRemoveBatch(int[] keys, bool[] result)
    {
        for (int i = 0; i < keys.Length; i++)
        {
            result[i] = loadedChunkIndexDict_TryRemove(keys[i]);
        }
    }

    public bool loadedChunkIndexDict_TryRemove(int key)
    {
        int index = loadedChunkIndexDict_Hash(key);
        var hashKeys = loadedChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    loadedChunkIndexDict__size--;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    loadedChunkIndexDict__size--;
                    return true;
                }
            }
        }

        return false;
    }

    public void loadedChunkIndexDict_Remove(int key)
    {
        if (!loadedChunkIndexDict_TryRemove(key))
            Debug.LogError("Key not found");
    }

    float generateAdditionalDelta = -1f;
    float searchAdditionalDelta = -1f;
    int isInstantiatedCost = 10;
    int poolCost = 3;
    int storeCount = 0;
    int storeMax = 3;
    int biomeIndex = 0;
    UdonSavingObjectPool storeBiomePool;
    void StoreCell()
    {
        BiomeStore(biomeIndex);
        isInstantiated = BiomePeekIsInstantiated(biomeIndex); //storeBiomePool.PeekIsInstantiated();
        biomeIndex++;
        biomeIndex %= (int)Biome.Dark;
    }

    int costIndex;
    GenerateChunkMode mode;
    void Update()
    {
        if (isGenerating)
        {
            //if(isUnLoading)return;
            for (costIndex = 0; costIndex < batchCount * isInstantiatedCost;)
            {
                //delay=generateInterval * count / batchCount;
                mode = GenerateChunk();
                if (isInstantiated)
                {
                    costIndex += isInstantiatedCost;
                    isInstantiated = false;
                }
                else if (mode == GenerateChunkMode.Pass)
                {
                    storeCount++;
                    if (storeCount == storeMax)
                    {
                        StoreCell();
                        storeCount = 0;
                    }

                    if (isInstantiated)
                    {
                        costIndex += isInstantiatedCost;
                        isInstantiated = false;
                    }
                    else
                    {
                        costIndex++;
                    }
                }
                else
                {
                    costIndex += poolCost;
                }

                if (mode == GenerateChunkMode.Complete || mode == GenerateChunkMode.Pass)
                {
                    chunkXIndex = 0;
                    chunkZIndex = 0;
                    chunkYIndex = 0;
                    xStartChunkIndex++;
                    if (xStartChunkIndex > xEndChunkIndex)
                    {
                        zStartChunkIndex++;
                        xStartChunkIndex = GetInRangeStartXChunkIndex(playerPos + posCorrection, zStartChunkIndex, chunkLoadRange);
                        xEndChunkIndex = GetInRangeEndXChunkIndex(playerPos + posCorrection, zStartChunkIndex, chunkLoadRange);
                        if (zStartChunkIndex >= zEndChunkIndex)
                        {
                            isGenerating = false;
                            //GenerateAdditional();
                            if (generateAdditionalInterval == 0)
                            {
                                GenerateAdditional();
                            }
                            else
                            {
                                generateAdditionalDelta = generateAdditionalInterval;
                            }

                            //SendCustomEventDelayedSeconds(nameof(GenerateAdditional),generateAdditionalInterval);
                            break;
                        }
                    }
                }

                if (mode == GenerateChunkMode.Complete)
                {
                    break;
                }
            }
        }
        else
        {
            if (generateAdditionalDelta >= 0)
            {
                generateAdditionalDelta -= Time.deltaTime;
                if (generateAdditionalDelta < 0)
                {
                    GenerateAdditional();
                }
            }
        }

        /*if(isRemoving&&removeOn){
            //if(isUnLoading)return;
            for( removeCount=0;removeCount<removeBatchCount;removeCount++){
                if(removeXIndex>=XENDINDEX){
                    removeZIndex++;
                    removeXIndex=XSTARTINDEX;
                    if(removeZIndex>=ZENDINDEX){
                        isRemoving=false;
                        break;
                    }
                } else {
                    removeXIndex++;
                }
                float delay=removeInterval * removeCount / removeBatchCount;
                removeCount+=RemoveChunk(delay);
            }
        }*/
        if (isSearching)
        {
            //if(isUnLoading)return;
            for (costIndex = 0; costIndex < searchBatchCount; costIndex++)
            {
                var x = xSearchStartChunkIndex;
                var z = zSearchStartChunkIndex;
                var chunkIndex = ToChunkIndex(x, z);
                if (loadedChunkIndexDict_HasItem(chunkIndex) && loadedChunkIndexDict_GetValue(chunkIndex))
                {
                    var diffx = x - playerPos.x;
                    var diffz = z - playerPos.z;
                    var distance = diffx * diffx + diffz * diffz;
                    if (distance >= chunkUnLoadRange * chunkUnLoadRange)
                    {
                        searchQueue_Enqueue(new Vector4(x, 0, z, (int)ChunkOperation.UnLoad));
                    //UnLoadChunk((int)x,(int)z,true);
                    }
                    else if (distance <= chunkDetailRange * chunkDetailRange)
                    {
                        if (!detailChunkIndexDict_GetValueOrDefault(chunkIndex, false))
                        {
                            detailQueue_Enqueue(new Vector4(x, 0, z, (int)ChunkOperation.Detail));
                        }
                    //DetailChunk((int)x,(int)z);
                    }
                    else
                    {
                        if (detailChunkIndexDict_GetValueOrDefault(chunkIndex, false))
                        {
                            searchQueue_Enqueue(new Vector4(x, 0, z, (int)ChunkOperation.UnDetail));
                        }
                    //UnDetailChunk((int)chunkPos.x,(int)chunkPos.z);
                    }
                }

                xSearchStartChunkIndex++;
                if (xSearchStartChunkIndex > xSearchEndChunkIndex)
                {
                    zSearchStartChunkIndex++;
                    xSearchStartChunkIndex = GetInRangeStartXChunkIndex(playerPos, zSearchStartChunkIndex, chunkUnLoadRange + searchMargin);
                    xSearchEndChunkIndex = GetInRangeEndXChunkIndex(playerPos, zSearchStartChunkIndex, chunkUnLoadRange + searchMargin);
                    if (zSearchStartChunkIndex >= zSearchEndChunkIndex)
                    {
                        isSearching = false;
                        break;
                    }
                }
            }
        }
        else
        {
            if (searchAdditionalDelta >= 0)
            {
                searchAdditionalDelta -= Time.deltaTime;
                if (searchAdditionalDelta < 0)
                {
                    SearchAdditional();
                }
            }
            else
            {
                if (searchQueue_Count == 0 && detailQueue_Count == 0)
                {
                    searchAdditionalDelta = searchAdditionalInterval; // search処理で最後に一回だけ呼ばれる
                };
            }
        }

        if (searchQueue_Count > 0 || detailQueue_Count > 0)
        {
            for (costIndex = 0; costIndex < operationBatchCount;)
            {
                Vector4 operation;
                if (detailQueue_Count > 0)
                {
                    operation = detailQueue_Dequeue();
                }
                else
                {
                    if (searchQueue_Count == 0)
                        break;
                    operation = searchQueue_Dequeue();
                }

                int mode = (int)operation.w;
                if (mode == (int)ChunkOperation.Detail)
                {
                    //Debug.Log("operation detail: "+operation);
                    if (DetailChunk((int)operation.x, (int)operation.z))
                        costIndex++;
                }
                else if (mode == (int)ChunkOperation.UnDetail)
                {
                    //Debug.Log("operation undetail: "+operation);
                    if (UnDetailChunk((int)operation.x, (int)operation.z))
                        costIndex++;
                }
                else if (mode == (int)ChunkOperation.UnLoad)
                {
                    //Debug.Log("operation unload: "+operation);
                    if (UnLoadChunk((int)operation.x, (int)operation.z, true))
                        costIndex++;
                }
                else
                {
                    Debug.LogError("Invalid operation mode: " + mode);
                }
            }
        }
    }

    float searchMargin => chunkDetailRange * 2;

    bool isSearching = false;
    int searchBatchCount => settings_searchBatchCount;

    int removeXIndex = 0;
    int removeZIndex = 0;
    int removeCount = 0;
    bool isRemoving = false;
    bool removeOn => settings_removeOn;

    bool searchOn => settings_searchOn;

    //[SerializeField,UnrollAttribute]MapChunkOperatorGroup chunkOperatorGroup;
    //[SerializeField,UnrollAttribute]MapCellOperatorGroup cellOperatorGroup;
    public int RemoveChunk(float delay)
    {
        int chunkIndex = ToChunkIndex(removeXIndex, removeZIndex);
        removedChunkIndexDict_Add(chunkIndex, true);
        if (outlineDict_HasItem(chunkIndex) && loadedChunkIndexDict_GetValueOrDefault(chunkIndex, false))
        {
            UnDetailChunk((int)removeXIndex, (int)removeZIndex);
            var allParts = outlineDict_GetValue(chunkIndex);
            Debug.Log("RemoveChunk: " + chunkIndex);
        /*chunkOperatorGroup.StartAnimation(allParts[0],AnimDir.Down,cellAnimationTime,delay,this,removeXIndex,removeZIndex);
            for(int i=1;i<allParts.Length;i++){
                cellOperatorGroup.StartAnimation(allParts[i],AnimDir.Down,cellAnimationTime,delay);
                // TODO: set call back for cell return;
            }*/
        }

        return chunkSize * chunkSize * chunkSize;
    }

    int ToChunkIndex(int x, int z)
    {
        return (z - ZSTARTINDEX) * chunkWidth + (x - XSTARTINDEX);
    }

    public const float AnimHeight = 10f;
    private Vector4[] searchQueue__array;
    private int searchQueue__head; // First valid element in the queue.
    private int searchQueue__tail; // Last valid element in the queue.
    private int searchQueue__size; // Number of elements.
    private int searchQueue__version;
    private const int searchQueue_MinimumGrow = 100000;
    public int searchQueue_Count => searchQueue__size;
    public int searchQueue_Version => searchQueue__version;

    [Obsolete("Use Count Property.")]
    public int searchQueue_GetCount() => searchQueue__size;
    [Obsolete("Use Version Property.")]
    public int searchQueue_GetVersion() => searchQueue__version;
    // Removes all Objects from the queue.
    public void searchQueue_Clear()
    {
        if (searchQueue__size != 0)
        {
            if (searchQueue__head < searchQueue__tail)
            {
                Array.Clear(searchQueue__array, searchQueue__head, searchQueue__size);
            }
            else
            {
                Array.Clear(searchQueue__array, searchQueue__head, searchQueue__array.Length - searchQueue__head);
                Array.Clear(searchQueue__array, 0, searchQueue__tail);
            }

            searchQueue__size = 0;
        }

        searchQueue__head = 0;
        searchQueue__tail = 0;
        searchQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    // Adds obj to the tail of the queue.
    public void searchQueue_Enqueue(Vector4 obj)
    {
        if (searchQueue__array == null)
        {
            searchQueue_SetCapacity(searchQueue_MinimumGrow);
        }
        else if (searchQueue__size == searchQueue__array.Length)
        {
            searchQueue_SetCapacity(searchQueue__array.Length + searchQueue_MinimumGrow);
        }

        searchQueue__array[searchQueue__tail] = obj;
        searchQueue__tail = (searchQueue__tail + 1) % searchQueue__array.Length;
        searchQueue__size++;
        searchQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public Vector4 searchQueue_Dequeue()
    {
        if (searchQueue__size == 0)
            Debug.LogError("Queue is empty!");
        Vector4 removed = searchQueue__array[searchQueue__head];
        searchQueue__array[searchQueue__head] = Vector4.zero;
        searchQueue__head = (searchQueue__head + 1) % searchQueue__array.Length;
        searchQueue__size--;
        searchQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public Vector4 searchQueue_Peek()
    {
        if (searchQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return Vector4.zero;
        }

        return searchQueue__array[searchQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void searchQueue_SetCapacity(int capacity)
    {
        Vector4[] newArray = new Vector4[capacity];
        if (searchQueue__size == 0)
        {
        }
        else if (searchQueue__head < searchQueue__tail)
        {
            Debug.LogWarning("ChunkOperationQueue: SetCapacity: _head < _tail");
            Array.Copy(searchQueue__array, searchQueue__head, newArray, 0, searchQueue__size);
        }
        else
        {
            Debug.LogWarning("ChunkOperationQueue: SetCapacity: _head >= _tail");
            int toHead = searchQueue__array.Length - searchQueue__head;
            Array.Copy(searchQueue__array, searchQueue__head, newArray, 0, toHead);
            Array.Copy(searchQueue__array, 0, newArray, toHead, searchQueue__tail);
        }

        searchQueue__array = newArray;
        searchQueue__head = 0;
        searchQueue__tail = searchQueue__size == capacity ? 0 : searchQueue__size;
        searchQueue__version++;
    }

    private Vector4[] detailQueue__array;
    private int detailQueue__head; // First valid element in the queue.
    private int detailQueue__tail; // Last valid element in the queue.
    private int detailQueue__size; // Number of elements.
    private int detailQueue__version;
    private const int detailQueue_MinimumGrow = 100000;
    public int detailQueue_Count => detailQueue__size;
    public int detailQueue_Version => detailQueue__version;

    [Obsolete("Use Count Property.")]
    public int detailQueue_GetCount() => detailQueue__size;
    [Obsolete("Use Version Property.")]
    public int detailQueue_GetVersion() => detailQueue__version;
    // Removes all Objects from the queue.
    public void detailQueue_Clear()
    {
        if (detailQueue__size != 0)
        {
            if (detailQueue__head < detailQueue__tail)
            {
                Array.Clear(detailQueue__array, detailQueue__head, detailQueue__size);
            }
            else
            {
                Array.Clear(detailQueue__array, detailQueue__head, detailQueue__array.Length - detailQueue__head);
                Array.Clear(detailQueue__array, 0, detailQueue__tail);
            }

            detailQueue__size = 0;
        }

        detailQueue__head = 0;
        detailQueue__tail = 0;
        detailQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    // Adds obj to the tail of the queue.
    public void detailQueue_Enqueue(Vector4 obj)
    {
        if (detailQueue__array == null)
        {
            detailQueue_SetCapacity(detailQueue_MinimumGrow);
        }
        else if (detailQueue__size == detailQueue__array.Length)
        {
            detailQueue_SetCapacity(detailQueue__array.Length + detailQueue_MinimumGrow);
        }

        detailQueue__array[detailQueue__tail] = obj;
        detailQueue__tail = (detailQueue__tail + 1) % detailQueue__array.Length;
        detailQueue__size++;
        detailQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public Vector4 detailQueue_Dequeue()
    {
        if (detailQueue__size == 0)
            Debug.LogError("Queue is empty!");
        Vector4 removed = detailQueue__array[detailQueue__head];
        detailQueue__array[detailQueue__head] = Vector4.zero;
        detailQueue__head = (detailQueue__head + 1) % detailQueue__array.Length;
        detailQueue__size--;
        detailQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public Vector4 detailQueue_Peek()
    {
        if (detailQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return Vector4.zero;
        }

        return detailQueue__array[detailQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void detailQueue_SetCapacity(int capacity)
    {
        Vector4[] newArray = new Vector4[capacity];
        if (detailQueue__size == 0)
        {
        }
        else if (detailQueue__head < detailQueue__tail)
        {
            Debug.LogWarning("ChunkOperationQueue: SetCapacity: _head < _tail");
            Array.Copy(detailQueue__array, detailQueue__head, newArray, 0, detailQueue__size);
        }
        else
        {
            Debug.LogWarning("ChunkOperationQueue: SetCapacity: _head >= _tail");
            int toHead = detailQueue__array.Length - detailQueue__head;
            Array.Copy(detailQueue__array, detailQueue__head, newArray, 0, toHead);
            Array.Copy(detailQueue__array, 0, newArray, toHead, detailQueue__tail);
        }

        detailQueue__array = newArray;
        detailQueue__head = 0;
        detailQueue__tail = detailQueue__size == capacity ? 0 : detailQueue__size;
        detailQueue__version++;
    }

    int[][] detailChunkIndexDict__keys;
    bool[][] detailChunkIndexDict__values;
    int detailChunkIndexDict__size;
    public int detailChunkIndexDict_Count => detailChunkIndexDict__size;

    public int[] detailChunkIndexDict_GenerateKeysArray()
    {
        int[] keys = new int[detailChunkIndexDict__size];
        int index = 0;
        for (int i = 0; i < detailChunkIndexDict__keys.Length; i++)
        {
            var hashKeys = detailChunkIndexDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int detailChunkIndexDict_bucketCount = 3;
    public void detailChunkIndexDict_SetCapacity(int capacity)
    {
        int len = capacity / detailChunkIndexDict_bucketCount;
        detailChunkIndexDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            detailChunkIndexDict__keys[i] = new int[detailChunkIndexDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < detailChunkIndexDict_bucketCount; i++)
        {
            detailChunkIndexDict__keys[0][i] = int.MaxValue;
        }

        detailChunkIndexDict__values = new bool[len][];
        for (int i = 0; i < len; i++)
        {
            detailChunkIndexDict__values[i] = new bool[detailChunkIndexDict_bucketCount];
        }
    }

    public bool detailChunkIndexDict_HasItem(int key)
    {
        var index = detailChunkIndexDict_Hash(key);
        var hashKeys = detailChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int detailChunkIndexDict_Hash(int key)
    {
        var len = detailChunkIndexDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool detailChunkIndexDict_Add(int key, bool value)
    {
        int index = detailChunkIndexDict_Hash(key);
        var hashKeys = detailChunkIndexDict__keys[index];
        if (key == int.MaxValue)
        {
            Debug.LogError("not allowed key value");
        }

        if (index == 0)
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    detailChunkIndexDict__keys[index][i] = key;
                    detailChunkIndexDict__values[index][i] = value;
                    detailChunkIndexDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    detailChunkIndexDict__keys[index][i] = key;
                    detailChunkIndexDict__values[index][i] = value;
                    detailChunkIndexDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyBoolDictionary Add: Dictionary is full");
        var preLen = hashKeys.Length;
        detailChunkIndexDict_ExpandList(index);
        detailChunkIndexDict__keys[index][preLen] = key;
        detailChunkIndexDict__values[index][preLen] = value;
        detailChunkIndexDict__size++;
        return true;
    }

    const int detailChunkIndexDict_expand = 10;
    void detailChunkIndexDict_ExpandList(int index)
    {
        var hashKeys = detailChunkIndexDict__keys[index];
        var hashValues = detailChunkIndexDict__values[index];
        var len = detailChunkIndexDict__keys[index].Length + detailChunkIndexDict_expand;
        var newKeys = new int[len];
        var newValues = new bool[len];
        for (int i = 0; i < detailChunkIndexDict__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = detailChunkIndexDict__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        detailChunkIndexDict__keys[index] = newKeys;
        detailChunkIndexDict__values[index] = newValues;
    }

    public bool detailChunkIndexDict_AddOrSetValue(int key, bool value)
    {
        int index = detailChunkIndexDict_Hash(key);
        var hashKeys = detailChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    detailChunkIndexDict__keys[index][i] = key;
                    detailChunkIndexDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    detailChunkIndexDict__keys[index][i] = key;
                    detailChunkIndexDict__values[index][i] = value;
                    detailChunkIndexDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    detailChunkIndexDict__keys[index][i] = key;
                    detailChunkIndexDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    detailChunkIndexDict__keys[index][i] = key;
                    detailChunkIndexDict__values[index][i] = value;
                    detailChunkIndexDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogError("InkEyBoolDictionary AddOrSetValue: Dictionary is full");
        //return false;
        var preLen = hashKeys.Length;
        detailChunkIndexDict_ExpandList(index);
        detailChunkIndexDict__keys[index][preLen] = key;
        detailChunkIndexDict__values[index][preLen] = value;
        detailChunkIndexDict__size++;
        return true;
    }

    public void detailChunkIndexDict_SetValue(int key, bool value)
    {
        int index = detailChunkIndexDict_Hash(key);
        var hashKeys = detailChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    detailChunkIndexDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    detailChunkIndexDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public bool detailChunkIndexDict_GetValueOrDefault(int key, bool defaultValue)
    {
        int index = detailChunkIndexDict_Hash(key);
        var hashKeys = detailChunkIndexDict__keys[index];
        var hashValues = detailChunkIndexDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return defaultValue;
    }

    public bool detailChunkIndexDict_GetValue(int key)
    {
        int index = detailChunkIndexDict_Hash(key);
        var hashKeys = detailChunkIndexDict__keys[index];
        var hashValues = detailChunkIndexDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void detailChunkIndexDict_TryRemoveBatch(int[] keys, bool[] result)
    {
        for (int i = 0; i < keys.Length; i++)
        {
            result[i] = detailChunkIndexDict_TryRemove(keys[i]);
        }
    }

    public bool detailChunkIndexDict_TryRemove(int key)
    {
        int index = detailChunkIndexDict_Hash(key);
        var hashKeys = detailChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    detailChunkIndexDict__size--;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    detailChunkIndexDict__size--;
                    return true;
                }
            }
        }

        return false;
    }

    public void detailChunkIndexDict_Remove(int key)
    {
        if (!detailChunkIndexDict_TryRemove(key))
            Debug.LogError("Key not found");
    }

    bool DetailChunk(int xIndex, int zIndex)
    {
        int chunkIndex = ToChunkIndex(xIndex, zIndex);
        if (!detailChunkIndexDict_GetValueOrDefault(chunkIndex, false))
        {
            if (outlineDict_HasItem(chunkIndex))
            {
                //Debug.Log("DetailChunk: "+chunkIndex);
                var outlines = outlineDict_GetValue(chunkIndex);
                var cells = chunkToCellsDict_GetValue(chunkIndex);
                for (int i = 0; i < cells.Length; i++)
                {
                    brokenArr[i] = false;
                    if (tempBreakCellDictionary_HasItem(cells[i].GetInstanceID()) || permanentBreakCellDictionary_HasItem(ToGlobalCellIndex(i, chunkIndex)))
                    {
                        brokenArr[i] = true;
                    }
                }

                meshCombiner_SwitchCombineMesh(false, outlines, cells, brokenArr);
                detailChunkIndexDict_AddOrSetValue(chunkIndex, true);
                return true;
            }
            else
            {
                Debug.LogWarning("DetailChunk: chunkIndexDict not has item");
            }
        }

        return false;
    }

    bool[] brokenArr;
    bool UnDetailChunk(int xIndex, int zIndex)
    {
        int chunkIndex = ToChunkIndex(xIndex, zIndex);
        if (detailChunkIndexDict_GetValueOrDefault(chunkIndex, false))
        {
            if (outlineDict_HasItem(chunkIndex))
            {
                //Debug.Log("UnDetailChunk: "+chunkIndex);
                var outlines = outlineDict_GetValue(chunkIndex);
                var cells = chunkToCellsDict_GetValue(chunkIndex);
                meshCombiner_SwitchCombineMesh(true, outlines, cells, brokenArr);
                detailChunkIndexDict_AddOrSetValue(chunkIndex, false);
                return true;
            }
            else
            {
                Debug.LogWarning("UnDetailChunk: chunkIndexDict not has item");
            }
        }

        return false;
    }

    public bool UnLoadChunk(int xIndex, int zIndex, bool setOnly = false)
    {
        int chunkIndex = ToChunkIndex(xIndex, zIndex);
        if (!loadedChunkIndexDict_GetValueOrDefault(chunkIndex, false))
        {
            Debug.Log("UnLoadChunk: not yet loaded");
            //遅延実行の関係上このケースは起こりえる
            return false;
        }

        if (outlineDict_HasItem(chunkIndex))
        {
            //Debug.Log("UnLoadChunk:"+chunkIndex);
            var allParts = outlineDict_GetValue(chunkIndex);
            if (setOnly)
            {
                loadedChunkIndexDict_SetValue(chunkIndex, false);
            }
            else
            {
                loadedChunkIndexDict_AddOrSetValue(chunkIndex, false);
            }

            //chunkIndexDict.Remove(chunkIndex);
            var chunkMesh = allParts[0];
            GameObject[] removeCells = null;
            //var id=chunkMesh.GetInstanceID();
            //Debug.Log("unload chunkID: "+id);
            if (chunkToCellsDict_HasItem(chunkIndex))
            {
                removeCells = chunkToCellsDict_GetValue(chunkIndex);
            }
            else
            {
                Debug.LogWarning("unload chunk id not exists");
            }

            if (chunkMesh != null)
            {
                chunkPool_Return(chunkMesh, true);
            }
            else
            {
                Debug.LogWarning("Chunk pool is empty!");
            }

            for (int i = 0; i < removeCells.Length; i++)
            {
                var cell = removeCells[i];
                if (cell != null)
                {
                    if (tempBreakCellDictionary_TryRemove(cell.GetInstanceID()))
                    {
                        permanentBreakCellDictionary_Add(ToGlobalCellIndex(i, chunkIndex), true);
                        Debug.Log("permnanet break:" + ToGlobalCellIndex(i, chunkIndex));
                    }
                    else
                    {
                        UnloadCell(cell);
                    }
                }
                else
                {
                    Debug.LogWarning("Cell pool is empty!");
                }
            }

            return true;
        }

        return false;
    }

    int[][] tempBreakCellDictionary__keys;
    bool[][] tempBreakCellDictionary__values;
    int tempBreakCellDictionary__size;
    public int tempBreakCellDictionary_Count => tempBreakCellDictionary__size;

    public int[] tempBreakCellDictionary_GenerateKeysArray()
    {
        int[] keys = new int[tempBreakCellDictionary__size];
        int index = 0;
        for (int i = 0; i < tempBreakCellDictionary__keys.Length; i++)
        {
            var hashKeys = tempBreakCellDictionary__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int tempBreakCellDictionary_bucketCount = 3;
    public void tempBreakCellDictionary_SetCapacity(int capacity)
    {
        int len = capacity / tempBreakCellDictionary_bucketCount;
        tempBreakCellDictionary__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            tempBreakCellDictionary__keys[i] = new int[tempBreakCellDictionary_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < tempBreakCellDictionary_bucketCount; i++)
        {
            tempBreakCellDictionary__keys[0][i] = int.MaxValue;
        }

        tempBreakCellDictionary__values = new bool[len][];
        for (int i = 0; i < len; i++)
        {
            tempBreakCellDictionary__values[i] = new bool[tempBreakCellDictionary_bucketCount];
        }
    }

    public bool tempBreakCellDictionary_HasItem(int key)
    {
        var index = tempBreakCellDictionary_Hash(key);
        var hashKeys = tempBreakCellDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int tempBreakCellDictionary_Hash(int key)
    {
        var len = tempBreakCellDictionary__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool tempBreakCellDictionary_Add(int key, bool value)
    {
        int index = tempBreakCellDictionary_Hash(key);
        var hashKeys = tempBreakCellDictionary__keys[index];
        if (key == int.MaxValue)
        {
            Debug.LogError("not allowed key value");
        }

        if (index == 0)
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    tempBreakCellDictionary__keys[index][i] = key;
                    tempBreakCellDictionary__values[index][i] = value;
                    tempBreakCellDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    tempBreakCellDictionary__keys[index][i] = key;
                    tempBreakCellDictionary__values[index][i] = value;
                    tempBreakCellDictionary__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyBoolDictionary Add: Dictionary is full");
        var preLen = hashKeys.Length;
        tempBreakCellDictionary_ExpandList(index);
        tempBreakCellDictionary__keys[index][preLen] = key;
        tempBreakCellDictionary__values[index][preLen] = value;
        tempBreakCellDictionary__size++;
        return true;
    }

    const int tempBreakCellDictionary_expand = 10;
    void tempBreakCellDictionary_ExpandList(int index)
    {
        var hashKeys = tempBreakCellDictionary__keys[index];
        var hashValues = tempBreakCellDictionary__values[index];
        var len = tempBreakCellDictionary__keys[index].Length + tempBreakCellDictionary_expand;
        var newKeys = new int[len];
        var newValues = new bool[len];
        for (int i = 0; i < tempBreakCellDictionary__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = tempBreakCellDictionary__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        tempBreakCellDictionary__keys[index] = newKeys;
        tempBreakCellDictionary__values[index] = newValues;
    }

    public bool tempBreakCellDictionary_AddOrSetValue(int key, bool value)
    {
        int index = tempBreakCellDictionary_Hash(key);
        var hashKeys = tempBreakCellDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tempBreakCellDictionary__keys[index][i] = key;
                    tempBreakCellDictionary__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    tempBreakCellDictionary__keys[index][i] = key;
                    tempBreakCellDictionary__values[index][i] = value;
                    tempBreakCellDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tempBreakCellDictionary__keys[index][i] = key;
                    tempBreakCellDictionary__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    tempBreakCellDictionary__keys[index][i] = key;
                    tempBreakCellDictionary__values[index][i] = value;
                    tempBreakCellDictionary__size++;
                    return true;
                }
            }
        }

        //Debug.LogError("InkEyBoolDictionary AddOrSetValue: Dictionary is full");
        //return false;
        var preLen = hashKeys.Length;
        tempBreakCellDictionary_ExpandList(index);
        tempBreakCellDictionary__keys[index][preLen] = key;
        tempBreakCellDictionary__values[index][preLen] = value;
        tempBreakCellDictionary__size++;
        return true;
    }

    public void tempBreakCellDictionary_SetValue(int key, bool value)
    {
        int index = tempBreakCellDictionary_Hash(key);
        var hashKeys = tempBreakCellDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tempBreakCellDictionary__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tempBreakCellDictionary__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public bool tempBreakCellDictionary_GetValueOrDefault(int key, bool defaultValue)
    {
        int index = tempBreakCellDictionary_Hash(key);
        var hashKeys = tempBreakCellDictionary__keys[index];
        var hashValues = tempBreakCellDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return defaultValue;
    }

    public bool tempBreakCellDictionary_GetValue(int key)
    {
        int index = tempBreakCellDictionary_Hash(key);
        var hashKeys = tempBreakCellDictionary__keys[index];
        var hashValues = tempBreakCellDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void tempBreakCellDictionary_TryRemoveBatch(int[] keys, bool[] result)
    {
        for (int i = 0; i < keys.Length; i++)
        {
            result[i] = tempBreakCellDictionary_TryRemove(keys[i]);
        }
    }

    public bool tempBreakCellDictionary_TryRemove(int key)
    {
        int index = tempBreakCellDictionary_Hash(key);
        var hashKeys = tempBreakCellDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    tempBreakCellDictionary__size--;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    tempBreakCellDictionary__size--;
                    return true;
                }
            }
        }

        return false;
    }

    public void tempBreakCellDictionary_Remove(int key)
    {
        if (!tempBreakCellDictionary_TryRemove(key))
            Debug.LogError("Key not found");
    }

    int[][] permanentBreakCellDictionary__keys;
    bool[][] permanentBreakCellDictionary__values;
    int permanentBreakCellDictionary__size;
    public int permanentBreakCellDictionary_Count => permanentBreakCellDictionary__size;

    public int[] permanentBreakCellDictionary_GenerateKeysArray()
    {
        int[] keys = new int[permanentBreakCellDictionary__size];
        int index = 0;
        for (int i = 0; i < permanentBreakCellDictionary__keys.Length; i++)
        {
            var hashKeys = permanentBreakCellDictionary__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int permanentBreakCellDictionary_bucketCount = 3;
    public void permanentBreakCellDictionary_SetCapacity(int capacity)
    {
        int len = capacity / permanentBreakCellDictionary_bucketCount;
        permanentBreakCellDictionary__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            permanentBreakCellDictionary__keys[i] = new int[permanentBreakCellDictionary_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < permanentBreakCellDictionary_bucketCount; i++)
        {
            permanentBreakCellDictionary__keys[0][i] = int.MaxValue;
        }

        permanentBreakCellDictionary__values = new bool[len][];
        for (int i = 0; i < len; i++)
        {
            permanentBreakCellDictionary__values[i] = new bool[permanentBreakCellDictionary_bucketCount];
        }
    }

    public bool permanentBreakCellDictionary_HasItem(int key)
    {
        var index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int permanentBreakCellDictionary_Hash(int key)
    {
        var len = permanentBreakCellDictionary__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool permanentBreakCellDictionary_Add(int key, bool value)
    {
        int index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        if (key == int.MaxValue)
        {
            Debug.LogError("not allowed key value");
        }

        if (index == 0)
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    permanentBreakCellDictionary__keys[index][i] = key;
                    permanentBreakCellDictionary__values[index][i] = value;
                    permanentBreakCellDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    permanentBreakCellDictionary__keys[index][i] = key;
                    permanentBreakCellDictionary__values[index][i] = value;
                    permanentBreakCellDictionary__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyBoolDictionary Add: Dictionary is full");
        var preLen = hashKeys.Length;
        permanentBreakCellDictionary_ExpandList(index);
        permanentBreakCellDictionary__keys[index][preLen] = key;
        permanentBreakCellDictionary__values[index][preLen] = value;
        permanentBreakCellDictionary__size++;
        return true;
    }

    const int permanentBreakCellDictionary_expand = 10;
    void permanentBreakCellDictionary_ExpandList(int index)
    {
        var hashKeys = permanentBreakCellDictionary__keys[index];
        var hashValues = permanentBreakCellDictionary__values[index];
        var len = permanentBreakCellDictionary__keys[index].Length + permanentBreakCellDictionary_expand;
        var newKeys = new int[len];
        var newValues = new bool[len];
        for (int i = 0; i < permanentBreakCellDictionary__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = permanentBreakCellDictionary__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        permanentBreakCellDictionary__keys[index] = newKeys;
        permanentBreakCellDictionary__values[index] = newValues;
    }

    public bool permanentBreakCellDictionary_AddOrSetValue(int key, bool value)
    {
        int index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    permanentBreakCellDictionary__keys[index][i] = key;
                    permanentBreakCellDictionary__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    permanentBreakCellDictionary__keys[index][i] = key;
                    permanentBreakCellDictionary__values[index][i] = value;
                    permanentBreakCellDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    permanentBreakCellDictionary__keys[index][i] = key;
                    permanentBreakCellDictionary__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    permanentBreakCellDictionary__keys[index][i] = key;
                    permanentBreakCellDictionary__values[index][i] = value;
                    permanentBreakCellDictionary__size++;
                    return true;
                }
            }
        }

        //Debug.LogError("InkEyBoolDictionary AddOrSetValue: Dictionary is full");
        //return false;
        var preLen = hashKeys.Length;
        permanentBreakCellDictionary_ExpandList(index);
        permanentBreakCellDictionary__keys[index][preLen] = key;
        permanentBreakCellDictionary__values[index][preLen] = value;
        permanentBreakCellDictionary__size++;
        return true;
    }

    public void permanentBreakCellDictionary_SetValue(int key, bool value)
    {
        int index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    permanentBreakCellDictionary__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    permanentBreakCellDictionary__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public bool permanentBreakCellDictionary_GetValueOrDefault(int key, bool defaultValue)
    {
        int index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        var hashValues = permanentBreakCellDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return defaultValue;
    }

    public bool permanentBreakCellDictionary_GetValue(int key)
    {
        int index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        var hashValues = permanentBreakCellDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void permanentBreakCellDictionary_TryRemoveBatch(int[] keys, bool[] result)
    {
        for (int i = 0; i < keys.Length; i++)
        {
            result[i] = permanentBreakCellDictionary_TryRemove(keys[i]);
        }
    }

    public bool permanentBreakCellDictionary_TryRemove(int key)
    {
        int index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    permanentBreakCellDictionary__size--;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    permanentBreakCellDictionary__size--;
                    return true;
                }
            }
        }

        return false;
    }

    public void permanentBreakCellDictionary_Remove(int key)
    {
        if (!permanentBreakCellDictionary_TryRemove(key))
            Debug.LogError("Key not found");
    }

    public void BreakCell(GameObject cell)
    {
        if (cell != null)
        {
            var cellIndex = cell.GetInstanceID();
            tempBreakCellDictionary_AddOrSetValue(cellIndex, true);
            UnloadCell(cell);
        }
        else
        {
            Debug.LogWarning("Cell pool is empty!");
        }
    }

    void UnloadCell(GameObject cell)
    {
        if (grassPool_IsMine(cell))
        {
            grassPool_Return(cell, true);
        }
        else if (sandPool_IsMine(cell))
        {
            sandPool_Return(cell, true);
        }
        else if (waterPool_IsMine(cell))
        {
            waterPool_Return(cell, true);
        }
        else if (rockPool_IsMine(cell))
        {
            rockPool_Return(cell, true);
        }
        else if (dirtPool_IsMine(cell))
        {
            dirtPool_Return(cell, true);
        }
        else if (desertPool_IsMine(cell))
        {
            desertPool_Return(cell, true);
        }
        else if (tundraPool_IsMine(cell))
        {
            tundraPool_Return(cell, true);
        }
        else if (darkPool_IsMine(cell))
        {
            darkPool_Return(cell, true);
        }
        else
        {
            Debug.LogWarning("Cell " + cell.name + " pool is empty! Or Make sure obj is cell type");
        }

        /*for(int i=0;i<prefabNames.Length;i++){
            if(cell.name.Contains(prefabNames[i])){
                pools[i].Return(cell,true);
                return;
            }
        }*/
        Debug.LogWarning("Cell " + cell.name + " pool is empty! Or Make sure obj is cell type");
    /*if(grassPool.IsMine(cell)){
            grassPool.Return(cell,true);
        } else if(sandPool.IsMine(cell)){
            sandPool.Return(cell,true);
        } else if(waterPool.IsMine(cell)){
            waterPool.Return(cell,true);
        } else if(rockPool.IsMine(cell)){
            rockPool.Return(cell,true);
        } else if(dirtPool.IsMine(cell)){
            dirtPool.Return(cell,true);
        } else if(desertPool.IsMine(cell)){
            desertPool.Return(cell,true);
        } else if(tundraPool.IsMine(cell)){
            tundraPool.Return(cell,true);
        } else if(darkPool.IsMine(cell)){
            darkPool.Return(cell,true);
        } else {
            Debug.LogWarning("Cell "+ cell.name+" pool is empty! Or Make sure obj is cell type");
        } */
    }

    float scale => settings_scale;

    float TileScale => settings_TileScale;

    float xValue, zValue, perlinValue, height, xTValue, zTValue, xHValue, zHValue;
    Vector3 spawnPos;
    [UdonSynced]
    float _seedX;
    [UdonSynced]
    float _seedZ;
    [UdonSynced]
    float _seedTX;
    [UdonSynced]
    float _seedTZ;
    [UdonSynced]
    float _seedHX;
    [UdonSynced]
    float _seedHZ;
    [SerializeField]
    Transform chunkParent;
    public bool meshCombiner_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        col.enabled = active;
        mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool meshCombiner_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return col.enabled && mesh.enabled;
    }

    public bool meshCombiner_chunkOperator_SetActive(GameObject obj, bool active)
    {
        MeshCollider col = obj.GetComponent<MeshCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: MeshCollider or MeshRenderer is null!");
            return false;
        }

        col.enabled = active;
        mesh.enabled = active;
        //mesh.material.SetFloat("_UpDown",0);// コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool meshCombiner_chunkOperator_IsActive(GameObject obj)
    {
        MeshCollider col = obj.GetComponent<MeshCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: MeshCollider or MeshRenderer is null!");
            return false;
        }

        return mesh.enabled;
    }

    public int meshCombiner_mapGeneratorSettings_chunkSize = 3;
    public int meshCombiner_mapGeneratorSettings_batchCount = 1000;
    public int meshCombiner_mapGeneratorSettings_chunkWidth = 100;
    public int meshCombiner_mapGeneratorSettings_chunkDepth = 100;
    public int meshCombiner_mapGeneratorSettings_fieldHeight = 3;
    public float meshCombiner_mapGeneratorSettings_scale = 0.015f;
    public float meshCombiner_mapGeneratorSettings_scaleT = 0.003f;
    public float meshCombiner_mapGeneratorSettings_scaleH = 0.003f;
    public float meshCombiner_mapGeneratorSettings_cellAnimationTime = 1f;
    public float meshCombiner_mapGeneratorSettings_TileScale = 1.5f;
    public float meshCombiner_mapGeneratorSettings_chunkLoadRange = 6f;
    public float meshCombiner_mapGeneratorSettings_chunkUnLoadRange = 12f;
    public float meshCombiner_mapGeneratorSettings_chunkDetailRange = 1f;
    public float meshCombiner_mapGeneratorSettings_generateAdditionalInterval = 5f;
    public float meshCombiner_mapGeneratorSettings_searchAdditionalInterval = 3f;
    public float meshCombiner_mapGeneratorSettings_removeBatchCount = 100;
    public float meshCombiner_mapGeneratorSettings_removeInterval = 0.1f;
    public float meshCombiner_mapGeneratorSettings_waterPercentage = 0.2f;
    public int meshCombiner_mapGeneratorSettings_operationBatchCount = 1;
    public int meshCombiner_mapGeneratorSettings_searchBatchCount = 30;
    public bool meshCombiner_mapGeneratorSettings_removeOn = true;
    public bool meshCombiner_mapGeneratorSettings_searchOn = true;
    public CombineInstance[] meshCombiner_GetCombine(int count)
    {
        if (count > meshCombiner_combineCache.Length)
        {
            Debug.LogError("CombineInstance cache is not enough " + count + " > " + meshCombiner_combineCache.Length);
            return null;
        }

        var target = meshCombiner_combineCache[count - 1];
        if (target == null)
        {
            target = new CombineInstance[count];
            meshCombiner_combineCache[count - 1] = target;
        }

        return target;
    }

    /*public  GameObject[] GetAllParts(int count){
        var target=allPartsCache[count];
        if(target==null){
            target=new GameObject[count];
            allPartsCache[count]=target;
        }
        return target;

    }*/
    CombineInstance[][] meshCombiner_combineCache;
    //GameObject[][] allPartsCache;
    void meshCombiner_Start()
    {
        var size = meshCombiner_mapGeneratorSettings_chunkSize;
        meshCombiner_combineCache = new CombineInstance[size * size * size][];
    //allPartsCache = new GameObject[10][];
    }

    public void meshCombiner_SwitchCombineMesh(bool active, GameObject[] outlines, GameObject[] cells, bool[] brokenArr)
    {
        meshCombiner_chunkOperator_SetActive(outlines[0], active);
        /*for(int i=1;i<outlines.Length;i++){
            itemOperator.SetActive(outlines[i],!active);
        }*/
        if (active)
        {
            foreach (var o in cells)
            {
                meshCombiner_itemOperator_SetActive(o, false);
            }
        }
        else
        {
            for (int i = 0; i < cells.Length; i++)
            {
                var o = cells[i];
                meshCombiner_itemOperator_SetActive(o, !brokenArr[i]);
            }
        }
    }

    public GameObject[] meshCombiner_CombineMesh(GameObject fieldParent, MeshFilter[] meshFilters, bool isInDetailRange, bool[] brokenArr)
    {
        // 親オブジェクトにMeshFilterがあるかどうか確認します。
        MeshFilter parentMeshFilter = fieldParent.GetComponent<MeshFilter>(); //CheckParentComponent<MeshFilter>(fieldParent.gameObject);
        if (parentMeshFilter == null)
        {
            Debug.LogError("Parent object has no MeshFilter !");
        }

        // 親オブジェクトにMeshRendererがあるかどうか確認します。
        //MeshRenderer parentMeshRenderer = fieldParent.GetComponent<MeshRenderer>();//(fieldParent.gameObject);
        /*if(parentMeshRenderer== null){
            Debug.LogError("Parent object has no  MeshRenderer!");
        }*/
        // 子オブジェクトのMeshFilterへの参照を配列として保持します。
        // ただし、親オブジェクトのメッシュもGetComponentsInChildrenに含まれるので除外します。
        //MeshFilter[] meshFilters = fieldParent.GetComponentsInChildren<MeshFilter>();
        /*Material combinedMat = meshFilters[0].GetComponent<MeshRenderer>().material;
        int combineCount=0;
        foreach(var mesh in meshFilters){
            if(mesh.GetComponent<MeshRenderer>().material.name==combinedMat.name){
                combineCount++;
            }
        }*/
        int combineCount = meshFilters.Length;
        // 結合するメッシュの配列を作成します。
        CombineInstance[] combine = meshCombiner_GetCombine(combineCount); //new CombineInstance[combineCount];//
        //GameObject[] allParts = new GameObject[meshFilters.Length-combineCount+1];
        GameObject[] allParts = new GameObject[1];
        allParts[0] = fieldParent;
        int restIndex = 1;
        // 結合するメッシュの情報をCombineInstanceに追加していきます。
        int index = 0;
        for (int i = 0; i < meshFilters.Length; i++)
        {
            var mesh = meshFilters[i];
            //TODO: destory block dictionaryを参照する
            combine[index].mesh = mesh.sharedMesh;
            combine[index].transform = mesh.transform.localToWorldMatrix;
            if (isInDetailRange)
            {
                if (brokenArr[i])
                    meshCombiner_itemOperator_SetActive(mesh.gameObject, false); // try to spawnでtrueは保証されている
            }
            else
            {
                meshCombiner_itemOperator_SetActive(mesh.gameObject, false); // try to spawnでtrueは保証されている
            }

            index++;
        /*if(mesh.GetComponent<MeshRenderer>().material.name==combinedMat.name){
                combine[index].mesh = mesh.sharedMesh;
                combine[index].transform = mesh.transform.localToWorldMatrix;
                itemOperator.SetActive(mesh.gameObject,false);
                index++;
            } else {
                //allParts[restIndex]=mesh.gameObject;
                restIndex++;
                itemOperator.SetActive(mesh.gameObject,true);
                Debug.LogWarning("MeshCombiner: MeshRenderer material is not same as parent material. ");
            }*/
        }

        // 結合したメッシュをセットします。
        parentMeshFilter.mesh = new Mesh();
        parentMeshFilter.mesh.CombineMeshes(combine);
        // 結合したメッシュにマテリアルをセットします。
        //parentMeshRenderer.material = combinedMat;
        MeshCollider meshCol = fieldParent.GetComponent<MeshCollider>();
        meshCol.sharedMesh = parentMeshFilter.mesh;
        meshCombiner_chunkOperator_SetActive(fieldParent, !isInDetailRange);
        return allParts;
    }

    MeshFilter[] meshFilters;
    int[][] chunkToCellsDict__keys;
    GameObject[][][] chunkToCellsDict__values;
    int chunkToCellsDict__size;
    public int chunkToCellsDict_Count => chunkToCellsDict__size;

    const int chunkToCellsDict_bucketCount = 3;
    public void chunkToCellsDict_SetCapacity(int capacity)
    {
        int len = capacity / chunkToCellsDict_bucketCount;
        chunkToCellsDict__keys = new int[len][];
        for (int i = 0; i < chunkToCellsDict__keys.Length; i++)
        {
            chunkToCellsDict__keys[i] = new int[chunkToCellsDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < chunkToCellsDict_bucketCount; i++)
        {
            chunkToCellsDict__keys[0][i] = int.MaxValue;
        }

        chunkToCellsDict__values = new GameObject[len][][];
        for (int i = 0; i < chunkToCellsDict__values.Length; i++)
        {
            chunkToCellsDict__values[i] = new GameObject[chunkToCellsDict_bucketCount][];
        }
    }

    public bool chunkToCellsDict_HasItem(int key)
    {
        var index = chunkToCellsDict_Hash(key);
        var hashKeys = chunkToCellsDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int chunkToCellsDict_Hash(int key)
    {
        var len = chunkToCellsDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public int[] chunkToCellsDict_GenerateKeysArray()
    {
        int[] keys = new int[chunkToCellsDict__size];
        int index = 0;
        for (int i = 0; i < chunkToCellsDict__keys.Length; i++)
        {
            var hashKeys = chunkToCellsDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    public bool chunkToCellsDict_Add(int key, GameObject[] value)
    {
        int index = chunkToCellsDict_Hash(key);
        var hashKeys = chunkToCellsDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkToCellsDict__keys[index][i] = key;
                    chunkToCellsDict__values[index][i] = value;
                    chunkToCellsDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    chunkToCellsDict__keys[index][i] = key;
                    chunkToCellsDict__values[index][i] = value;
                    chunkToCellsDict__size++;
                    return true;
                }
            }
        }

        chunkToCellsDict_ExpandList(index);
        var preLen = hashKeys.Length;
        Debug.LogWarning("InkEyGameObjectArrDictionary Add: Dictionary is full");
        chunkToCellsDict__keys[index][preLen] = key;
        chunkToCellsDict__values[index][preLen] = value;
        chunkToCellsDict__size++;
        return true;
    }

    const int chunkToCellsDict_expand = 10;
    void chunkToCellsDict_ExpandList(int index)
    {
        var hashKeys = chunkToCellsDict__keys[index];
        var hashValues = chunkToCellsDict__values[index];
        var len = chunkToCellsDict__keys[index].Length + chunkToCellsDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len][];
        for (int i = 0; i < chunkToCellsDict__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = chunkToCellsDict__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        chunkToCellsDict__keys[index] = newKeys;
        chunkToCellsDict__values[index] = newValues;
    }

    public void chunkToCellsDict_AddOrSetValue(int key, GameObject[] value)
    {
        int index = chunkToCellsDict_Hash(key);
        var hashKeys = chunkToCellsDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkToCellsDict__keys[index][i] = key;
                    chunkToCellsDict__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkToCellsDict__keys[index][i] = key;
                    chunkToCellsDict__values[index][i] = value;
                    chunkToCellsDict__size++;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkToCellsDict__keys[index][i] = key;
                    chunkToCellsDict__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == default)
                {
                    chunkToCellsDict__keys[index][i] = key;
                    chunkToCellsDict__values[index][i] = value;
                    chunkToCellsDict__size++;
                    return;
                }
            }
        }

        var preLen = hashKeys.Length;
        chunkToCellsDict_ExpandList(index);
        Debug.LogWarning("InkEyGameObjectArrDictionary AddOrSet: Dictionary is full");
        chunkToCellsDict__keys[index][preLen] = key;
        chunkToCellsDict__values[index][preLen] = value;
        chunkToCellsDict__size++;
    }

    public void chunkToCellsDict_SetValue(int key, GameObject[] value)
    {
        int index = chunkToCellsDict_Hash(key);
        var hashKeys = chunkToCellsDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkToCellsDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkToCellsDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject[] chunkToCellsDict_GetValue(int key)
    {
        int index = chunkToCellsDict_Hash(key);
        var hashKeys = chunkToCellsDict__keys[index];
        var hashValues = chunkToCellsDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void chunkToCellsDict_Remove(int key)
    {
        int index = chunkToCellsDict_Hash(key);
        var hashKeys = chunkToCellsDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    chunkToCellsDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    chunkToCellsDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    GameObject chunkPool_prefab;
    int[][] chunkPool_idToObjDict__keys;
    GameObject[][] chunkPool_idToObjDict__values;
    int chunkPool_idToObjDict__size;
    public int chunkPool_idToObjDict_Count => chunkPool_idToObjDict__size;

    public int[] chunkPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[chunkPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < chunkPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = chunkPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    [SerializeField]
    int chunkPool_idToObjDict_bucketCount = 4;
    public int chunkPool_idToObjDict_KeyLength => chunkPool_idToObjDict__keys.Length;

    public void chunkPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / chunkPool_idToObjDict_bucketCount;
        chunkPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            chunkPool_idToObjDict__keys[i] = new int[chunkPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < chunkPool_idToObjDict_bucketCount; i++)
        {
            chunkPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        chunkPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            chunkPool_idToObjDict__values[i] = new GameObject[chunkPool_idToObjDict_bucketCount];
        }
    }

    public bool chunkPool_idToObjDict_HasItem(int key)
    {
        var index = chunkPool_idToObjDict_Hash(key);
        var hashKeys = chunkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int chunkPool_idToObjDict_Hash(int key)
    {
        var len = chunkPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool chunkPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = chunkPool_idToObjDict_Hash(key);
        var hashKeys = chunkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkPool_idToObjDict__keys[index][i] = key;
                    chunkPool_idToObjDict__values[index][i] = value;
                    chunkPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    chunkPool_idToObjDict__keys[index][i] = key;
                    chunkPool_idToObjDict__values[index][i] = value;
                    chunkPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full " + index);
        var preLen = hashKeys.Length;
        chunkPool_idToObjDict_ExpandList(index);
        chunkPool_idToObjDict__keys[index][preLen] = key;
        chunkPool_idToObjDict__values[index][preLen] = value;
        chunkPool_idToObjDict__size++;
        return true;
    }

    const int chunkPool_idToObjDict_expand = 10;
    void chunkPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = chunkPool_idToObjDict__keys[index];
        var hashValues = chunkPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + chunkPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        chunkPool_idToObjDict__keys[index] = newKeys;
        chunkPool_idToObjDict__values[index] = newValues;
    }

    public bool chunkPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = chunkPool_idToObjDict_Hash(key);
        var hashKeys = chunkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkPool_idToObjDict__keys[index][i] = key;
                    chunkPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkPool_idToObjDict__keys[index][i] = key;
                    chunkPool_idToObjDict__values[index][i] = value;
                    chunkPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkPool_idToObjDict__keys[index][i] = key;
                    chunkPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    chunkPool_idToObjDict__keys[index][i] = key;
                    chunkPool_idToObjDict__values[index][i] = value;
                    chunkPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        chunkPool_idToObjDict_ExpandList(index);
        chunkPool_idToObjDict__keys[index][preLen] = key;
        chunkPool_idToObjDict__values[index][preLen] = value;
        chunkPool_idToObjDict__size++;
        return true;
    }

    public void chunkPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = chunkPool_idToObjDict_Hash(key);
        var hashKeys = chunkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject chunkPool_idToObjDict_GetValue(int key)
    {
        int index = chunkPool_idToObjDict_Hash(key);
        var hashKeys = chunkPool_idToObjDict__keys[index];
        var hashValues = chunkPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void chunkPool_idToObjDict_Remove(int key)
    {
        int index = chunkPool_idToObjDict_Hash(key);
        var hashKeys = chunkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    chunkPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    chunkPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int chunkPool_InitGenerateCount = 0;
    [SerializeField]
    int chunkPool_Capacity = 100000;
    public bool chunkPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        MeshCollider col = obj.GetComponent<MeshCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: MeshCollider or MeshRenderer is null!");
            return false;
        }

        col.enabled = active;
        mesh.enabled = active;
        //mesh.material.SetFloat("_UpDown",0);// コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool chunkPool_itemOperator_IsActive(GameObject obj)
    {
        MeshCollider col = obj.GetComponent<MeshCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: MeshCollider or MeshRenderer is null!");
            return false;
        }

        return mesh.enabled;
    }

    int chunkPool_poolSize;
    private int[] chunkPool_notActiveObjQueue__array;
    private int chunkPool_notActiveObjQueue__head; // First valid element in the queue.
    private int chunkPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int chunkPool_notActiveObjQueue__size; // Number of elements.
    private int chunkPool_notActiveObjQueue__version;
    private const int chunkPool_notActiveObjQueue_MinimumGrow = 100000;
    public int chunkPool_notActiveObjQueue_Count => chunkPool_notActiveObjQueue__size;
    public int chunkPool_notActiveObjQueue_Version => chunkPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int chunkPool_notActiveObjQueue_GetCount() => chunkPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int chunkPool_notActiveObjQueue_GetVersion() => chunkPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void chunkPool_notActiveObjQueue_Clear()
    {
        if (chunkPool_notActiveObjQueue__size != 0)
        {
            if (chunkPool_notActiveObjQueue__head < chunkPool_notActiveObjQueue__tail)
            {
                Array.Clear(chunkPool_notActiveObjQueue__array, chunkPool_notActiveObjQueue__head, chunkPool_notActiveObjQueue__size);
            }
            else
            {
                Array.Clear(chunkPool_notActiveObjQueue__array, chunkPool_notActiveObjQueue__head, chunkPool_notActiveObjQueue__array.Length - chunkPool_notActiveObjQueue__head);
                Array.Clear(chunkPool_notActiveObjQueue__array, 0, chunkPool_notActiveObjQueue__tail);
            }

            chunkPool_notActiveObjQueue__size = 0;
        }

        chunkPool_notActiveObjQueue__head = 0;
        chunkPool_notActiveObjQueue__tail = 0;
        chunkPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void chunkPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < chunkPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = chunkPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = chunkPool_notActiveObjQueue__array.Length - chunkPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(chunkPool_notActiveObjQueue__array, chunkPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(chunkPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void chunkPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (chunkPool_notActiveObjQueue__array == null)
        {
            chunkPool_notActiveObjQueue_SetCapacity(chunkPool_notActiveObjQueue_MinimumGrow);
        }
        else if (chunkPool_notActiveObjQueue__size == chunkPool_notActiveObjQueue__array.Length)
        {
            chunkPool_notActiveObjQueue_SetCapacity(chunkPool_notActiveObjQueue__array.Length + chunkPool_notActiveObjQueue_MinimumGrow);
        }

        chunkPool_notActiveObjQueue__array[chunkPool_notActiveObjQueue__tail] = obj;
        chunkPool_notActiveObjQueue__tail = (chunkPool_notActiveObjQueue__tail + 1) % chunkPool_notActiveObjQueue__array.Length;
        chunkPool_notActiveObjQueue__size++;
        chunkPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int chunkPool_notActiveObjQueue_Dequeue()
    {
        if (chunkPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = chunkPool_notActiveObjQueue__array[chunkPool_notActiveObjQueue__head];
        chunkPool_notActiveObjQueue__array[chunkPool_notActiveObjQueue__head] = int.MaxValue;
        chunkPool_notActiveObjQueue__head = (chunkPool_notActiveObjQueue__head + 1) % chunkPool_notActiveObjQueue__array.Length;
        chunkPool_notActiveObjQueue__size--;
        chunkPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int chunkPool_notActiveObjQueue_Peek()
    {
        if (chunkPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return chunkPool_notActiveObjQueue__array[chunkPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] chunkPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[chunkPool_notActiveObjQueue__size];
        if (chunkPool_notActiveObjQueue__size == 0)
        {
        }
        else if (chunkPool_notActiveObjQueue__head < chunkPool_notActiveObjQueue__tail)
        {
            Array.Copy(chunkPool_notActiveObjQueue__array, chunkPool_notActiveObjQueue__head, arr, 0, chunkPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = chunkPool_notActiveObjQueue__array.Length - chunkPool_notActiveObjQueue__head;
            Array.Copy(chunkPool_notActiveObjQueue__array, chunkPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(chunkPool_notActiveObjQueue__array, 0, arr, toHead, chunkPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void chunkPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (chunkPool_notActiveObjQueue__size == 0)
        {
        }
        else if (chunkPool_notActiveObjQueue__head < chunkPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(chunkPool_notActiveObjQueue__array, chunkPool_notActiveObjQueue__head, newArray, 0, chunkPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = chunkPool_notActiveObjQueue__array.Length - chunkPool_notActiveObjQueue__head;
            Array.Copy(chunkPool_notActiveObjQueue__array, chunkPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(chunkPool_notActiveObjQueue__array, 0, newArray, toHead, chunkPool_notActiveObjQueue__tail);
        }

        chunkPool_notActiveObjQueue__array = newArray;
        chunkPool_notActiveObjQueue__head = 0;
        chunkPool_notActiveObjQueue__tail = chunkPool_notActiveObjQueue__size == capacity ? 0 : chunkPool_notActiveObjQueue__size;
        chunkPool_notActiveObjQueue__version++;
    }

    [SerializeField]
    Transform chunkPool_parent;
    void chunkPool_Start()
    {
        chunkPool_poolSize = chunkPool_InitGenerateCount;
        chunkPool_idToObjDict_SetCapacity(chunkPool_Capacity);
        chunkPool_notActiveObjQueue_SetCapacity(chunkPool_Capacity);
        for (int i = 0; i < chunkPool_InitGenerateCount; i++)
        {
            int id;
            GameObject instance;
            do
            {
                instance = GameObject.Instantiate(chunkPool_prefab);
                if (instance == null)
                {
                    Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
                }

                id = instance.GetInstanceID().GetHashCode();
            }
            while (!chunkPool_idToObjDict_Add(id, instance));
            chunkPool_itemOperator_SetActive(instance, false);
            chunkPool_notActiveObjQueue_Enqueue(id);
        }
    }

    public bool chunkPool_PeekIsInstantiated()
    {
        return chunkPool_isInstantiated;
    }

    bool chunkPool_isInstantiated = false;
    public void chunkPool_Batch(PoolOperatorType[] opes, GameObject[] objs)
    {
        int i = 0;
        foreach (var ope in opes)
        {
            switch (ope)
            {
                case PoolOperatorType.TryToSpawn:
                    chunkPool_TryToSpawn();
                    break;
                case PoolOperatorType.Return:
                    chunkPool_Return(objs[i]);
                    i++;
                    break;
                case PoolOperatorType.Store:
                    chunkPool_Store();
                    break;
                case PoolOperatorType.Clear:
                    chunkPool_Clear();
                    break;
            }
        }
    }

    public void chunkPool_Store(Transform p = null)
    {
        if (chunkPool_idToObjDict_Count > chunkPool_idToObjDict_KeyLength)
            return;
        chunkPool_isInstantiated = true;
        GameObject instance;
        int id;
        do
        {
            instance = GameObject.Instantiate(chunkPool_prefab);
            if (instance == null)
            {
                Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
            }

            id = instance.GetInstanceID().GetHashCode();
            chunkPool_itemOperator_SetActive(instance, false);
        }
        while (!chunkPool_idToObjDict_Add(id, instance));
        chunkPool_notActiveObjQueue_Enqueue(id);
    }

    // falseで出してmeshcombinerで切り替える
    public GameObject chunkPool_TryToSpawn(Transform p = null)
    {
        int id;
        chunkPool_isInstantiated = true;
        if (chunkPool_notActiveObjQueue_Count > 0)
        {
            chunkPool_isInstantiated = false;
            id = chunkPool_notActiveObjQueue_Dequeue();
            if (chunkPool_idToObjDict_HasItem(id))
            {
                var obj = chunkPool_idToObjDict_GetValue(id);
                chunkPool_itemOperator_SetActive(obj, true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        GameObject instance;
        do
        {
            instance = GameObject.Instantiate(chunkPool_prefab);
            if (instance == null)
            {
                Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
            }

            id = instance.GetInstanceID().GetHashCode();
        }
        while (!chunkPool_idToObjDict_Add(id, instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return instance;
    }

    public void chunkPool_Return(GameObject obj, bool force = false)
    {
        if (obj == null)
            return;
        int id = obj.GetInstanceID().GetHashCode();
        if (!chunkPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        chunkPool_itemOperator_SetActive(obj, false);
        chunkPool_notActiveObjQueue_Enqueue(id);
    }

    public bool chunkPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(chunkPool_prefab.name);
    }

    public string chunkPool_prefabName => chunkPool_prefab.name;

    public void chunkPool_Clear()
    {
        chunkPool_notActiveObjQueue_Clear();
        foreach (var obj in chunkPool_idToObjDict_GenerateKeysArray())
        {
            chunkPool_itemOperator_SetActive(chunkPool_idToObjDict_GetValue(obj), false);
            chunkPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    GameObject[] generatingCells;
    int chunkXIndex, chunkYIndex, chunkZIndex;
    GameObject chunkObj;
    int chunkID;
    public const string IndestructibleTag = "Ignore Raycast";
    public const string CellTag = "Cell";
    int ToLocalCellIndex(int xIndex, int yIndex, int zIndex)
    {
        return (xIndex * chunkSize + zIndex) * chunkSize + yIndex;
    }

    int ToGlobalCellIndex(int localCellIndex, int chunkIndex)
    {
        return localCellIndex + chunkIndex * chunkSize * chunkSize * chunkSize;
    }

    GenerateChunkMode GenerateChunk()
    {
        int chunkIndex = ToChunkIndex(xStartChunkIndex, zStartChunkIndex);
        if (loadedChunkIndexDict_GetValueOrDefault(chunkIndex, false))
            return GenerateChunkMode.Pass;
        /*if(removedChunkIndexDict.HasItem(chunkIndex)){
            if(chunkObj!=null){
                chunkPool.Return(chunkObj,true);
                foreach(var cell in generatingCells){
                    if(cell==null)break;
                    UnloadCell(cell);
                }
                chunkObj=null;
            }
            return GenerateChunkMode.Pass;
        }*/
        bool isInit = false;
        if (chunkXIndex == 0 && chunkZIndex == 0 && chunkYIndex == 0)
        {
            //Debug.Log("GenerateChunk: "+chunkIndex);
            isInit = true;
            if (chunkObj != null)
                Debug.LogError("chunkObj is not null");
            chunkObj = chunkPool_TryToSpawn();
            //chunkID=chunkObj.GetInstanceID();
            //Debug.Log("generate chunkID: "+chunkIndex);
            if (chunkToCellsDict_HasItem(chunkIndex))
            {
                generatingCells = chunkToCellsDict_GetValue(chunkIndex);
            }
            else
            {
                generatingCells = new GameObject[chunkSize * chunkSize * chunkSize];
            }
        }

        //GameObject.Instantiate(chunkPrefab,Vector3.zero,Quaternion.identity,chunkParent);
        //MeshFilter[] meshFilters = new MeshFilter[chunkSize*chunkSize];
        var resCell = GenerateCell(xStartChunkIndex * chunkSize + chunkXIndex, zStartChunkIndex * chunkSize + chunkZIndex, chunkYIndex - chunkSize + 1, null);
        if (chunkYIndex < indestructibleLine)
        {
            resCell.layer = LayerMask.NameToLayer(IndestructibleTag);
        }
        else
        {
            resCell.layer = LayerMask.NameToLayer(CellTag);
        }

        meshFilters[ToLocalCellIndex(chunkXIndex, chunkYIndex, chunkZIndex)] = resCell.GetComponent<MeshFilter>();
        generatingCells[ToLocalCellIndex(chunkXIndex, chunkYIndex, chunkZIndex)] = resCell;
        chunkYIndex++;
        if (chunkYIndex == chunkSize)
        {
            chunkYIndex = 0;
            chunkZIndex++;
            //resCell.name+=IndestructibleTag; // 底は破壊不可能にする
            if (chunkZIndex == chunkSize)
            {
                chunkZIndex = 0;
                chunkXIndex++;
                if (chunkXIndex == chunkSize)
                {
                    chunkToCellsDict_AddOrSetValue(chunkIndex, generatingCells);
                    bool isInDetailRange = IsInDetailRange(GetPlayerPosition(), xStartChunkIndex, zStartChunkIndex);
                    if (isInDetailRange)
                    {
                        for (int i = 0; i < generatingCells.Length; i++)
                        {
                            brokenArr[i] = false;
                            if (permanentBreakCellDictionary_HasItem(ToGlobalCellIndex(i, chunkIndex)))
                            {
                                brokenArr[i] = true;
                            }
                        }
                    }

                    var allParts = meshCombiner_CombineMesh(chunkObj, meshFilters, isInDetailRange, brokenArr);
                    chunkObj = null;
                    outlineDict_AddOrSetValue(chunkIndex, allParts);
                    loadedChunkIndexDict_AddOrSetValue(chunkIndex, true);
                    return GenerateChunkMode.Complete;
                }
            }
        }

        if (isInit)
            return GenerateChunkMode.Init;
        return GenerateChunkMode.Generating;
    }

    int indestructibleLine = 2;
    public GameObject GenerateCell(int xIndex, int zIndex, int yIndex, Transform parent)
    {
        xValue = xIndex * scale + _seedX;
        zValue = zIndex * scale + _seedZ;
        perlinValue = fbm(xValue, zValue, 4, 0.4f); //Mathf.PerlinNoise(xValue, zValue);
        height = fieldHeight * (perlinValue - waterPercentage);
        height = Mathf.Round(height);
        spawnPos = new Vector3(xIndex, height + yIndex, zIndex) * TileScale;
        //spawnPos = new Vector3((xIndex)*TileScale,height,zIndex*TileScale);
        biomeCell = GenerateBiome(xIndex, zIndex, parent);
        if (biomeCell != null)
        {
            biomeCell.transform.localPosition = spawnPos;
        }
        else
        {
            Debug.LogWarning("Chunk pool is empty!");
        }

        return biomeCell;
    }

    GameObject biomeCell;
    float scaleT => settings_scaleT;

    float scaleH => settings_scaleH;

    bool isInstantiated = false;
    GameObject GenerateBiome(int xIndex, int zIndex, Transform parent)
    {
        xTValue = xIndex * scaleT + _seedTX;
        zTValue = zIndex * scaleT + _seedTZ;
        xHValue = xIndex * scaleH + _seedHX;
        zHValue = zIndex * scaleH + _seedHZ;
        float temperature = Mathf.PerlinNoise(xTValue, zTValue);
        float humidity = Mathf.PerlinNoise(xHValue, zHValue);
        //humidity *= Mathf.Sqrt(1-(1-temperature)*(1-temperature));
        Biome biomeType;
        if (height <= 0)
            biomeType = Biome.Water;
        else
        {
            int tempIndex = Math.Min((int)(temperature * 5), 4);
            int humIndex = Math.Min((int)(humidity * 5), 4);
            biomeType = biomeMap[tempIndex][humIndex];
        }

        var cell = BiomeTryToSpawn(biomeType);
        isInstantiated = BiomePeekIsInstantiated(biomeType);
        return cell;
    }

    float fbmTotal, fbmFrequency, fbmAmplitude, fbmMaxValue;
    int fbmIndex;
    float fbm(float x, float y, int octaves, float persistence)
    {
        fbmTotal = 0;
        fbmFrequency = 1;
        fbmAmplitude = 1;
        fbmMaxValue = 0; // Used for normalizing result to 0.0 - 1.0
        for (fbmIndex = 0; fbmIndex < octaves; fbmIndex++)
        {
            fbmTotal += Mathf.PerlinNoise(x * fbmFrequency, y * fbmFrequency) * fbmAmplitude;
            fbmMaxValue += fbmAmplitude;
            fbmAmplitude *= persistence;
            fbmFrequency *= 2;
        }

        return fbmTotal / fbmMaxValue;
    }
}