using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System;
using UdonSharp;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;
using VRC.SDKBase;
using VRC.Udon;
using BuildSoft.UdonSharp.Collection;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using System.Runtime.InteropServices;
using System;
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using UdonObjectPool;

[UdonBehaviourSyncMode(BehaviourSyncMode.Manual)]
public class UnrolledMapGenerator : IMapGenerator
{
    [SerializeField]
    GameObject grassPool_prefab;
    int[][] grassPool_idToObjDict__keys;
    GameObject[][] grassPool_idToObjDict__values;
    int grassPool_idToObjDict__size;
    public int grassPool_idToObjDict_Count => grassPool_idToObjDict__size;

    public int[] grassPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[grassPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < grassPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = grassPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int grassPool_idToObjDict_bucketCount = 2;
    public int grassPool_idToObjDict_KeyLength => grassPool_idToObjDict__keys.Length;

    public void grassPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / grassPool_idToObjDict_bucketCount;
        grassPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            grassPool_idToObjDict__keys[i] = new int[grassPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < grassPool_idToObjDict_bucketCount; i++)
        {
            grassPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        grassPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            grassPool_idToObjDict__values[i] = new GameObject[grassPool_idToObjDict_bucketCount];
        }
    }

    public bool grassPool_idToObjDict_HasItem(int key)
    {
        var index = grassPool_idToObjDict_Hash(key);
        var hashKeys = grassPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int grassPool_idToObjDict_Hash(int key)
    {
        var len = grassPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool grassPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = grassPool_idToObjDict_Hash(key);
        var hashKeys = grassPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    grassPool_idToObjDict__keys[index][i] = key;
                    grassPool_idToObjDict__values[index][i] = value;
                    grassPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    grassPool_idToObjDict__keys[index][i] = key;
                    grassPool_idToObjDict__values[index][i] = value;
                    grassPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        grassPool_idToObjDict_ExpandList(index);
        grassPool_idToObjDict__keys[index][preLen] = key;
        grassPool_idToObjDict__values[index][preLen] = value;
        grassPool_idToObjDict__size++;
        return true;
    }

    const int grassPool_idToObjDict_expand = 10;
    void grassPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = grassPool_idToObjDict__keys[index];
        var hashValues = grassPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + grassPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        grassPool_idToObjDict__keys[index] = newKeys;
        grassPool_idToObjDict__values[index] = newValues;
    }

    public bool grassPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = grassPool_idToObjDict_Hash(key);
        var hashKeys = grassPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    grassPool_idToObjDict__keys[index][i] = key;
                    grassPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    grassPool_idToObjDict__keys[index][i] = key;
                    grassPool_idToObjDict__values[index][i] = value;
                    grassPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    grassPool_idToObjDict__keys[index][i] = key;
                    grassPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    grassPool_idToObjDict__keys[index][i] = key;
                    grassPool_idToObjDict__values[index][i] = value;
                    grassPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        grassPool_idToObjDict_ExpandList(index);
        grassPool_idToObjDict__keys[index][preLen] = key;
        grassPool_idToObjDict__values[index][preLen] = value;
        grassPool_idToObjDict__size++;
        return true;
    }

    public void grassPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = grassPool_idToObjDict_Hash(key);
        var hashKeys = grassPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    grassPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    grassPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject grassPool_idToObjDict_GetValue(int key)
    {
        int index = grassPool_idToObjDict_Hash(key);
        var hashKeys = grassPool_idToObjDict__keys[index];
        var hashValues = grassPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject grassPool_idToObjDict_TryGetValue(int key)
    {
        int index = grassPool_idToObjDict_Hash(key);
        var hashKeys = grassPool_idToObjDict__keys[index];
        var hashValues = grassPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void grassPool_idToObjDict_Remove(int key)
    {
        int index = grassPool_idToObjDict_Hash(key);
        var hashKeys = grassPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    grassPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    grassPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int grassPool_Capacity = 100000;
    public bool grassPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        grassPool_itemOperator_col.enabled = active;
        grassPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    [SerializeField]
    int grassPool_itemOperator_capacity = 300000;
    void grassPool_itemOperator_Start()
    {
        grassPool_itemOperator_idToColDict_SetCapacity(grassPool_itemOperator_capacity);
        grassPool_itemOperator_idToMeshDict_SetCapacity(grassPool_itemOperator_capacity);
    }

    int[][] grassPool_itemOperator_idToColDict__keys;
    BoxCollider[][] grassPool_itemOperator_idToColDict__values;
    int grassPool_itemOperator_idToColDict__size;
    public int grassPool_itemOperator_idToColDict_Count => grassPool_itemOperator_idToColDict__size;

    public int[] grassPool_itemOperator_idToColDict_GenerateKeysArray()
    {
        int[] keys = new int[grassPool_itemOperator_idToColDict__size];
        int index = 0;
        for (int i = 0; i < grassPool_itemOperator_idToColDict__keys.Length; i++)
        {
            var hashKeys = grassPool_itemOperator_idToColDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int grassPool_itemOperator_idToColDict_bucketCount = 2;
    public int grassPool_itemOperator_idToColDict_KeyLength => grassPool_itemOperator_idToColDict__keys.Length;

    public void grassPool_itemOperator_idToColDict_SetCapacity(int capacity)
    {
        int len = grassPool_itemOperator_capacity / grassPool_itemOperator_idToColDict_bucketCount;
        grassPool_itemOperator_idToColDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            grassPool_itemOperator_idToColDict__keys[i] = new int[grassPool_itemOperator_idToColDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < grassPool_itemOperator_idToColDict_bucketCount; i++)
        {
            grassPool_itemOperator_idToColDict__keys[0][i] = int.MaxValue;
        }

        grassPool_itemOperator_idToColDict__values = new BoxCollider[len][];
        for (int i = 0; i < len; i++)
        {
            grassPool_itemOperator_idToColDict__values[i] = new BoxCollider[grassPool_itemOperator_idToColDict_bucketCount];
        }
    }

    public bool grassPool_itemOperator_idToColDict_HasItem(int key)
    {
        var index = grassPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = grassPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int grassPool_itemOperator_idToColDict_Hash(int key)
    {
        var len = grassPool_itemOperator_idToColDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool grassPool_itemOperator_idToColDict_Add(int key, BoxCollider value)
    {
        int index = grassPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = grassPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBoxColliderDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    grassPool_itemOperator_idToColDict__keys[index][i] = key;
                    grassPool_itemOperator_idToColDict__values[index][i] = value;
                    grassPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBoxColliderDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    grassPool_itemOperator_idToColDict__keys[index][i] = key;
                    grassPool_itemOperator_idToColDict__values[index][i] = value;
                    grassPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoxColliderDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        grassPool_itemOperator_idToColDict_ExpandList(index);
        grassPool_itemOperator_idToColDict__keys[index][preLen] = key;
        grassPool_itemOperator_idToColDict__values[index][preLen] = value;
        grassPool_itemOperator_idToColDict__size++;
        return true;
    }

    const int grassPool_itemOperator_idToColDict_expand = 10;
    void grassPool_itemOperator_idToColDict_ExpandList(int index)
    {
        var hashKeys = grassPool_itemOperator_idToColDict__keys[index];
        var hashValues = grassPool_itemOperator_idToColDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + grassPool_itemOperator_idToColDict_expand;
        var newKeys = new int[len];
        var newValues = new BoxCollider[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        grassPool_itemOperator_idToColDict__keys[index] = newKeys;
        grassPool_itemOperator_idToColDict__values[index] = newValues;
    }

    public bool grassPool_itemOperator_idToColDict_AddOrSetValue(int key, BoxCollider value)
    {
        int index = grassPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = grassPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    grassPool_itemOperator_idToColDict__keys[index][i] = key;
                    grassPool_itemOperator_idToColDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    grassPool_itemOperator_idToColDict__keys[index][i] = key;
                    grassPool_itemOperator_idToColDict__values[index][i] = value;
                    grassPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    grassPool_itemOperator_idToColDict__keys[index][i] = key;
                    grassPool_itemOperator_idToColDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    grassPool_itemOperator_idToColDict__keys[index][i] = key;
                    grassPool_itemOperator_idToColDict__values[index][i] = value;
                    grassPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoxColliderDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        grassPool_itemOperator_idToColDict_ExpandList(index);
        grassPool_itemOperator_idToColDict__keys[index][preLen] = key;
        grassPool_itemOperator_idToColDict__values[index][preLen] = value;
        grassPool_itemOperator_idToColDict__size++;
        return true;
    }

    public void grassPool_itemOperator_idToColDict_SetValue(int key, BoxCollider value)
    {
        int index = grassPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = grassPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    grassPool_itemOperator_idToColDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    grassPool_itemOperator_idToColDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public BoxCollider grassPool_itemOperator_idToColDict_GetValue(int key)
    {
        int index = grassPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = grassPool_itemOperator_idToColDict__keys[index];
        var hashValues = grassPool_itemOperator_idToColDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void grassPool_itemOperator_idToColDict_Remove(int key)
    {
        int index = grassPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = grassPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    grassPool_itemOperator_idToColDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    grassPool_itemOperator_idToColDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    int[][] grassPool_itemOperator_idToMeshDict__keys;
    MeshRenderer[][] grassPool_itemOperator_idToMeshDict__values;
    int grassPool_itemOperator_idToMeshDict__size;
    public int grassPool_itemOperator_idToMeshDict_Count => grassPool_itemOperator_idToMeshDict__size;

    public int[] grassPool_itemOperator_idToMeshDict_GenerateKeysArray()
    {
        int[] keys = new int[grassPool_itemOperator_idToMeshDict__size];
        int index = 0;
        for (int i = 0; i < grassPool_itemOperator_idToMeshDict__keys.Length; i++)
        {
            var hashKeys = grassPool_itemOperator_idToMeshDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int grassPool_itemOperator_idToMeshDict_bucketCount = 2;
    public int grassPool_itemOperator_idToMeshDict_KeyLength => grassPool_itemOperator_idToMeshDict__keys.Length;

    public void grassPool_itemOperator_idToMeshDict_SetCapacity(int capacity)
    {
        int len = grassPool_itemOperator_capacity / grassPool_itemOperator_idToMeshDict_bucketCount;
        grassPool_itemOperator_idToMeshDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            grassPool_itemOperator_idToMeshDict__keys[i] = new int[grassPool_itemOperator_idToMeshDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < grassPool_itemOperator_idToMeshDict_bucketCount; i++)
        {
            grassPool_itemOperator_idToMeshDict__keys[0][i] = int.MaxValue;
        }

        grassPool_itemOperator_idToMeshDict__values = new MeshRenderer[len][];
        for (int i = 0; i < len; i++)
        {
            grassPool_itemOperator_idToMeshDict__values[i] = new MeshRenderer[grassPool_itemOperator_idToMeshDict_bucketCount];
        }
    }

    public bool grassPool_itemOperator_idToMeshDict_HasItem(int key)
    {
        var index = grassPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = grassPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int grassPool_itemOperator_idToMeshDict_Hash(int key)
    {
        var len = grassPool_itemOperator_idToMeshDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool grassPool_itemOperator_idToMeshDict_Add(int key, MeshRenderer value)
    {
        int index = grassPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = grassPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyMeshRendererDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    grassPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    grassPool_itemOperator_idToMeshDict__values[index][i] = value;
                    grassPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyMeshRendererDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    grassPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    grassPool_itemOperator_idToMeshDict__values[index][i] = value;
                    grassPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyMeshRendererDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        grassPool_itemOperator_idToMeshDict_ExpandList(index);
        grassPool_itemOperator_idToMeshDict__keys[index][preLen] = key;
        grassPool_itemOperator_idToMeshDict__values[index][preLen] = value;
        grassPool_itemOperator_idToMeshDict__size++;
        return true;
    }

    const int grassPool_itemOperator_idToMeshDict_expand = 10;
    void grassPool_itemOperator_idToMeshDict_ExpandList(int index)
    {
        var hashKeys = grassPool_itemOperator_idToMeshDict__keys[index];
        var hashValues = grassPool_itemOperator_idToMeshDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + grassPool_itemOperator_idToMeshDict_expand;
        var newKeys = new int[len];
        var newValues = new MeshRenderer[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        grassPool_itemOperator_idToMeshDict__keys[index] = newKeys;
        grassPool_itemOperator_idToMeshDict__values[index] = newValues;
    }

    public bool grassPool_itemOperator_idToMeshDict_AddOrSetValue(int key, MeshRenderer value)
    {
        int index = grassPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = grassPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    grassPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    grassPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    grassPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    grassPool_itemOperator_idToMeshDict__values[index][i] = value;
                    grassPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    grassPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    grassPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    grassPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    grassPool_itemOperator_idToMeshDict__values[index][i] = value;
                    grassPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyMeshRendererDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        grassPool_itemOperator_idToMeshDict_ExpandList(index);
        grassPool_itemOperator_idToMeshDict__keys[index][preLen] = key;
        grassPool_itemOperator_idToMeshDict__values[index][preLen] = value;
        grassPool_itemOperator_idToMeshDict__size++;
        return true;
    }

    public void grassPool_itemOperator_idToMeshDict_SetValue(int key, MeshRenderer value)
    {
        int index = grassPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = grassPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    grassPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    grassPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public MeshRenderer grassPool_itemOperator_idToMeshDict_GetValue(int key)
    {
        int index = grassPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = grassPool_itemOperator_idToMeshDict__keys[index];
        var hashValues = grassPool_itemOperator_idToMeshDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void grassPool_itemOperator_idToMeshDict_Remove(int key)
    {
        int index = grassPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = grassPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    grassPool_itemOperator_idToMeshDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    grassPool_itemOperator_idToMeshDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    BoxCollider grassPool_itemOperator_col;
    MeshRenderer grassPool_itemOperator_mesh;
    public bool grassPool_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        if (grassPool_itemOperator_idToColDict_HasItem(instanceID))
        {
            grassPool_itemOperator_col = grassPool_itemOperator_idToColDict_GetValue(instanceID);
        }
        else
        {
            grassPool_itemOperator_col = obj.GetComponent<BoxCollider>();
            grassPool_itemOperator_idToColDict_Add(instanceID, grassPool_itemOperator_col);
        }

        if (grassPool_itemOperator_idToMeshDict_HasItem(instanceID))
        {
            grassPool_itemOperator_mesh = grassPool_itemOperator_idToMeshDict_GetValue(instanceID);
        }
        else
        {
            grassPool_itemOperator_mesh = obj.GetComponent<MeshRenderer>();
            grassPool_itemOperator_idToMeshDict_Add(instanceID, grassPool_itemOperator_mesh);
        }

        grassPool_itemOperator_col.enabled = active;
        grassPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool grassPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (grassPool_itemOperator_col == null || grassPool_itemOperator_mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return grassPool_itemOperator_col.enabled && grassPool_itemOperator_mesh.enabled;
    }

    int grassPool_poolSize;
    private int[] grassPool_notActiveObjQueue__array;
    private int grassPool_notActiveObjQueue__head; // First valid element in the queue.
    private int grassPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int grassPool_notActiveObjQueue__size; // Number of elements.
    private int grassPool_notActiveObjQueue__version;
    private const int grassPool_notActiveObjQueue_MinimumGrow = 100000;
    public int grassPool_notActiveObjQueue_Count => grassPool_notActiveObjQueue__size;
    public int grassPool_notActiveObjQueue_Version => grassPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int grassPool_notActiveObjQueue_GetCount() => grassPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int grassPool_notActiveObjQueue_GetVersion() => grassPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void grassPool_notActiveObjQueue_Clear()
    {
        if (grassPool_notActiveObjQueue__size != 0)
        {
            if (grassPool_notActiveObjQueue__head < grassPool_notActiveObjQueue__tail)
            {
                Array.Clear(grassPool_notActiveObjQueue__array, grassPool_notActiveObjQueue__head, grassPool_notActiveObjQueue__size);
            }
            else
            {
                Array.Clear(grassPool_notActiveObjQueue__array, grassPool_notActiveObjQueue__head, grassPool_notActiveObjQueue__array.Length - grassPool_notActiveObjQueue__head);
                Array.Clear(grassPool_notActiveObjQueue__array, 0, grassPool_notActiveObjQueue__tail);
            }

            grassPool_notActiveObjQueue__size = 0;
        }

        grassPool_notActiveObjQueue__head = 0;
        grassPool_notActiveObjQueue__tail = 0;
        grassPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void grassPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < grassPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = grassPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = grassPool_notActiveObjQueue__array.Length - grassPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(grassPool_notActiveObjQueue__array, grassPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(grassPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void grassPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (grassPool_notActiveObjQueue__array == null)
        {
            grassPool_notActiveObjQueue_SetCapacity(grassPool_notActiveObjQueue_MinimumGrow);
        }
        else if (grassPool_notActiveObjQueue__size == grassPool_notActiveObjQueue__array.Length)
        {
            grassPool_notActiveObjQueue_SetCapacity(grassPool_notActiveObjQueue__array.Length + grassPool_notActiveObjQueue_MinimumGrow);
        }

        grassPool_notActiveObjQueue__array[grassPool_notActiveObjQueue__tail] = obj;
        grassPool_notActiveObjQueue__tail = (grassPool_notActiveObjQueue__tail + 1) % grassPool_notActiveObjQueue__array.Length;
        grassPool_notActiveObjQueue__size++;
        grassPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int grassPool_notActiveObjQueue_Dequeue()
    {
        if (grassPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = grassPool_notActiveObjQueue__array[grassPool_notActiveObjQueue__head];
        grassPool_notActiveObjQueue__array[grassPool_notActiveObjQueue__head] = int.MaxValue;
        grassPool_notActiveObjQueue__head = (grassPool_notActiveObjQueue__head + 1) % grassPool_notActiveObjQueue__array.Length;
        grassPool_notActiveObjQueue__size--;
        grassPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int grassPool_notActiveObjQueue_Peek()
    {
        if (grassPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return grassPool_notActiveObjQueue__array[grassPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] grassPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[grassPool_notActiveObjQueue__size];
        if (grassPool_notActiveObjQueue__size == 0)
        {
        }
        else if (grassPool_notActiveObjQueue__head < grassPool_notActiveObjQueue__tail)
        {
            Array.Copy(grassPool_notActiveObjQueue__array, grassPool_notActiveObjQueue__head, arr, 0, grassPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = grassPool_notActiveObjQueue__array.Length - grassPool_notActiveObjQueue__head;
            Array.Copy(grassPool_notActiveObjQueue__array, grassPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(grassPool_notActiveObjQueue__array, 0, arr, toHead, grassPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void grassPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (grassPool_notActiveObjQueue__size == 0)
        {
        }
        else if (grassPool_notActiveObjQueue__head < grassPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(grassPool_notActiveObjQueue__array, grassPool_notActiveObjQueue__head, newArray, 0, grassPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = grassPool_notActiveObjQueue__array.Length - grassPool_notActiveObjQueue__head;
            Array.Copy(grassPool_notActiveObjQueue__array, grassPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(grassPool_notActiveObjQueue__array, 0, newArray, toHead, grassPool_notActiveObjQueue__tail);
        }

        grassPool_notActiveObjQueue__array = newArray;
        grassPool_notActiveObjQueue__head = 0;
        grassPool_notActiveObjQueue__tail = grassPool_notActiveObjQueue__size == capacity ? 0 : grassPool_notActiveObjQueue__size;
        grassPool_notActiveObjQueue__version++;
    }

    [SerializeField]
    Transform grassPool_parent;
    void grassPool_Start()
    {
        grassPool_itemOperator_Start();
        grassPool_prefabName = grassPool_prefab.name;
        grassPool_idToObjDict_SetCapacity(grassPool_Capacity);
        grassPool_notActiveObjQueue_SetCapacity(grassPool_Capacity);
    }

    public bool grassPool_PeekIsInstantiated()
    {
        return grassPool_isInstantiated;
    }

    bool grassPool_isInstantiated = false;
    public void grassPool_Store(Transform p = null)
    {
        if (grassPool_idToObjDict_Count > grassPool_idToObjDict_KeyLength)
            return;
        grassPool_isInstantiated = true;
        GameObject instance;
        int id;
        grassPool_instance = GameObject.Instantiate(grassPool_prefab);
        //gc alloc debug only
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        //id = GetInstanceID(instance);/*instance.GetInstanceID();*///.GetHashCode();
        id = grassPool_instance.GetInstanceID();
        grassPool_itemOperator_SetActive(grassPool_instance, id, false);
        grassPool_idToObjDict_Add(id, grassPool_instance);
        grassPool_notActiveObjQueue_Enqueue(id);
    }

    string grassPool_prefabName;
    GameObject grassPool_instance;
    // falseで出してmeshcombinerで切り替える
    int grassPool_uniqueId = 0;
    public GameObject grassPool_TryToSpawn()
    {
        int id;
        grassPool_isInstantiated = true;
        if (grassPool_notActiveObjQueue_Count > 0)
        {
            grassPool_isInstantiated = false;
            id = grassPool_notActiveObjQueue_Dequeue();
            if (grassPool_idToObjDict_HasItem(id))
            {
                var obj = grassPool_idToObjDict_GetValue(id);
                //itemOperator.SetActive(obj,id,true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        grassPool_instance = GameObject.Instantiate(grassPool_prefab);
        //gc alloc
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        id = grassPool_instance.GetInstanceID();
        grassPool_idToObjDict_Add(id, grassPool_instance); // gc alloc
        //itemOperator.SetActive(instance,id,true);
        //}while(!idToObjDict.Add(id,instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return grassPool_instance;
    }

    public GameObject grassPool_TryToSpawn(int id)
    {
        grassPool_isInstantiated = false;
        if (grassPool_idToObjDict_HasItem(id))
        {
            var obj = grassPool_idToObjDict_GetValue(id);
            grassPool_itemOperator_SetActive(obj, id, false);
            return obj;
        }
        else
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return null;
        }
    }

    public void grassPool_Return(GameObject obj, bool force = false, bool enqueue = true)
    {
        // gc alloc debug only
        //if(obj==null)return; // gc alloc debug only
        int id = obj.GetInstanceID(); //obj.GetInstanceID();
        if (!grassPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        grassPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            grassPool_notActiveObjQueue_Enqueue(id);
    }

    public void grassPool_Return(GameObject obj, int id, bool force = false, bool enqueue = true)
    {
        //if(obj==null)return; // gc alloc debug only
        if (!grassPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        grassPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            grassPool_notActiveObjQueue_Enqueue(id);
    }

    public bool grassPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(grassPool_prefab.name);
    }

    public void grassPool_Clear()
    {
        grassPool_notActiveObjQueue_Clear();
        foreach (var obj in grassPool_idToObjDict_GenerateKeysArray())
        {
            grassPool_itemOperator_SetActive(grassPool_idToObjDict_GetValue(obj), false);
            grassPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject tundraPool_prefab;
    int[][] tundraPool_idToObjDict__keys;
    GameObject[][] tundraPool_idToObjDict__values;
    int tundraPool_idToObjDict__size;
    public int tundraPool_idToObjDict_Count => tundraPool_idToObjDict__size;

    public int[] tundraPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[tundraPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < tundraPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = tundraPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int tundraPool_idToObjDict_bucketCount = 2;
    public int tundraPool_idToObjDict_KeyLength => tundraPool_idToObjDict__keys.Length;

    public void tundraPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / tundraPool_idToObjDict_bucketCount;
        tundraPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            tundraPool_idToObjDict__keys[i] = new int[tundraPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < tundraPool_idToObjDict_bucketCount; i++)
        {
            tundraPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        tundraPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            tundraPool_idToObjDict__values[i] = new GameObject[tundraPool_idToObjDict_bucketCount];
        }
    }

    public bool tundraPool_idToObjDict_HasItem(int key)
    {
        var index = tundraPool_idToObjDict_Hash(key);
        var hashKeys = tundraPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int tundraPool_idToObjDict_Hash(int key)
    {
        var len = tundraPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool tundraPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = tundraPool_idToObjDict_Hash(key);
        var hashKeys = tundraPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    tundraPool_idToObjDict__keys[index][i] = key;
                    tundraPool_idToObjDict__values[index][i] = value;
                    tundraPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    tundraPool_idToObjDict__keys[index][i] = key;
                    tundraPool_idToObjDict__values[index][i] = value;
                    tundraPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        tundraPool_idToObjDict_ExpandList(index);
        tundraPool_idToObjDict__keys[index][preLen] = key;
        tundraPool_idToObjDict__values[index][preLen] = value;
        tundraPool_idToObjDict__size++;
        return true;
    }

    const int tundraPool_idToObjDict_expand = 10;
    void tundraPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = tundraPool_idToObjDict__keys[index];
        var hashValues = tundraPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + tundraPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        tundraPool_idToObjDict__keys[index] = newKeys;
        tundraPool_idToObjDict__values[index] = newValues;
    }

    public bool tundraPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = tundraPool_idToObjDict_Hash(key);
        var hashKeys = tundraPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tundraPool_idToObjDict__keys[index][i] = key;
                    tundraPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    tundraPool_idToObjDict__keys[index][i] = key;
                    tundraPool_idToObjDict__values[index][i] = value;
                    tundraPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tundraPool_idToObjDict__keys[index][i] = key;
                    tundraPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    tundraPool_idToObjDict__keys[index][i] = key;
                    tundraPool_idToObjDict__values[index][i] = value;
                    tundraPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        tundraPool_idToObjDict_ExpandList(index);
        tundraPool_idToObjDict__keys[index][preLen] = key;
        tundraPool_idToObjDict__values[index][preLen] = value;
        tundraPool_idToObjDict__size++;
        return true;
    }

    public void tundraPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = tundraPool_idToObjDict_Hash(key);
        var hashKeys = tundraPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tundraPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tundraPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject tundraPool_idToObjDict_GetValue(int key)
    {
        int index = tundraPool_idToObjDict_Hash(key);
        var hashKeys = tundraPool_idToObjDict__keys[index];
        var hashValues = tundraPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject tundraPool_idToObjDict_TryGetValue(int key)
    {
        int index = tundraPool_idToObjDict_Hash(key);
        var hashKeys = tundraPool_idToObjDict__keys[index];
        var hashValues = tundraPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void tundraPool_idToObjDict_Remove(int key)
    {
        int index = tundraPool_idToObjDict_Hash(key);
        var hashKeys = tundraPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    tundraPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    tundraPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int tundraPool_Capacity = 100000;
    public bool tundraPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        tundraPool_itemOperator_col.enabled = active;
        tundraPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    [SerializeField]
    int tundraPool_itemOperator_capacity = 300000;
    void tundraPool_itemOperator_Start()
    {
        tundraPool_itemOperator_idToColDict_SetCapacity(tundraPool_itemOperator_capacity);
        tundraPool_itemOperator_idToMeshDict_SetCapacity(tundraPool_itemOperator_capacity);
    }

    int[][] tundraPool_itemOperator_idToColDict__keys;
    BoxCollider[][] tundraPool_itemOperator_idToColDict__values;
    int tundraPool_itemOperator_idToColDict__size;
    public int tundraPool_itemOperator_idToColDict_Count => tundraPool_itemOperator_idToColDict__size;

    public int[] tundraPool_itemOperator_idToColDict_GenerateKeysArray()
    {
        int[] keys = new int[tundraPool_itemOperator_idToColDict__size];
        int index = 0;
        for (int i = 0; i < tundraPool_itemOperator_idToColDict__keys.Length; i++)
        {
            var hashKeys = tundraPool_itemOperator_idToColDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int tundraPool_itemOperator_idToColDict_bucketCount = 2;
    public int tundraPool_itemOperator_idToColDict_KeyLength => tundraPool_itemOperator_idToColDict__keys.Length;

    public void tundraPool_itemOperator_idToColDict_SetCapacity(int capacity)
    {
        int len = tundraPool_itemOperator_capacity / tundraPool_itemOperator_idToColDict_bucketCount;
        tundraPool_itemOperator_idToColDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            tundraPool_itemOperator_idToColDict__keys[i] = new int[tundraPool_itemOperator_idToColDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < tundraPool_itemOperator_idToColDict_bucketCount; i++)
        {
            tundraPool_itemOperator_idToColDict__keys[0][i] = int.MaxValue;
        }

        tundraPool_itemOperator_idToColDict__values = new BoxCollider[len][];
        for (int i = 0; i < len; i++)
        {
            tundraPool_itemOperator_idToColDict__values[i] = new BoxCollider[tundraPool_itemOperator_idToColDict_bucketCount];
        }
    }

    public bool tundraPool_itemOperator_idToColDict_HasItem(int key)
    {
        var index = tundraPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = tundraPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int tundraPool_itemOperator_idToColDict_Hash(int key)
    {
        var len = tundraPool_itemOperator_idToColDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool tundraPool_itemOperator_idToColDict_Add(int key, BoxCollider value)
    {
        int index = tundraPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = tundraPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBoxColliderDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    tundraPool_itemOperator_idToColDict__keys[index][i] = key;
                    tundraPool_itemOperator_idToColDict__values[index][i] = value;
                    tundraPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBoxColliderDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    tundraPool_itemOperator_idToColDict__keys[index][i] = key;
                    tundraPool_itemOperator_idToColDict__values[index][i] = value;
                    tundraPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoxColliderDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        tundraPool_itemOperator_idToColDict_ExpandList(index);
        tundraPool_itemOperator_idToColDict__keys[index][preLen] = key;
        tundraPool_itemOperator_idToColDict__values[index][preLen] = value;
        tundraPool_itemOperator_idToColDict__size++;
        return true;
    }

    const int tundraPool_itemOperator_idToColDict_expand = 10;
    void tundraPool_itemOperator_idToColDict_ExpandList(int index)
    {
        var hashKeys = tundraPool_itemOperator_idToColDict__keys[index];
        var hashValues = tundraPool_itemOperator_idToColDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + tundraPool_itemOperator_idToColDict_expand;
        var newKeys = new int[len];
        var newValues = new BoxCollider[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        tundraPool_itemOperator_idToColDict__keys[index] = newKeys;
        tundraPool_itemOperator_idToColDict__values[index] = newValues;
    }

    public bool tundraPool_itemOperator_idToColDict_AddOrSetValue(int key, BoxCollider value)
    {
        int index = tundraPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = tundraPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tundraPool_itemOperator_idToColDict__keys[index][i] = key;
                    tundraPool_itemOperator_idToColDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    tundraPool_itemOperator_idToColDict__keys[index][i] = key;
                    tundraPool_itemOperator_idToColDict__values[index][i] = value;
                    tundraPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tundraPool_itemOperator_idToColDict__keys[index][i] = key;
                    tundraPool_itemOperator_idToColDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    tundraPool_itemOperator_idToColDict__keys[index][i] = key;
                    tundraPool_itemOperator_idToColDict__values[index][i] = value;
                    tundraPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoxColliderDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        tundraPool_itemOperator_idToColDict_ExpandList(index);
        tundraPool_itemOperator_idToColDict__keys[index][preLen] = key;
        tundraPool_itemOperator_idToColDict__values[index][preLen] = value;
        tundraPool_itemOperator_idToColDict__size++;
        return true;
    }

    public void tundraPool_itemOperator_idToColDict_SetValue(int key, BoxCollider value)
    {
        int index = tundraPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = tundraPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tundraPool_itemOperator_idToColDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tundraPool_itemOperator_idToColDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public BoxCollider tundraPool_itemOperator_idToColDict_GetValue(int key)
    {
        int index = tundraPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = tundraPool_itemOperator_idToColDict__keys[index];
        var hashValues = tundraPool_itemOperator_idToColDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void tundraPool_itemOperator_idToColDict_Remove(int key)
    {
        int index = tundraPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = tundraPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    tundraPool_itemOperator_idToColDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    tundraPool_itemOperator_idToColDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    int[][] tundraPool_itemOperator_idToMeshDict__keys;
    MeshRenderer[][] tundraPool_itemOperator_idToMeshDict__values;
    int tundraPool_itemOperator_idToMeshDict__size;
    public int tundraPool_itemOperator_idToMeshDict_Count => tundraPool_itemOperator_idToMeshDict__size;

    public int[] tundraPool_itemOperator_idToMeshDict_GenerateKeysArray()
    {
        int[] keys = new int[tundraPool_itemOperator_idToMeshDict__size];
        int index = 0;
        for (int i = 0; i < tundraPool_itemOperator_idToMeshDict__keys.Length; i++)
        {
            var hashKeys = tundraPool_itemOperator_idToMeshDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int tundraPool_itemOperator_idToMeshDict_bucketCount = 2;
    public int tundraPool_itemOperator_idToMeshDict_KeyLength => tundraPool_itemOperator_idToMeshDict__keys.Length;

    public void tundraPool_itemOperator_idToMeshDict_SetCapacity(int capacity)
    {
        int len = tundraPool_itemOperator_capacity / tundraPool_itemOperator_idToMeshDict_bucketCount;
        tundraPool_itemOperator_idToMeshDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            tundraPool_itemOperator_idToMeshDict__keys[i] = new int[tundraPool_itemOperator_idToMeshDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < tundraPool_itemOperator_idToMeshDict_bucketCount; i++)
        {
            tundraPool_itemOperator_idToMeshDict__keys[0][i] = int.MaxValue;
        }

        tundraPool_itemOperator_idToMeshDict__values = new MeshRenderer[len][];
        for (int i = 0; i < len; i++)
        {
            tundraPool_itemOperator_idToMeshDict__values[i] = new MeshRenderer[tundraPool_itemOperator_idToMeshDict_bucketCount];
        }
    }

    public bool tundraPool_itemOperator_idToMeshDict_HasItem(int key)
    {
        var index = tundraPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = tundraPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int tundraPool_itemOperator_idToMeshDict_Hash(int key)
    {
        var len = tundraPool_itemOperator_idToMeshDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool tundraPool_itemOperator_idToMeshDict_Add(int key, MeshRenderer value)
    {
        int index = tundraPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = tundraPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyMeshRendererDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    tundraPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    tundraPool_itemOperator_idToMeshDict__values[index][i] = value;
                    tundraPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyMeshRendererDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    tundraPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    tundraPool_itemOperator_idToMeshDict__values[index][i] = value;
                    tundraPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyMeshRendererDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        tundraPool_itemOperator_idToMeshDict_ExpandList(index);
        tundraPool_itemOperator_idToMeshDict__keys[index][preLen] = key;
        tundraPool_itemOperator_idToMeshDict__values[index][preLen] = value;
        tundraPool_itemOperator_idToMeshDict__size++;
        return true;
    }

    const int tundraPool_itemOperator_idToMeshDict_expand = 10;
    void tundraPool_itemOperator_idToMeshDict_ExpandList(int index)
    {
        var hashKeys = tundraPool_itemOperator_idToMeshDict__keys[index];
        var hashValues = tundraPool_itemOperator_idToMeshDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + tundraPool_itemOperator_idToMeshDict_expand;
        var newKeys = new int[len];
        var newValues = new MeshRenderer[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        tundraPool_itemOperator_idToMeshDict__keys[index] = newKeys;
        tundraPool_itemOperator_idToMeshDict__values[index] = newValues;
    }

    public bool tundraPool_itemOperator_idToMeshDict_AddOrSetValue(int key, MeshRenderer value)
    {
        int index = tundraPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = tundraPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tundraPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    tundraPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    tundraPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    tundraPool_itemOperator_idToMeshDict__values[index][i] = value;
                    tundraPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tundraPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    tundraPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    tundraPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    tundraPool_itemOperator_idToMeshDict__values[index][i] = value;
                    tundraPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyMeshRendererDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        tundraPool_itemOperator_idToMeshDict_ExpandList(index);
        tundraPool_itemOperator_idToMeshDict__keys[index][preLen] = key;
        tundraPool_itemOperator_idToMeshDict__values[index][preLen] = value;
        tundraPool_itemOperator_idToMeshDict__size++;
        return true;
    }

    public void tundraPool_itemOperator_idToMeshDict_SetValue(int key, MeshRenderer value)
    {
        int index = tundraPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = tundraPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tundraPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    tundraPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public MeshRenderer tundraPool_itemOperator_idToMeshDict_GetValue(int key)
    {
        int index = tundraPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = tundraPool_itemOperator_idToMeshDict__keys[index];
        var hashValues = tundraPool_itemOperator_idToMeshDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void tundraPool_itemOperator_idToMeshDict_Remove(int key)
    {
        int index = tundraPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = tundraPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    tundraPool_itemOperator_idToMeshDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    tundraPool_itemOperator_idToMeshDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    BoxCollider tundraPool_itemOperator_col;
    MeshRenderer tundraPool_itemOperator_mesh;
    public bool tundraPool_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        if (tundraPool_itemOperator_idToColDict_HasItem(instanceID))
        {
            tundraPool_itemOperator_col = tundraPool_itemOperator_idToColDict_GetValue(instanceID);
        }
        else
        {
            tundraPool_itemOperator_col = obj.GetComponent<BoxCollider>();
            tundraPool_itemOperator_idToColDict_Add(instanceID, tundraPool_itemOperator_col);
        }

        if (tundraPool_itemOperator_idToMeshDict_HasItem(instanceID))
        {
            tundraPool_itemOperator_mesh = tundraPool_itemOperator_idToMeshDict_GetValue(instanceID);
        }
        else
        {
            tundraPool_itemOperator_mesh = obj.GetComponent<MeshRenderer>();
            tundraPool_itemOperator_idToMeshDict_Add(instanceID, tundraPool_itemOperator_mesh);
        }

        tundraPool_itemOperator_col.enabled = active;
        tundraPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool tundraPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (tundraPool_itemOperator_col == null || tundraPool_itemOperator_mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return tundraPool_itemOperator_col.enabled && tundraPool_itemOperator_mesh.enabled;
    }

    int tundraPool_poolSize;
    private int[] tundraPool_notActiveObjQueue__array;
    private int tundraPool_notActiveObjQueue__head; // First valid element in the queue.
    private int tundraPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int tundraPool_notActiveObjQueue__size; // Number of elements.
    private int tundraPool_notActiveObjQueue__version;
    private const int tundraPool_notActiveObjQueue_MinimumGrow = 100000;
    public int tundraPool_notActiveObjQueue_Count => tundraPool_notActiveObjQueue__size;
    public int tundraPool_notActiveObjQueue_Version => tundraPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int tundraPool_notActiveObjQueue_GetCount() => tundraPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int tundraPool_notActiveObjQueue_GetVersion() => tundraPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void tundraPool_notActiveObjQueue_Clear()
    {
        if (tundraPool_notActiveObjQueue__size != 0)
        {
            if (tundraPool_notActiveObjQueue__head < tundraPool_notActiveObjQueue__tail)
            {
                Array.Clear(tundraPool_notActiveObjQueue__array, tundraPool_notActiveObjQueue__head, tundraPool_notActiveObjQueue__size);
            }
            else
            {
                Array.Clear(tundraPool_notActiveObjQueue__array, tundraPool_notActiveObjQueue__head, tundraPool_notActiveObjQueue__array.Length - tundraPool_notActiveObjQueue__head);
                Array.Clear(tundraPool_notActiveObjQueue__array, 0, tundraPool_notActiveObjQueue__tail);
            }

            tundraPool_notActiveObjQueue__size = 0;
        }

        tundraPool_notActiveObjQueue__head = 0;
        tundraPool_notActiveObjQueue__tail = 0;
        tundraPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void tundraPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < tundraPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = tundraPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = tundraPool_notActiveObjQueue__array.Length - tundraPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(tundraPool_notActiveObjQueue__array, tundraPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(tundraPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void tundraPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (tundraPool_notActiveObjQueue__array == null)
        {
            tundraPool_notActiveObjQueue_SetCapacity(tundraPool_notActiveObjQueue_MinimumGrow);
        }
        else if (tundraPool_notActiveObjQueue__size == tundraPool_notActiveObjQueue__array.Length)
        {
            tundraPool_notActiveObjQueue_SetCapacity(tundraPool_notActiveObjQueue__array.Length + tundraPool_notActiveObjQueue_MinimumGrow);
        }

        tundraPool_notActiveObjQueue__array[tundraPool_notActiveObjQueue__tail] = obj;
        tundraPool_notActiveObjQueue__tail = (tundraPool_notActiveObjQueue__tail + 1) % tundraPool_notActiveObjQueue__array.Length;
        tundraPool_notActiveObjQueue__size++;
        tundraPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int tundraPool_notActiveObjQueue_Dequeue()
    {
        if (tundraPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = tundraPool_notActiveObjQueue__array[tundraPool_notActiveObjQueue__head];
        tundraPool_notActiveObjQueue__array[tundraPool_notActiveObjQueue__head] = int.MaxValue;
        tundraPool_notActiveObjQueue__head = (tundraPool_notActiveObjQueue__head + 1) % tundraPool_notActiveObjQueue__array.Length;
        tundraPool_notActiveObjQueue__size--;
        tundraPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int tundraPool_notActiveObjQueue_Peek()
    {
        if (tundraPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return tundraPool_notActiveObjQueue__array[tundraPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] tundraPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[tundraPool_notActiveObjQueue__size];
        if (tundraPool_notActiveObjQueue__size == 0)
        {
        }
        else if (tundraPool_notActiveObjQueue__head < tundraPool_notActiveObjQueue__tail)
        {
            Array.Copy(tundraPool_notActiveObjQueue__array, tundraPool_notActiveObjQueue__head, arr, 0, tundraPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = tundraPool_notActiveObjQueue__array.Length - tundraPool_notActiveObjQueue__head;
            Array.Copy(tundraPool_notActiveObjQueue__array, tundraPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(tundraPool_notActiveObjQueue__array, 0, arr, toHead, tundraPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void tundraPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (tundraPool_notActiveObjQueue__size == 0)
        {
        }
        else if (tundraPool_notActiveObjQueue__head < tundraPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(tundraPool_notActiveObjQueue__array, tundraPool_notActiveObjQueue__head, newArray, 0, tundraPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = tundraPool_notActiveObjQueue__array.Length - tundraPool_notActiveObjQueue__head;
            Array.Copy(tundraPool_notActiveObjQueue__array, tundraPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(tundraPool_notActiveObjQueue__array, 0, newArray, toHead, tundraPool_notActiveObjQueue__tail);
        }

        tundraPool_notActiveObjQueue__array = newArray;
        tundraPool_notActiveObjQueue__head = 0;
        tundraPool_notActiveObjQueue__tail = tundraPool_notActiveObjQueue__size == capacity ? 0 : tundraPool_notActiveObjQueue__size;
        tundraPool_notActiveObjQueue__version++;
    }

    [SerializeField]
    Transform tundraPool_parent;
    void tundraPool_Start()
    {
        tundraPool_itemOperator_Start();
        tundraPool_prefabName = tundraPool_prefab.name;
        tundraPool_idToObjDict_SetCapacity(tundraPool_Capacity);
        tundraPool_notActiveObjQueue_SetCapacity(tundraPool_Capacity);
    }

    public bool tundraPool_PeekIsInstantiated()
    {
        return tundraPool_isInstantiated;
    }

    bool tundraPool_isInstantiated = false;
    public void tundraPool_Store(Transform p = null)
    {
        if (tundraPool_idToObjDict_Count > tundraPool_idToObjDict_KeyLength)
            return;
        tundraPool_isInstantiated = true;
        GameObject instance;
        int id;
        tundraPool_instance = GameObject.Instantiate(tundraPool_prefab);
        //gc alloc debug only
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        //id = GetInstanceID(instance);/*instance.GetInstanceID();*///.GetHashCode();
        id = tundraPool_instance.GetInstanceID();
        tundraPool_itemOperator_SetActive(tundraPool_instance, id, false);
        tundraPool_idToObjDict_Add(id, tundraPool_instance);
        tundraPool_notActiveObjQueue_Enqueue(id);
    }

    string tundraPool_prefabName;
    GameObject tundraPool_instance;
    // falseで出してmeshcombinerで切り替える
    int tundraPool_uniqueId = 0;
    public GameObject tundraPool_TryToSpawn()
    {
        int id;
        tundraPool_isInstantiated = true;
        if (tundraPool_notActiveObjQueue_Count > 0)
        {
            tundraPool_isInstantiated = false;
            id = tundraPool_notActiveObjQueue_Dequeue();
            if (tundraPool_idToObjDict_HasItem(id))
            {
                var obj = tundraPool_idToObjDict_GetValue(id);
                //itemOperator.SetActive(obj,id,true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        tundraPool_instance = GameObject.Instantiate(tundraPool_prefab);
        //gc alloc
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        id = tundraPool_instance.GetInstanceID();
        tundraPool_idToObjDict_Add(id, tundraPool_instance); // gc alloc
        //itemOperator.SetActive(instance,id,true);
        //}while(!idToObjDict.Add(id,instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return tundraPool_instance;
    }

    public GameObject tundraPool_TryToSpawn(int id)
    {
        tundraPool_isInstantiated = false;
        if (tundraPool_idToObjDict_HasItem(id))
        {
            var obj = tundraPool_idToObjDict_GetValue(id);
            tundraPool_itemOperator_SetActive(obj, id, false);
            return obj;
        }
        else
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return null;
        }
    }

    public void tundraPool_Return(GameObject obj, bool force = false, bool enqueue = true)
    {
        // gc alloc debug only
        //if(obj==null)return; // gc alloc debug only
        int id = obj.GetInstanceID(); //obj.GetInstanceID();
        if (!tundraPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        tundraPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            tundraPool_notActiveObjQueue_Enqueue(id);
    }

    public void tundraPool_Return(GameObject obj, int id, bool force = false, bool enqueue = true)
    {
        //if(obj==null)return; // gc alloc debug only
        if (!tundraPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        tundraPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            tundraPool_notActiveObjQueue_Enqueue(id);
    }

    public bool tundraPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(tundraPool_prefab.name);
    }

    public void tundraPool_Clear()
    {
        tundraPool_notActiveObjQueue_Clear();
        foreach (var obj in tundraPool_idToObjDict_GenerateKeysArray())
        {
            tundraPool_itemOperator_SetActive(tundraPool_idToObjDict_GetValue(obj), false);
            tundraPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject desertPool_prefab;
    int[][] desertPool_idToObjDict__keys;
    GameObject[][] desertPool_idToObjDict__values;
    int desertPool_idToObjDict__size;
    public int desertPool_idToObjDict_Count => desertPool_idToObjDict__size;

    public int[] desertPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[desertPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < desertPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = desertPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int desertPool_idToObjDict_bucketCount = 2;
    public int desertPool_idToObjDict_KeyLength => desertPool_idToObjDict__keys.Length;

    public void desertPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / desertPool_idToObjDict_bucketCount;
        desertPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            desertPool_idToObjDict__keys[i] = new int[desertPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < desertPool_idToObjDict_bucketCount; i++)
        {
            desertPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        desertPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            desertPool_idToObjDict__values[i] = new GameObject[desertPool_idToObjDict_bucketCount];
        }
    }

    public bool desertPool_idToObjDict_HasItem(int key)
    {
        var index = desertPool_idToObjDict_Hash(key);
        var hashKeys = desertPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int desertPool_idToObjDict_Hash(int key)
    {
        var len = desertPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool desertPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = desertPool_idToObjDict_Hash(key);
        var hashKeys = desertPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    desertPool_idToObjDict__keys[index][i] = key;
                    desertPool_idToObjDict__values[index][i] = value;
                    desertPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    desertPool_idToObjDict__keys[index][i] = key;
                    desertPool_idToObjDict__values[index][i] = value;
                    desertPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        desertPool_idToObjDict_ExpandList(index);
        desertPool_idToObjDict__keys[index][preLen] = key;
        desertPool_idToObjDict__values[index][preLen] = value;
        desertPool_idToObjDict__size++;
        return true;
    }

    const int desertPool_idToObjDict_expand = 10;
    void desertPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = desertPool_idToObjDict__keys[index];
        var hashValues = desertPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + desertPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        desertPool_idToObjDict__keys[index] = newKeys;
        desertPool_idToObjDict__values[index] = newValues;
    }

    public bool desertPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = desertPool_idToObjDict_Hash(key);
        var hashKeys = desertPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    desertPool_idToObjDict__keys[index][i] = key;
                    desertPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    desertPool_idToObjDict__keys[index][i] = key;
                    desertPool_idToObjDict__values[index][i] = value;
                    desertPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    desertPool_idToObjDict__keys[index][i] = key;
                    desertPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    desertPool_idToObjDict__keys[index][i] = key;
                    desertPool_idToObjDict__values[index][i] = value;
                    desertPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        desertPool_idToObjDict_ExpandList(index);
        desertPool_idToObjDict__keys[index][preLen] = key;
        desertPool_idToObjDict__values[index][preLen] = value;
        desertPool_idToObjDict__size++;
        return true;
    }

    public void desertPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = desertPool_idToObjDict_Hash(key);
        var hashKeys = desertPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    desertPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    desertPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject desertPool_idToObjDict_GetValue(int key)
    {
        int index = desertPool_idToObjDict_Hash(key);
        var hashKeys = desertPool_idToObjDict__keys[index];
        var hashValues = desertPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject desertPool_idToObjDict_TryGetValue(int key)
    {
        int index = desertPool_idToObjDict_Hash(key);
        var hashKeys = desertPool_idToObjDict__keys[index];
        var hashValues = desertPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void desertPool_idToObjDict_Remove(int key)
    {
        int index = desertPool_idToObjDict_Hash(key);
        var hashKeys = desertPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    desertPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    desertPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int desertPool_Capacity = 100000;
    public bool desertPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        desertPool_itemOperator_col.enabled = active;
        desertPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    [SerializeField]
    int desertPool_itemOperator_capacity = 300000;
    void desertPool_itemOperator_Start()
    {
        desertPool_itemOperator_idToColDict_SetCapacity(desertPool_itemOperator_capacity);
        desertPool_itemOperator_idToMeshDict_SetCapacity(desertPool_itemOperator_capacity);
    }

    int[][] desertPool_itemOperator_idToColDict__keys;
    BoxCollider[][] desertPool_itemOperator_idToColDict__values;
    int desertPool_itemOperator_idToColDict__size;
    public int desertPool_itemOperator_idToColDict_Count => desertPool_itemOperator_idToColDict__size;

    public int[] desertPool_itemOperator_idToColDict_GenerateKeysArray()
    {
        int[] keys = new int[desertPool_itemOperator_idToColDict__size];
        int index = 0;
        for (int i = 0; i < desertPool_itemOperator_idToColDict__keys.Length; i++)
        {
            var hashKeys = desertPool_itemOperator_idToColDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int desertPool_itemOperator_idToColDict_bucketCount = 2;
    public int desertPool_itemOperator_idToColDict_KeyLength => desertPool_itemOperator_idToColDict__keys.Length;

    public void desertPool_itemOperator_idToColDict_SetCapacity(int capacity)
    {
        int len = desertPool_itemOperator_capacity / desertPool_itemOperator_idToColDict_bucketCount;
        desertPool_itemOperator_idToColDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            desertPool_itemOperator_idToColDict__keys[i] = new int[desertPool_itemOperator_idToColDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < desertPool_itemOperator_idToColDict_bucketCount; i++)
        {
            desertPool_itemOperator_idToColDict__keys[0][i] = int.MaxValue;
        }

        desertPool_itemOperator_idToColDict__values = new BoxCollider[len][];
        for (int i = 0; i < len; i++)
        {
            desertPool_itemOperator_idToColDict__values[i] = new BoxCollider[desertPool_itemOperator_idToColDict_bucketCount];
        }
    }

    public bool desertPool_itemOperator_idToColDict_HasItem(int key)
    {
        var index = desertPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = desertPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int desertPool_itemOperator_idToColDict_Hash(int key)
    {
        var len = desertPool_itemOperator_idToColDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool desertPool_itemOperator_idToColDict_Add(int key, BoxCollider value)
    {
        int index = desertPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = desertPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBoxColliderDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    desertPool_itemOperator_idToColDict__keys[index][i] = key;
                    desertPool_itemOperator_idToColDict__values[index][i] = value;
                    desertPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBoxColliderDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    desertPool_itemOperator_idToColDict__keys[index][i] = key;
                    desertPool_itemOperator_idToColDict__values[index][i] = value;
                    desertPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoxColliderDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        desertPool_itemOperator_idToColDict_ExpandList(index);
        desertPool_itemOperator_idToColDict__keys[index][preLen] = key;
        desertPool_itemOperator_idToColDict__values[index][preLen] = value;
        desertPool_itemOperator_idToColDict__size++;
        return true;
    }

    const int desertPool_itemOperator_idToColDict_expand = 10;
    void desertPool_itemOperator_idToColDict_ExpandList(int index)
    {
        var hashKeys = desertPool_itemOperator_idToColDict__keys[index];
        var hashValues = desertPool_itemOperator_idToColDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + desertPool_itemOperator_idToColDict_expand;
        var newKeys = new int[len];
        var newValues = new BoxCollider[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        desertPool_itemOperator_idToColDict__keys[index] = newKeys;
        desertPool_itemOperator_idToColDict__values[index] = newValues;
    }

    public bool desertPool_itemOperator_idToColDict_AddOrSetValue(int key, BoxCollider value)
    {
        int index = desertPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = desertPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    desertPool_itemOperator_idToColDict__keys[index][i] = key;
                    desertPool_itemOperator_idToColDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    desertPool_itemOperator_idToColDict__keys[index][i] = key;
                    desertPool_itemOperator_idToColDict__values[index][i] = value;
                    desertPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    desertPool_itemOperator_idToColDict__keys[index][i] = key;
                    desertPool_itemOperator_idToColDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    desertPool_itemOperator_idToColDict__keys[index][i] = key;
                    desertPool_itemOperator_idToColDict__values[index][i] = value;
                    desertPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoxColliderDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        desertPool_itemOperator_idToColDict_ExpandList(index);
        desertPool_itemOperator_idToColDict__keys[index][preLen] = key;
        desertPool_itemOperator_idToColDict__values[index][preLen] = value;
        desertPool_itemOperator_idToColDict__size++;
        return true;
    }

    public void desertPool_itemOperator_idToColDict_SetValue(int key, BoxCollider value)
    {
        int index = desertPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = desertPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    desertPool_itemOperator_idToColDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    desertPool_itemOperator_idToColDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public BoxCollider desertPool_itemOperator_idToColDict_GetValue(int key)
    {
        int index = desertPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = desertPool_itemOperator_idToColDict__keys[index];
        var hashValues = desertPool_itemOperator_idToColDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void desertPool_itemOperator_idToColDict_Remove(int key)
    {
        int index = desertPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = desertPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    desertPool_itemOperator_idToColDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    desertPool_itemOperator_idToColDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    int[][] desertPool_itemOperator_idToMeshDict__keys;
    MeshRenderer[][] desertPool_itemOperator_idToMeshDict__values;
    int desertPool_itemOperator_idToMeshDict__size;
    public int desertPool_itemOperator_idToMeshDict_Count => desertPool_itemOperator_idToMeshDict__size;

    public int[] desertPool_itemOperator_idToMeshDict_GenerateKeysArray()
    {
        int[] keys = new int[desertPool_itemOperator_idToMeshDict__size];
        int index = 0;
        for (int i = 0; i < desertPool_itemOperator_idToMeshDict__keys.Length; i++)
        {
            var hashKeys = desertPool_itemOperator_idToMeshDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int desertPool_itemOperator_idToMeshDict_bucketCount = 2;
    public int desertPool_itemOperator_idToMeshDict_KeyLength => desertPool_itemOperator_idToMeshDict__keys.Length;

    public void desertPool_itemOperator_idToMeshDict_SetCapacity(int capacity)
    {
        int len = desertPool_itemOperator_capacity / desertPool_itemOperator_idToMeshDict_bucketCount;
        desertPool_itemOperator_idToMeshDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            desertPool_itemOperator_idToMeshDict__keys[i] = new int[desertPool_itemOperator_idToMeshDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < desertPool_itemOperator_idToMeshDict_bucketCount; i++)
        {
            desertPool_itemOperator_idToMeshDict__keys[0][i] = int.MaxValue;
        }

        desertPool_itemOperator_idToMeshDict__values = new MeshRenderer[len][];
        for (int i = 0; i < len; i++)
        {
            desertPool_itemOperator_idToMeshDict__values[i] = new MeshRenderer[desertPool_itemOperator_idToMeshDict_bucketCount];
        }
    }

    public bool desertPool_itemOperator_idToMeshDict_HasItem(int key)
    {
        var index = desertPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = desertPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int desertPool_itemOperator_idToMeshDict_Hash(int key)
    {
        var len = desertPool_itemOperator_idToMeshDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool desertPool_itemOperator_idToMeshDict_Add(int key, MeshRenderer value)
    {
        int index = desertPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = desertPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyMeshRendererDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    desertPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    desertPool_itemOperator_idToMeshDict__values[index][i] = value;
                    desertPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyMeshRendererDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    desertPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    desertPool_itemOperator_idToMeshDict__values[index][i] = value;
                    desertPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyMeshRendererDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        desertPool_itemOperator_idToMeshDict_ExpandList(index);
        desertPool_itemOperator_idToMeshDict__keys[index][preLen] = key;
        desertPool_itemOperator_idToMeshDict__values[index][preLen] = value;
        desertPool_itemOperator_idToMeshDict__size++;
        return true;
    }

    const int desertPool_itemOperator_idToMeshDict_expand = 10;
    void desertPool_itemOperator_idToMeshDict_ExpandList(int index)
    {
        var hashKeys = desertPool_itemOperator_idToMeshDict__keys[index];
        var hashValues = desertPool_itemOperator_idToMeshDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + desertPool_itemOperator_idToMeshDict_expand;
        var newKeys = new int[len];
        var newValues = new MeshRenderer[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        desertPool_itemOperator_idToMeshDict__keys[index] = newKeys;
        desertPool_itemOperator_idToMeshDict__values[index] = newValues;
    }

    public bool desertPool_itemOperator_idToMeshDict_AddOrSetValue(int key, MeshRenderer value)
    {
        int index = desertPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = desertPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    desertPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    desertPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    desertPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    desertPool_itemOperator_idToMeshDict__values[index][i] = value;
                    desertPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    desertPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    desertPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    desertPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    desertPool_itemOperator_idToMeshDict__values[index][i] = value;
                    desertPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyMeshRendererDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        desertPool_itemOperator_idToMeshDict_ExpandList(index);
        desertPool_itemOperator_idToMeshDict__keys[index][preLen] = key;
        desertPool_itemOperator_idToMeshDict__values[index][preLen] = value;
        desertPool_itemOperator_idToMeshDict__size++;
        return true;
    }

    public void desertPool_itemOperator_idToMeshDict_SetValue(int key, MeshRenderer value)
    {
        int index = desertPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = desertPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    desertPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    desertPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public MeshRenderer desertPool_itemOperator_idToMeshDict_GetValue(int key)
    {
        int index = desertPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = desertPool_itemOperator_idToMeshDict__keys[index];
        var hashValues = desertPool_itemOperator_idToMeshDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void desertPool_itemOperator_idToMeshDict_Remove(int key)
    {
        int index = desertPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = desertPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    desertPool_itemOperator_idToMeshDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    desertPool_itemOperator_idToMeshDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    BoxCollider desertPool_itemOperator_col;
    MeshRenderer desertPool_itemOperator_mesh;
    public bool desertPool_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        if (desertPool_itemOperator_idToColDict_HasItem(instanceID))
        {
            desertPool_itemOperator_col = desertPool_itemOperator_idToColDict_GetValue(instanceID);
        }
        else
        {
            desertPool_itemOperator_col = obj.GetComponent<BoxCollider>();
            desertPool_itemOperator_idToColDict_Add(instanceID, desertPool_itemOperator_col);
        }

        if (desertPool_itemOperator_idToMeshDict_HasItem(instanceID))
        {
            desertPool_itemOperator_mesh = desertPool_itemOperator_idToMeshDict_GetValue(instanceID);
        }
        else
        {
            desertPool_itemOperator_mesh = obj.GetComponent<MeshRenderer>();
            desertPool_itemOperator_idToMeshDict_Add(instanceID, desertPool_itemOperator_mesh);
        }

        desertPool_itemOperator_col.enabled = active;
        desertPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool desertPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (desertPool_itemOperator_col == null || desertPool_itemOperator_mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return desertPool_itemOperator_col.enabled && desertPool_itemOperator_mesh.enabled;
    }

    int desertPool_poolSize;
    private int[] desertPool_notActiveObjQueue__array;
    private int desertPool_notActiveObjQueue__head; // First valid element in the queue.
    private int desertPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int desertPool_notActiveObjQueue__size; // Number of elements.
    private int desertPool_notActiveObjQueue__version;
    private const int desertPool_notActiveObjQueue_MinimumGrow = 100000;
    public int desertPool_notActiveObjQueue_Count => desertPool_notActiveObjQueue__size;
    public int desertPool_notActiveObjQueue_Version => desertPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int desertPool_notActiveObjQueue_GetCount() => desertPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int desertPool_notActiveObjQueue_GetVersion() => desertPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void desertPool_notActiveObjQueue_Clear()
    {
        if (desertPool_notActiveObjQueue__size != 0)
        {
            if (desertPool_notActiveObjQueue__head < desertPool_notActiveObjQueue__tail)
            {
                Array.Clear(desertPool_notActiveObjQueue__array, desertPool_notActiveObjQueue__head, desertPool_notActiveObjQueue__size);
            }
            else
            {
                Array.Clear(desertPool_notActiveObjQueue__array, desertPool_notActiveObjQueue__head, desertPool_notActiveObjQueue__array.Length - desertPool_notActiveObjQueue__head);
                Array.Clear(desertPool_notActiveObjQueue__array, 0, desertPool_notActiveObjQueue__tail);
            }

            desertPool_notActiveObjQueue__size = 0;
        }

        desertPool_notActiveObjQueue__head = 0;
        desertPool_notActiveObjQueue__tail = 0;
        desertPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void desertPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < desertPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = desertPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = desertPool_notActiveObjQueue__array.Length - desertPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(desertPool_notActiveObjQueue__array, desertPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(desertPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void desertPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (desertPool_notActiveObjQueue__array == null)
        {
            desertPool_notActiveObjQueue_SetCapacity(desertPool_notActiveObjQueue_MinimumGrow);
        }
        else if (desertPool_notActiveObjQueue__size == desertPool_notActiveObjQueue__array.Length)
        {
            desertPool_notActiveObjQueue_SetCapacity(desertPool_notActiveObjQueue__array.Length + desertPool_notActiveObjQueue_MinimumGrow);
        }

        desertPool_notActiveObjQueue__array[desertPool_notActiveObjQueue__tail] = obj;
        desertPool_notActiveObjQueue__tail = (desertPool_notActiveObjQueue__tail + 1) % desertPool_notActiveObjQueue__array.Length;
        desertPool_notActiveObjQueue__size++;
        desertPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int desertPool_notActiveObjQueue_Dequeue()
    {
        if (desertPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = desertPool_notActiveObjQueue__array[desertPool_notActiveObjQueue__head];
        desertPool_notActiveObjQueue__array[desertPool_notActiveObjQueue__head] = int.MaxValue;
        desertPool_notActiveObjQueue__head = (desertPool_notActiveObjQueue__head + 1) % desertPool_notActiveObjQueue__array.Length;
        desertPool_notActiveObjQueue__size--;
        desertPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int desertPool_notActiveObjQueue_Peek()
    {
        if (desertPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return desertPool_notActiveObjQueue__array[desertPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] desertPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[desertPool_notActiveObjQueue__size];
        if (desertPool_notActiveObjQueue__size == 0)
        {
        }
        else if (desertPool_notActiveObjQueue__head < desertPool_notActiveObjQueue__tail)
        {
            Array.Copy(desertPool_notActiveObjQueue__array, desertPool_notActiveObjQueue__head, arr, 0, desertPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = desertPool_notActiveObjQueue__array.Length - desertPool_notActiveObjQueue__head;
            Array.Copy(desertPool_notActiveObjQueue__array, desertPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(desertPool_notActiveObjQueue__array, 0, arr, toHead, desertPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void desertPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (desertPool_notActiveObjQueue__size == 0)
        {
        }
        else if (desertPool_notActiveObjQueue__head < desertPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(desertPool_notActiveObjQueue__array, desertPool_notActiveObjQueue__head, newArray, 0, desertPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = desertPool_notActiveObjQueue__array.Length - desertPool_notActiveObjQueue__head;
            Array.Copy(desertPool_notActiveObjQueue__array, desertPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(desertPool_notActiveObjQueue__array, 0, newArray, toHead, desertPool_notActiveObjQueue__tail);
        }

        desertPool_notActiveObjQueue__array = newArray;
        desertPool_notActiveObjQueue__head = 0;
        desertPool_notActiveObjQueue__tail = desertPool_notActiveObjQueue__size == capacity ? 0 : desertPool_notActiveObjQueue__size;
        desertPool_notActiveObjQueue__version++;
    }

    [SerializeField]
    Transform desertPool_parent;
    void desertPool_Start()
    {
        desertPool_itemOperator_Start();
        desertPool_prefabName = desertPool_prefab.name;
        desertPool_idToObjDict_SetCapacity(desertPool_Capacity);
        desertPool_notActiveObjQueue_SetCapacity(desertPool_Capacity);
    }

    public bool desertPool_PeekIsInstantiated()
    {
        return desertPool_isInstantiated;
    }

    bool desertPool_isInstantiated = false;
    public void desertPool_Store(Transform p = null)
    {
        if (desertPool_idToObjDict_Count > desertPool_idToObjDict_KeyLength)
            return;
        desertPool_isInstantiated = true;
        GameObject instance;
        int id;
        desertPool_instance = GameObject.Instantiate(desertPool_prefab);
        //gc alloc debug only
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        //id = GetInstanceID(instance);/*instance.GetInstanceID();*///.GetHashCode();
        id = desertPool_instance.GetInstanceID();
        desertPool_itemOperator_SetActive(desertPool_instance, id, false);
        desertPool_idToObjDict_Add(id, desertPool_instance);
        desertPool_notActiveObjQueue_Enqueue(id);
    }

    string desertPool_prefabName;
    GameObject desertPool_instance;
    // falseで出してmeshcombinerで切り替える
    int desertPool_uniqueId = 0;
    public GameObject desertPool_TryToSpawn()
    {
        int id;
        desertPool_isInstantiated = true;
        if (desertPool_notActiveObjQueue_Count > 0)
        {
            desertPool_isInstantiated = false;
            id = desertPool_notActiveObjQueue_Dequeue();
            if (desertPool_idToObjDict_HasItem(id))
            {
                var obj = desertPool_idToObjDict_GetValue(id);
                //itemOperator.SetActive(obj,id,true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        desertPool_instance = GameObject.Instantiate(desertPool_prefab);
        //gc alloc
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        id = desertPool_instance.GetInstanceID();
        desertPool_idToObjDict_Add(id, desertPool_instance); // gc alloc
        //itemOperator.SetActive(instance,id,true);
        //}while(!idToObjDict.Add(id,instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return desertPool_instance;
    }

    public GameObject desertPool_TryToSpawn(int id)
    {
        desertPool_isInstantiated = false;
        if (desertPool_idToObjDict_HasItem(id))
        {
            var obj = desertPool_idToObjDict_GetValue(id);
            desertPool_itemOperator_SetActive(obj, id, false);
            return obj;
        }
        else
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return null;
        }
    }

    public void desertPool_Return(GameObject obj, bool force = false, bool enqueue = true)
    {
        // gc alloc debug only
        //if(obj==null)return; // gc alloc debug only
        int id = obj.GetInstanceID(); //obj.GetInstanceID();
        if (!desertPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        desertPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            desertPool_notActiveObjQueue_Enqueue(id);
    }

    public void desertPool_Return(GameObject obj, int id, bool force = false, bool enqueue = true)
    {
        //if(obj==null)return; // gc alloc debug only
        if (!desertPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        desertPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            desertPool_notActiveObjQueue_Enqueue(id);
    }

    public bool desertPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(desertPool_prefab.name);
    }

    public void desertPool_Clear()
    {
        desertPool_notActiveObjQueue_Clear();
        foreach (var obj in desertPool_idToObjDict_GenerateKeysArray())
        {
            desertPool_itemOperator_SetActive(desertPool_idToObjDict_GetValue(obj), false);
            desertPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject dirtPool_prefab;
    int[][] dirtPool_idToObjDict__keys;
    GameObject[][] dirtPool_idToObjDict__values;
    int dirtPool_idToObjDict__size;
    public int dirtPool_idToObjDict_Count => dirtPool_idToObjDict__size;

    public int[] dirtPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[dirtPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < dirtPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = dirtPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int dirtPool_idToObjDict_bucketCount = 2;
    public int dirtPool_idToObjDict_KeyLength => dirtPool_idToObjDict__keys.Length;

    public void dirtPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / dirtPool_idToObjDict_bucketCount;
        dirtPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            dirtPool_idToObjDict__keys[i] = new int[dirtPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < dirtPool_idToObjDict_bucketCount; i++)
        {
            dirtPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        dirtPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            dirtPool_idToObjDict__values[i] = new GameObject[dirtPool_idToObjDict_bucketCount];
        }
    }

    public bool dirtPool_idToObjDict_HasItem(int key)
    {
        var index = dirtPool_idToObjDict_Hash(key);
        var hashKeys = dirtPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int dirtPool_idToObjDict_Hash(int key)
    {
        var len = dirtPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool dirtPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = dirtPool_idToObjDict_Hash(key);
        var hashKeys = dirtPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    dirtPool_idToObjDict__keys[index][i] = key;
                    dirtPool_idToObjDict__values[index][i] = value;
                    dirtPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    dirtPool_idToObjDict__keys[index][i] = key;
                    dirtPool_idToObjDict__values[index][i] = value;
                    dirtPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        dirtPool_idToObjDict_ExpandList(index);
        dirtPool_idToObjDict__keys[index][preLen] = key;
        dirtPool_idToObjDict__values[index][preLen] = value;
        dirtPool_idToObjDict__size++;
        return true;
    }

    const int dirtPool_idToObjDict_expand = 10;
    void dirtPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = dirtPool_idToObjDict__keys[index];
        var hashValues = dirtPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + dirtPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        dirtPool_idToObjDict__keys[index] = newKeys;
        dirtPool_idToObjDict__values[index] = newValues;
    }

    public bool dirtPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = dirtPool_idToObjDict_Hash(key);
        var hashKeys = dirtPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    dirtPool_idToObjDict__keys[index][i] = key;
                    dirtPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    dirtPool_idToObjDict__keys[index][i] = key;
                    dirtPool_idToObjDict__values[index][i] = value;
                    dirtPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    dirtPool_idToObjDict__keys[index][i] = key;
                    dirtPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    dirtPool_idToObjDict__keys[index][i] = key;
                    dirtPool_idToObjDict__values[index][i] = value;
                    dirtPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        dirtPool_idToObjDict_ExpandList(index);
        dirtPool_idToObjDict__keys[index][preLen] = key;
        dirtPool_idToObjDict__values[index][preLen] = value;
        dirtPool_idToObjDict__size++;
        return true;
    }

    public void dirtPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = dirtPool_idToObjDict_Hash(key);
        var hashKeys = dirtPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    dirtPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    dirtPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject dirtPool_idToObjDict_GetValue(int key)
    {
        int index = dirtPool_idToObjDict_Hash(key);
        var hashKeys = dirtPool_idToObjDict__keys[index];
        var hashValues = dirtPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject dirtPool_idToObjDict_TryGetValue(int key)
    {
        int index = dirtPool_idToObjDict_Hash(key);
        var hashKeys = dirtPool_idToObjDict__keys[index];
        var hashValues = dirtPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void dirtPool_idToObjDict_Remove(int key)
    {
        int index = dirtPool_idToObjDict_Hash(key);
        var hashKeys = dirtPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    dirtPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    dirtPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int dirtPool_Capacity = 100000;
    public bool dirtPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        dirtPool_itemOperator_col.enabled = active;
        dirtPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    [SerializeField]
    int dirtPool_itemOperator_capacity = 300000;
    void dirtPool_itemOperator_Start()
    {
        dirtPool_itemOperator_idToColDict_SetCapacity(dirtPool_itemOperator_capacity);
        dirtPool_itemOperator_idToMeshDict_SetCapacity(dirtPool_itemOperator_capacity);
    }

    int[][] dirtPool_itemOperator_idToColDict__keys;
    BoxCollider[][] dirtPool_itemOperator_idToColDict__values;
    int dirtPool_itemOperator_idToColDict__size;
    public int dirtPool_itemOperator_idToColDict_Count => dirtPool_itemOperator_idToColDict__size;

    public int[] dirtPool_itemOperator_idToColDict_GenerateKeysArray()
    {
        int[] keys = new int[dirtPool_itemOperator_idToColDict__size];
        int index = 0;
        for (int i = 0; i < dirtPool_itemOperator_idToColDict__keys.Length; i++)
        {
            var hashKeys = dirtPool_itemOperator_idToColDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int dirtPool_itemOperator_idToColDict_bucketCount = 2;
    public int dirtPool_itemOperator_idToColDict_KeyLength => dirtPool_itemOperator_idToColDict__keys.Length;

    public void dirtPool_itemOperator_idToColDict_SetCapacity(int capacity)
    {
        int len = dirtPool_itemOperator_capacity / dirtPool_itemOperator_idToColDict_bucketCount;
        dirtPool_itemOperator_idToColDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            dirtPool_itemOperator_idToColDict__keys[i] = new int[dirtPool_itemOperator_idToColDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < dirtPool_itemOperator_idToColDict_bucketCount; i++)
        {
            dirtPool_itemOperator_idToColDict__keys[0][i] = int.MaxValue;
        }

        dirtPool_itemOperator_idToColDict__values = new BoxCollider[len][];
        for (int i = 0; i < len; i++)
        {
            dirtPool_itemOperator_idToColDict__values[i] = new BoxCollider[dirtPool_itemOperator_idToColDict_bucketCount];
        }
    }

    public bool dirtPool_itemOperator_idToColDict_HasItem(int key)
    {
        var index = dirtPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = dirtPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int dirtPool_itemOperator_idToColDict_Hash(int key)
    {
        var len = dirtPool_itemOperator_idToColDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool dirtPool_itemOperator_idToColDict_Add(int key, BoxCollider value)
    {
        int index = dirtPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = dirtPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBoxColliderDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    dirtPool_itemOperator_idToColDict__keys[index][i] = key;
                    dirtPool_itemOperator_idToColDict__values[index][i] = value;
                    dirtPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBoxColliderDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    dirtPool_itemOperator_idToColDict__keys[index][i] = key;
                    dirtPool_itemOperator_idToColDict__values[index][i] = value;
                    dirtPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoxColliderDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        dirtPool_itemOperator_idToColDict_ExpandList(index);
        dirtPool_itemOperator_idToColDict__keys[index][preLen] = key;
        dirtPool_itemOperator_idToColDict__values[index][preLen] = value;
        dirtPool_itemOperator_idToColDict__size++;
        return true;
    }

    const int dirtPool_itemOperator_idToColDict_expand = 10;
    void dirtPool_itemOperator_idToColDict_ExpandList(int index)
    {
        var hashKeys = dirtPool_itemOperator_idToColDict__keys[index];
        var hashValues = dirtPool_itemOperator_idToColDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + dirtPool_itemOperator_idToColDict_expand;
        var newKeys = new int[len];
        var newValues = new BoxCollider[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        dirtPool_itemOperator_idToColDict__keys[index] = newKeys;
        dirtPool_itemOperator_idToColDict__values[index] = newValues;
    }

    public bool dirtPool_itemOperator_idToColDict_AddOrSetValue(int key, BoxCollider value)
    {
        int index = dirtPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = dirtPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    dirtPool_itemOperator_idToColDict__keys[index][i] = key;
                    dirtPool_itemOperator_idToColDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    dirtPool_itemOperator_idToColDict__keys[index][i] = key;
                    dirtPool_itemOperator_idToColDict__values[index][i] = value;
                    dirtPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    dirtPool_itemOperator_idToColDict__keys[index][i] = key;
                    dirtPool_itemOperator_idToColDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    dirtPool_itemOperator_idToColDict__keys[index][i] = key;
                    dirtPool_itemOperator_idToColDict__values[index][i] = value;
                    dirtPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoxColliderDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        dirtPool_itemOperator_idToColDict_ExpandList(index);
        dirtPool_itemOperator_idToColDict__keys[index][preLen] = key;
        dirtPool_itemOperator_idToColDict__values[index][preLen] = value;
        dirtPool_itemOperator_idToColDict__size++;
        return true;
    }

    public void dirtPool_itemOperator_idToColDict_SetValue(int key, BoxCollider value)
    {
        int index = dirtPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = dirtPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    dirtPool_itemOperator_idToColDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    dirtPool_itemOperator_idToColDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public BoxCollider dirtPool_itemOperator_idToColDict_GetValue(int key)
    {
        int index = dirtPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = dirtPool_itemOperator_idToColDict__keys[index];
        var hashValues = dirtPool_itemOperator_idToColDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void dirtPool_itemOperator_idToColDict_Remove(int key)
    {
        int index = dirtPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = dirtPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    dirtPool_itemOperator_idToColDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    dirtPool_itemOperator_idToColDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    int[][] dirtPool_itemOperator_idToMeshDict__keys;
    MeshRenderer[][] dirtPool_itemOperator_idToMeshDict__values;
    int dirtPool_itemOperator_idToMeshDict__size;
    public int dirtPool_itemOperator_idToMeshDict_Count => dirtPool_itemOperator_idToMeshDict__size;

    public int[] dirtPool_itemOperator_idToMeshDict_GenerateKeysArray()
    {
        int[] keys = new int[dirtPool_itemOperator_idToMeshDict__size];
        int index = 0;
        for (int i = 0; i < dirtPool_itemOperator_idToMeshDict__keys.Length; i++)
        {
            var hashKeys = dirtPool_itemOperator_idToMeshDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int dirtPool_itemOperator_idToMeshDict_bucketCount = 2;
    public int dirtPool_itemOperator_idToMeshDict_KeyLength => dirtPool_itemOperator_idToMeshDict__keys.Length;

    public void dirtPool_itemOperator_idToMeshDict_SetCapacity(int capacity)
    {
        int len = dirtPool_itemOperator_capacity / dirtPool_itemOperator_idToMeshDict_bucketCount;
        dirtPool_itemOperator_idToMeshDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            dirtPool_itemOperator_idToMeshDict__keys[i] = new int[dirtPool_itemOperator_idToMeshDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < dirtPool_itemOperator_idToMeshDict_bucketCount; i++)
        {
            dirtPool_itemOperator_idToMeshDict__keys[0][i] = int.MaxValue;
        }

        dirtPool_itemOperator_idToMeshDict__values = new MeshRenderer[len][];
        for (int i = 0; i < len; i++)
        {
            dirtPool_itemOperator_idToMeshDict__values[i] = new MeshRenderer[dirtPool_itemOperator_idToMeshDict_bucketCount];
        }
    }

    public bool dirtPool_itemOperator_idToMeshDict_HasItem(int key)
    {
        var index = dirtPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = dirtPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int dirtPool_itemOperator_idToMeshDict_Hash(int key)
    {
        var len = dirtPool_itemOperator_idToMeshDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool dirtPool_itemOperator_idToMeshDict_Add(int key, MeshRenderer value)
    {
        int index = dirtPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = dirtPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyMeshRendererDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    dirtPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    dirtPool_itemOperator_idToMeshDict__values[index][i] = value;
                    dirtPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyMeshRendererDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    dirtPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    dirtPool_itemOperator_idToMeshDict__values[index][i] = value;
                    dirtPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyMeshRendererDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        dirtPool_itemOperator_idToMeshDict_ExpandList(index);
        dirtPool_itemOperator_idToMeshDict__keys[index][preLen] = key;
        dirtPool_itemOperator_idToMeshDict__values[index][preLen] = value;
        dirtPool_itemOperator_idToMeshDict__size++;
        return true;
    }

    const int dirtPool_itemOperator_idToMeshDict_expand = 10;
    void dirtPool_itemOperator_idToMeshDict_ExpandList(int index)
    {
        var hashKeys = dirtPool_itemOperator_idToMeshDict__keys[index];
        var hashValues = dirtPool_itemOperator_idToMeshDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + dirtPool_itemOperator_idToMeshDict_expand;
        var newKeys = new int[len];
        var newValues = new MeshRenderer[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        dirtPool_itemOperator_idToMeshDict__keys[index] = newKeys;
        dirtPool_itemOperator_idToMeshDict__values[index] = newValues;
    }

    public bool dirtPool_itemOperator_idToMeshDict_AddOrSetValue(int key, MeshRenderer value)
    {
        int index = dirtPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = dirtPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    dirtPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    dirtPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    dirtPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    dirtPool_itemOperator_idToMeshDict__values[index][i] = value;
                    dirtPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    dirtPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    dirtPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    dirtPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    dirtPool_itemOperator_idToMeshDict__values[index][i] = value;
                    dirtPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyMeshRendererDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        dirtPool_itemOperator_idToMeshDict_ExpandList(index);
        dirtPool_itemOperator_idToMeshDict__keys[index][preLen] = key;
        dirtPool_itemOperator_idToMeshDict__values[index][preLen] = value;
        dirtPool_itemOperator_idToMeshDict__size++;
        return true;
    }

    public void dirtPool_itemOperator_idToMeshDict_SetValue(int key, MeshRenderer value)
    {
        int index = dirtPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = dirtPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    dirtPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    dirtPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public MeshRenderer dirtPool_itemOperator_idToMeshDict_GetValue(int key)
    {
        int index = dirtPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = dirtPool_itemOperator_idToMeshDict__keys[index];
        var hashValues = dirtPool_itemOperator_idToMeshDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void dirtPool_itemOperator_idToMeshDict_Remove(int key)
    {
        int index = dirtPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = dirtPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    dirtPool_itemOperator_idToMeshDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    dirtPool_itemOperator_idToMeshDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    BoxCollider dirtPool_itemOperator_col;
    MeshRenderer dirtPool_itemOperator_mesh;
    public bool dirtPool_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        if (dirtPool_itemOperator_idToColDict_HasItem(instanceID))
        {
            dirtPool_itemOperator_col = dirtPool_itemOperator_idToColDict_GetValue(instanceID);
        }
        else
        {
            dirtPool_itemOperator_col = obj.GetComponent<BoxCollider>();
            dirtPool_itemOperator_idToColDict_Add(instanceID, dirtPool_itemOperator_col);
        }

        if (dirtPool_itemOperator_idToMeshDict_HasItem(instanceID))
        {
            dirtPool_itemOperator_mesh = dirtPool_itemOperator_idToMeshDict_GetValue(instanceID);
        }
        else
        {
            dirtPool_itemOperator_mesh = obj.GetComponent<MeshRenderer>();
            dirtPool_itemOperator_idToMeshDict_Add(instanceID, dirtPool_itemOperator_mesh);
        }

        dirtPool_itemOperator_col.enabled = active;
        dirtPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool dirtPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (dirtPool_itemOperator_col == null || dirtPool_itemOperator_mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return dirtPool_itemOperator_col.enabled && dirtPool_itemOperator_mesh.enabled;
    }

    int dirtPool_poolSize;
    private int[] dirtPool_notActiveObjQueue__array;
    private int dirtPool_notActiveObjQueue__head; // First valid element in the queue.
    private int dirtPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int dirtPool_notActiveObjQueue__size; // Number of elements.
    private int dirtPool_notActiveObjQueue__version;
    private const int dirtPool_notActiveObjQueue_MinimumGrow = 100000;
    public int dirtPool_notActiveObjQueue_Count => dirtPool_notActiveObjQueue__size;
    public int dirtPool_notActiveObjQueue_Version => dirtPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int dirtPool_notActiveObjQueue_GetCount() => dirtPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int dirtPool_notActiveObjQueue_GetVersion() => dirtPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void dirtPool_notActiveObjQueue_Clear()
    {
        if (dirtPool_notActiveObjQueue__size != 0)
        {
            if (dirtPool_notActiveObjQueue__head < dirtPool_notActiveObjQueue__tail)
            {
                Array.Clear(dirtPool_notActiveObjQueue__array, dirtPool_notActiveObjQueue__head, dirtPool_notActiveObjQueue__size);
            }
            else
            {
                Array.Clear(dirtPool_notActiveObjQueue__array, dirtPool_notActiveObjQueue__head, dirtPool_notActiveObjQueue__array.Length - dirtPool_notActiveObjQueue__head);
                Array.Clear(dirtPool_notActiveObjQueue__array, 0, dirtPool_notActiveObjQueue__tail);
            }

            dirtPool_notActiveObjQueue__size = 0;
        }

        dirtPool_notActiveObjQueue__head = 0;
        dirtPool_notActiveObjQueue__tail = 0;
        dirtPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void dirtPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < dirtPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = dirtPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = dirtPool_notActiveObjQueue__array.Length - dirtPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(dirtPool_notActiveObjQueue__array, dirtPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(dirtPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void dirtPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (dirtPool_notActiveObjQueue__array == null)
        {
            dirtPool_notActiveObjQueue_SetCapacity(dirtPool_notActiveObjQueue_MinimumGrow);
        }
        else if (dirtPool_notActiveObjQueue__size == dirtPool_notActiveObjQueue__array.Length)
        {
            dirtPool_notActiveObjQueue_SetCapacity(dirtPool_notActiveObjQueue__array.Length + dirtPool_notActiveObjQueue_MinimumGrow);
        }

        dirtPool_notActiveObjQueue__array[dirtPool_notActiveObjQueue__tail] = obj;
        dirtPool_notActiveObjQueue__tail = (dirtPool_notActiveObjQueue__tail + 1) % dirtPool_notActiveObjQueue__array.Length;
        dirtPool_notActiveObjQueue__size++;
        dirtPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int dirtPool_notActiveObjQueue_Dequeue()
    {
        if (dirtPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = dirtPool_notActiveObjQueue__array[dirtPool_notActiveObjQueue__head];
        dirtPool_notActiveObjQueue__array[dirtPool_notActiveObjQueue__head] = int.MaxValue;
        dirtPool_notActiveObjQueue__head = (dirtPool_notActiveObjQueue__head + 1) % dirtPool_notActiveObjQueue__array.Length;
        dirtPool_notActiveObjQueue__size--;
        dirtPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int dirtPool_notActiveObjQueue_Peek()
    {
        if (dirtPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return dirtPool_notActiveObjQueue__array[dirtPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] dirtPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[dirtPool_notActiveObjQueue__size];
        if (dirtPool_notActiveObjQueue__size == 0)
        {
        }
        else if (dirtPool_notActiveObjQueue__head < dirtPool_notActiveObjQueue__tail)
        {
            Array.Copy(dirtPool_notActiveObjQueue__array, dirtPool_notActiveObjQueue__head, arr, 0, dirtPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = dirtPool_notActiveObjQueue__array.Length - dirtPool_notActiveObjQueue__head;
            Array.Copy(dirtPool_notActiveObjQueue__array, dirtPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(dirtPool_notActiveObjQueue__array, 0, arr, toHead, dirtPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void dirtPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (dirtPool_notActiveObjQueue__size == 0)
        {
        }
        else if (dirtPool_notActiveObjQueue__head < dirtPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(dirtPool_notActiveObjQueue__array, dirtPool_notActiveObjQueue__head, newArray, 0, dirtPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = dirtPool_notActiveObjQueue__array.Length - dirtPool_notActiveObjQueue__head;
            Array.Copy(dirtPool_notActiveObjQueue__array, dirtPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(dirtPool_notActiveObjQueue__array, 0, newArray, toHead, dirtPool_notActiveObjQueue__tail);
        }

        dirtPool_notActiveObjQueue__array = newArray;
        dirtPool_notActiveObjQueue__head = 0;
        dirtPool_notActiveObjQueue__tail = dirtPool_notActiveObjQueue__size == capacity ? 0 : dirtPool_notActiveObjQueue__size;
        dirtPool_notActiveObjQueue__version++;
    }

    [SerializeField]
    Transform dirtPool_parent;
    void dirtPool_Start()
    {
        dirtPool_itemOperator_Start();
        dirtPool_prefabName = dirtPool_prefab.name;
        dirtPool_idToObjDict_SetCapacity(dirtPool_Capacity);
        dirtPool_notActiveObjQueue_SetCapacity(dirtPool_Capacity);
    }

    public bool dirtPool_PeekIsInstantiated()
    {
        return dirtPool_isInstantiated;
    }

    bool dirtPool_isInstantiated = false;
    public void dirtPool_Store(Transform p = null)
    {
        if (dirtPool_idToObjDict_Count > dirtPool_idToObjDict_KeyLength)
            return;
        dirtPool_isInstantiated = true;
        GameObject instance;
        int id;
        dirtPool_instance = GameObject.Instantiate(dirtPool_prefab);
        //gc alloc debug only
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        //id = GetInstanceID(instance);/*instance.GetInstanceID();*///.GetHashCode();
        id = dirtPool_instance.GetInstanceID();
        dirtPool_itemOperator_SetActive(dirtPool_instance, id, false);
        dirtPool_idToObjDict_Add(id, dirtPool_instance);
        dirtPool_notActiveObjQueue_Enqueue(id);
    }

    string dirtPool_prefabName;
    GameObject dirtPool_instance;
    // falseで出してmeshcombinerで切り替える
    int dirtPool_uniqueId = 0;
    public GameObject dirtPool_TryToSpawn()
    {
        int id;
        dirtPool_isInstantiated = true;
        if (dirtPool_notActiveObjQueue_Count > 0)
        {
            dirtPool_isInstantiated = false;
            id = dirtPool_notActiveObjQueue_Dequeue();
            if (dirtPool_idToObjDict_HasItem(id))
            {
                var obj = dirtPool_idToObjDict_GetValue(id);
                //itemOperator.SetActive(obj,id,true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        dirtPool_instance = GameObject.Instantiate(dirtPool_prefab);
        //gc alloc
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        id = dirtPool_instance.GetInstanceID();
        dirtPool_idToObjDict_Add(id, dirtPool_instance); // gc alloc
        //itemOperator.SetActive(instance,id,true);
        //}while(!idToObjDict.Add(id,instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return dirtPool_instance;
    }

    public GameObject dirtPool_TryToSpawn(int id)
    {
        dirtPool_isInstantiated = false;
        if (dirtPool_idToObjDict_HasItem(id))
        {
            var obj = dirtPool_idToObjDict_GetValue(id);
            dirtPool_itemOperator_SetActive(obj, id, false);
            return obj;
        }
        else
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return null;
        }
    }

    public void dirtPool_Return(GameObject obj, bool force = false, bool enqueue = true)
    {
        // gc alloc debug only
        //if(obj==null)return; // gc alloc debug only
        int id = obj.GetInstanceID(); //obj.GetInstanceID();
        if (!dirtPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        dirtPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            dirtPool_notActiveObjQueue_Enqueue(id);
    }

    public void dirtPool_Return(GameObject obj, int id, bool force = false, bool enqueue = true)
    {
        //if(obj==null)return; // gc alloc debug only
        if (!dirtPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        dirtPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            dirtPool_notActiveObjQueue_Enqueue(id);
    }

    public bool dirtPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(dirtPool_prefab.name);
    }

    public void dirtPool_Clear()
    {
        dirtPool_notActiveObjQueue_Clear();
        foreach (var obj in dirtPool_idToObjDict_GenerateKeysArray())
        {
            dirtPool_itemOperator_SetActive(dirtPool_idToObjDict_GetValue(obj), false);
            dirtPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject rockPool_prefab;
    int[][] rockPool_idToObjDict__keys;
    GameObject[][] rockPool_idToObjDict__values;
    int rockPool_idToObjDict__size;
    public int rockPool_idToObjDict_Count => rockPool_idToObjDict__size;

    public int[] rockPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[rockPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < rockPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = rockPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int rockPool_idToObjDict_bucketCount = 2;
    public int rockPool_idToObjDict_KeyLength => rockPool_idToObjDict__keys.Length;

    public void rockPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / rockPool_idToObjDict_bucketCount;
        rockPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            rockPool_idToObjDict__keys[i] = new int[rockPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < rockPool_idToObjDict_bucketCount; i++)
        {
            rockPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        rockPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            rockPool_idToObjDict__values[i] = new GameObject[rockPool_idToObjDict_bucketCount];
        }
    }

    public bool rockPool_idToObjDict_HasItem(int key)
    {
        var index = rockPool_idToObjDict_Hash(key);
        var hashKeys = rockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int rockPool_idToObjDict_Hash(int key)
    {
        var len = rockPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool rockPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = rockPool_idToObjDict_Hash(key);
        var hashKeys = rockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    rockPool_idToObjDict__keys[index][i] = key;
                    rockPool_idToObjDict__values[index][i] = value;
                    rockPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    rockPool_idToObjDict__keys[index][i] = key;
                    rockPool_idToObjDict__values[index][i] = value;
                    rockPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        rockPool_idToObjDict_ExpandList(index);
        rockPool_idToObjDict__keys[index][preLen] = key;
        rockPool_idToObjDict__values[index][preLen] = value;
        rockPool_idToObjDict__size++;
        return true;
    }

    const int rockPool_idToObjDict_expand = 10;
    void rockPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = rockPool_idToObjDict__keys[index];
        var hashValues = rockPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + rockPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        rockPool_idToObjDict__keys[index] = newKeys;
        rockPool_idToObjDict__values[index] = newValues;
    }

    public bool rockPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = rockPool_idToObjDict_Hash(key);
        var hashKeys = rockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    rockPool_idToObjDict__keys[index][i] = key;
                    rockPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    rockPool_idToObjDict__keys[index][i] = key;
                    rockPool_idToObjDict__values[index][i] = value;
                    rockPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    rockPool_idToObjDict__keys[index][i] = key;
                    rockPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    rockPool_idToObjDict__keys[index][i] = key;
                    rockPool_idToObjDict__values[index][i] = value;
                    rockPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        rockPool_idToObjDict_ExpandList(index);
        rockPool_idToObjDict__keys[index][preLen] = key;
        rockPool_idToObjDict__values[index][preLen] = value;
        rockPool_idToObjDict__size++;
        return true;
    }

    public void rockPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = rockPool_idToObjDict_Hash(key);
        var hashKeys = rockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    rockPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    rockPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject rockPool_idToObjDict_GetValue(int key)
    {
        int index = rockPool_idToObjDict_Hash(key);
        var hashKeys = rockPool_idToObjDict__keys[index];
        var hashValues = rockPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject rockPool_idToObjDict_TryGetValue(int key)
    {
        int index = rockPool_idToObjDict_Hash(key);
        var hashKeys = rockPool_idToObjDict__keys[index];
        var hashValues = rockPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void rockPool_idToObjDict_Remove(int key)
    {
        int index = rockPool_idToObjDict_Hash(key);
        var hashKeys = rockPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    rockPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    rockPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int rockPool_Capacity = 100000;
    public bool rockPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        rockPool_itemOperator_col.enabled = active;
        rockPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    [SerializeField]
    int rockPool_itemOperator_capacity = 300000;
    void rockPool_itemOperator_Start()
    {
        rockPool_itemOperator_idToColDict_SetCapacity(rockPool_itemOperator_capacity);
        rockPool_itemOperator_idToMeshDict_SetCapacity(rockPool_itemOperator_capacity);
    }

    int[][] rockPool_itemOperator_idToColDict__keys;
    BoxCollider[][] rockPool_itemOperator_idToColDict__values;
    int rockPool_itemOperator_idToColDict__size;
    public int rockPool_itemOperator_idToColDict_Count => rockPool_itemOperator_idToColDict__size;

    public int[] rockPool_itemOperator_idToColDict_GenerateKeysArray()
    {
        int[] keys = new int[rockPool_itemOperator_idToColDict__size];
        int index = 0;
        for (int i = 0; i < rockPool_itemOperator_idToColDict__keys.Length; i++)
        {
            var hashKeys = rockPool_itemOperator_idToColDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int rockPool_itemOperator_idToColDict_bucketCount = 2;
    public int rockPool_itemOperator_idToColDict_KeyLength => rockPool_itemOperator_idToColDict__keys.Length;

    public void rockPool_itemOperator_idToColDict_SetCapacity(int capacity)
    {
        int len = rockPool_itemOperator_capacity / rockPool_itemOperator_idToColDict_bucketCount;
        rockPool_itemOperator_idToColDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            rockPool_itemOperator_idToColDict__keys[i] = new int[rockPool_itemOperator_idToColDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < rockPool_itemOperator_idToColDict_bucketCount; i++)
        {
            rockPool_itemOperator_idToColDict__keys[0][i] = int.MaxValue;
        }

        rockPool_itemOperator_idToColDict__values = new BoxCollider[len][];
        for (int i = 0; i < len; i++)
        {
            rockPool_itemOperator_idToColDict__values[i] = new BoxCollider[rockPool_itemOperator_idToColDict_bucketCount];
        }
    }

    public bool rockPool_itemOperator_idToColDict_HasItem(int key)
    {
        var index = rockPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = rockPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int rockPool_itemOperator_idToColDict_Hash(int key)
    {
        var len = rockPool_itemOperator_idToColDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool rockPool_itemOperator_idToColDict_Add(int key, BoxCollider value)
    {
        int index = rockPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = rockPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBoxColliderDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    rockPool_itemOperator_idToColDict__keys[index][i] = key;
                    rockPool_itemOperator_idToColDict__values[index][i] = value;
                    rockPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBoxColliderDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    rockPool_itemOperator_idToColDict__keys[index][i] = key;
                    rockPool_itemOperator_idToColDict__values[index][i] = value;
                    rockPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoxColliderDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        rockPool_itemOperator_idToColDict_ExpandList(index);
        rockPool_itemOperator_idToColDict__keys[index][preLen] = key;
        rockPool_itemOperator_idToColDict__values[index][preLen] = value;
        rockPool_itemOperator_idToColDict__size++;
        return true;
    }

    const int rockPool_itemOperator_idToColDict_expand = 10;
    void rockPool_itemOperator_idToColDict_ExpandList(int index)
    {
        var hashKeys = rockPool_itemOperator_idToColDict__keys[index];
        var hashValues = rockPool_itemOperator_idToColDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + rockPool_itemOperator_idToColDict_expand;
        var newKeys = new int[len];
        var newValues = new BoxCollider[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        rockPool_itemOperator_idToColDict__keys[index] = newKeys;
        rockPool_itemOperator_idToColDict__values[index] = newValues;
    }

    public bool rockPool_itemOperator_idToColDict_AddOrSetValue(int key, BoxCollider value)
    {
        int index = rockPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = rockPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    rockPool_itemOperator_idToColDict__keys[index][i] = key;
                    rockPool_itemOperator_idToColDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    rockPool_itemOperator_idToColDict__keys[index][i] = key;
                    rockPool_itemOperator_idToColDict__values[index][i] = value;
                    rockPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    rockPool_itemOperator_idToColDict__keys[index][i] = key;
                    rockPool_itemOperator_idToColDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    rockPool_itemOperator_idToColDict__keys[index][i] = key;
                    rockPool_itemOperator_idToColDict__values[index][i] = value;
                    rockPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoxColliderDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        rockPool_itemOperator_idToColDict_ExpandList(index);
        rockPool_itemOperator_idToColDict__keys[index][preLen] = key;
        rockPool_itemOperator_idToColDict__values[index][preLen] = value;
        rockPool_itemOperator_idToColDict__size++;
        return true;
    }

    public void rockPool_itemOperator_idToColDict_SetValue(int key, BoxCollider value)
    {
        int index = rockPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = rockPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    rockPool_itemOperator_idToColDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    rockPool_itemOperator_idToColDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public BoxCollider rockPool_itemOperator_idToColDict_GetValue(int key)
    {
        int index = rockPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = rockPool_itemOperator_idToColDict__keys[index];
        var hashValues = rockPool_itemOperator_idToColDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void rockPool_itemOperator_idToColDict_Remove(int key)
    {
        int index = rockPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = rockPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    rockPool_itemOperator_idToColDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    rockPool_itemOperator_idToColDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    int[][] rockPool_itemOperator_idToMeshDict__keys;
    MeshRenderer[][] rockPool_itemOperator_idToMeshDict__values;
    int rockPool_itemOperator_idToMeshDict__size;
    public int rockPool_itemOperator_idToMeshDict_Count => rockPool_itemOperator_idToMeshDict__size;

    public int[] rockPool_itemOperator_idToMeshDict_GenerateKeysArray()
    {
        int[] keys = new int[rockPool_itemOperator_idToMeshDict__size];
        int index = 0;
        for (int i = 0; i < rockPool_itemOperator_idToMeshDict__keys.Length; i++)
        {
            var hashKeys = rockPool_itemOperator_idToMeshDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int rockPool_itemOperator_idToMeshDict_bucketCount = 2;
    public int rockPool_itemOperator_idToMeshDict_KeyLength => rockPool_itemOperator_idToMeshDict__keys.Length;

    public void rockPool_itemOperator_idToMeshDict_SetCapacity(int capacity)
    {
        int len = rockPool_itemOperator_capacity / rockPool_itemOperator_idToMeshDict_bucketCount;
        rockPool_itemOperator_idToMeshDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            rockPool_itemOperator_idToMeshDict__keys[i] = new int[rockPool_itemOperator_idToMeshDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < rockPool_itemOperator_idToMeshDict_bucketCount; i++)
        {
            rockPool_itemOperator_idToMeshDict__keys[0][i] = int.MaxValue;
        }

        rockPool_itemOperator_idToMeshDict__values = new MeshRenderer[len][];
        for (int i = 0; i < len; i++)
        {
            rockPool_itemOperator_idToMeshDict__values[i] = new MeshRenderer[rockPool_itemOperator_idToMeshDict_bucketCount];
        }
    }

    public bool rockPool_itemOperator_idToMeshDict_HasItem(int key)
    {
        var index = rockPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = rockPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int rockPool_itemOperator_idToMeshDict_Hash(int key)
    {
        var len = rockPool_itemOperator_idToMeshDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool rockPool_itemOperator_idToMeshDict_Add(int key, MeshRenderer value)
    {
        int index = rockPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = rockPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyMeshRendererDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    rockPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    rockPool_itemOperator_idToMeshDict__values[index][i] = value;
                    rockPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyMeshRendererDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    rockPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    rockPool_itemOperator_idToMeshDict__values[index][i] = value;
                    rockPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyMeshRendererDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        rockPool_itemOperator_idToMeshDict_ExpandList(index);
        rockPool_itemOperator_idToMeshDict__keys[index][preLen] = key;
        rockPool_itemOperator_idToMeshDict__values[index][preLen] = value;
        rockPool_itemOperator_idToMeshDict__size++;
        return true;
    }

    const int rockPool_itemOperator_idToMeshDict_expand = 10;
    void rockPool_itemOperator_idToMeshDict_ExpandList(int index)
    {
        var hashKeys = rockPool_itemOperator_idToMeshDict__keys[index];
        var hashValues = rockPool_itemOperator_idToMeshDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + rockPool_itemOperator_idToMeshDict_expand;
        var newKeys = new int[len];
        var newValues = new MeshRenderer[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        rockPool_itemOperator_idToMeshDict__keys[index] = newKeys;
        rockPool_itemOperator_idToMeshDict__values[index] = newValues;
    }

    public bool rockPool_itemOperator_idToMeshDict_AddOrSetValue(int key, MeshRenderer value)
    {
        int index = rockPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = rockPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    rockPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    rockPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    rockPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    rockPool_itemOperator_idToMeshDict__values[index][i] = value;
                    rockPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    rockPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    rockPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    rockPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    rockPool_itemOperator_idToMeshDict__values[index][i] = value;
                    rockPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyMeshRendererDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        rockPool_itemOperator_idToMeshDict_ExpandList(index);
        rockPool_itemOperator_idToMeshDict__keys[index][preLen] = key;
        rockPool_itemOperator_idToMeshDict__values[index][preLen] = value;
        rockPool_itemOperator_idToMeshDict__size++;
        return true;
    }

    public void rockPool_itemOperator_idToMeshDict_SetValue(int key, MeshRenderer value)
    {
        int index = rockPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = rockPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    rockPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    rockPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public MeshRenderer rockPool_itemOperator_idToMeshDict_GetValue(int key)
    {
        int index = rockPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = rockPool_itemOperator_idToMeshDict__keys[index];
        var hashValues = rockPool_itemOperator_idToMeshDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void rockPool_itemOperator_idToMeshDict_Remove(int key)
    {
        int index = rockPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = rockPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    rockPool_itemOperator_idToMeshDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    rockPool_itemOperator_idToMeshDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    BoxCollider rockPool_itemOperator_col;
    MeshRenderer rockPool_itemOperator_mesh;
    public bool rockPool_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        if (rockPool_itemOperator_idToColDict_HasItem(instanceID))
        {
            rockPool_itemOperator_col = rockPool_itemOperator_idToColDict_GetValue(instanceID);
        }
        else
        {
            rockPool_itemOperator_col = obj.GetComponent<BoxCollider>();
            rockPool_itemOperator_idToColDict_Add(instanceID, rockPool_itemOperator_col);
        }

        if (rockPool_itemOperator_idToMeshDict_HasItem(instanceID))
        {
            rockPool_itemOperator_mesh = rockPool_itemOperator_idToMeshDict_GetValue(instanceID);
        }
        else
        {
            rockPool_itemOperator_mesh = obj.GetComponent<MeshRenderer>();
            rockPool_itemOperator_idToMeshDict_Add(instanceID, rockPool_itemOperator_mesh);
        }

        rockPool_itemOperator_col.enabled = active;
        rockPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool rockPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (rockPool_itemOperator_col == null || rockPool_itemOperator_mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return rockPool_itemOperator_col.enabled && rockPool_itemOperator_mesh.enabled;
    }

    int rockPool_poolSize;
    private int[] rockPool_notActiveObjQueue__array;
    private int rockPool_notActiveObjQueue__head; // First valid element in the queue.
    private int rockPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int rockPool_notActiveObjQueue__size; // Number of elements.
    private int rockPool_notActiveObjQueue__version;
    private const int rockPool_notActiveObjQueue_MinimumGrow = 100000;
    public int rockPool_notActiveObjQueue_Count => rockPool_notActiveObjQueue__size;
    public int rockPool_notActiveObjQueue_Version => rockPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int rockPool_notActiveObjQueue_GetCount() => rockPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int rockPool_notActiveObjQueue_GetVersion() => rockPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void rockPool_notActiveObjQueue_Clear()
    {
        if (rockPool_notActiveObjQueue__size != 0)
        {
            if (rockPool_notActiveObjQueue__head < rockPool_notActiveObjQueue__tail)
            {
                Array.Clear(rockPool_notActiveObjQueue__array, rockPool_notActiveObjQueue__head, rockPool_notActiveObjQueue__size);
            }
            else
            {
                Array.Clear(rockPool_notActiveObjQueue__array, rockPool_notActiveObjQueue__head, rockPool_notActiveObjQueue__array.Length - rockPool_notActiveObjQueue__head);
                Array.Clear(rockPool_notActiveObjQueue__array, 0, rockPool_notActiveObjQueue__tail);
            }

            rockPool_notActiveObjQueue__size = 0;
        }

        rockPool_notActiveObjQueue__head = 0;
        rockPool_notActiveObjQueue__tail = 0;
        rockPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void rockPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < rockPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = rockPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = rockPool_notActiveObjQueue__array.Length - rockPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(rockPool_notActiveObjQueue__array, rockPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(rockPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void rockPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (rockPool_notActiveObjQueue__array == null)
        {
            rockPool_notActiveObjQueue_SetCapacity(rockPool_notActiveObjQueue_MinimumGrow);
        }
        else if (rockPool_notActiveObjQueue__size == rockPool_notActiveObjQueue__array.Length)
        {
            rockPool_notActiveObjQueue_SetCapacity(rockPool_notActiveObjQueue__array.Length + rockPool_notActiveObjQueue_MinimumGrow);
        }

        rockPool_notActiveObjQueue__array[rockPool_notActiveObjQueue__tail] = obj;
        rockPool_notActiveObjQueue__tail = (rockPool_notActiveObjQueue__tail + 1) % rockPool_notActiveObjQueue__array.Length;
        rockPool_notActiveObjQueue__size++;
        rockPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int rockPool_notActiveObjQueue_Dequeue()
    {
        if (rockPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = rockPool_notActiveObjQueue__array[rockPool_notActiveObjQueue__head];
        rockPool_notActiveObjQueue__array[rockPool_notActiveObjQueue__head] = int.MaxValue;
        rockPool_notActiveObjQueue__head = (rockPool_notActiveObjQueue__head + 1) % rockPool_notActiveObjQueue__array.Length;
        rockPool_notActiveObjQueue__size--;
        rockPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int rockPool_notActiveObjQueue_Peek()
    {
        if (rockPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return rockPool_notActiveObjQueue__array[rockPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] rockPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[rockPool_notActiveObjQueue__size];
        if (rockPool_notActiveObjQueue__size == 0)
        {
        }
        else if (rockPool_notActiveObjQueue__head < rockPool_notActiveObjQueue__tail)
        {
            Array.Copy(rockPool_notActiveObjQueue__array, rockPool_notActiveObjQueue__head, arr, 0, rockPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = rockPool_notActiveObjQueue__array.Length - rockPool_notActiveObjQueue__head;
            Array.Copy(rockPool_notActiveObjQueue__array, rockPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(rockPool_notActiveObjQueue__array, 0, arr, toHead, rockPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void rockPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (rockPool_notActiveObjQueue__size == 0)
        {
        }
        else if (rockPool_notActiveObjQueue__head < rockPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(rockPool_notActiveObjQueue__array, rockPool_notActiveObjQueue__head, newArray, 0, rockPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = rockPool_notActiveObjQueue__array.Length - rockPool_notActiveObjQueue__head;
            Array.Copy(rockPool_notActiveObjQueue__array, rockPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(rockPool_notActiveObjQueue__array, 0, newArray, toHead, rockPool_notActiveObjQueue__tail);
        }

        rockPool_notActiveObjQueue__array = newArray;
        rockPool_notActiveObjQueue__head = 0;
        rockPool_notActiveObjQueue__tail = rockPool_notActiveObjQueue__size == capacity ? 0 : rockPool_notActiveObjQueue__size;
        rockPool_notActiveObjQueue__version++;
    }

    [SerializeField]
    Transform rockPool_parent;
    void rockPool_Start()
    {
        rockPool_itemOperator_Start();
        rockPool_prefabName = rockPool_prefab.name;
        rockPool_idToObjDict_SetCapacity(rockPool_Capacity);
        rockPool_notActiveObjQueue_SetCapacity(rockPool_Capacity);
    }

    public bool rockPool_PeekIsInstantiated()
    {
        return rockPool_isInstantiated;
    }

    bool rockPool_isInstantiated = false;
    public void rockPool_Store(Transform p = null)
    {
        if (rockPool_idToObjDict_Count > rockPool_idToObjDict_KeyLength)
            return;
        rockPool_isInstantiated = true;
        GameObject instance;
        int id;
        rockPool_instance = GameObject.Instantiate(rockPool_prefab);
        //gc alloc debug only
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        //id = GetInstanceID(instance);/*instance.GetInstanceID();*///.GetHashCode();
        id = rockPool_instance.GetInstanceID();
        rockPool_itemOperator_SetActive(rockPool_instance, id, false);
        rockPool_idToObjDict_Add(id, rockPool_instance);
        rockPool_notActiveObjQueue_Enqueue(id);
    }

    string rockPool_prefabName;
    GameObject rockPool_instance;
    // falseで出してmeshcombinerで切り替える
    int rockPool_uniqueId = 0;
    public GameObject rockPool_TryToSpawn()
    {
        int id;
        rockPool_isInstantiated = true;
        if (rockPool_notActiveObjQueue_Count > 0)
        {
            rockPool_isInstantiated = false;
            id = rockPool_notActiveObjQueue_Dequeue();
            if (rockPool_idToObjDict_HasItem(id))
            {
                var obj = rockPool_idToObjDict_GetValue(id);
                //itemOperator.SetActive(obj,id,true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        rockPool_instance = GameObject.Instantiate(rockPool_prefab);
        //gc alloc
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        id = rockPool_instance.GetInstanceID();
        rockPool_idToObjDict_Add(id, rockPool_instance); // gc alloc
        //itemOperator.SetActive(instance,id,true);
        //}while(!idToObjDict.Add(id,instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return rockPool_instance;
    }

    public GameObject rockPool_TryToSpawn(int id)
    {
        rockPool_isInstantiated = false;
        if (rockPool_idToObjDict_HasItem(id))
        {
            var obj = rockPool_idToObjDict_GetValue(id);
            rockPool_itemOperator_SetActive(obj, id, false);
            return obj;
        }
        else
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return null;
        }
    }

    public void rockPool_Return(GameObject obj, bool force = false, bool enqueue = true)
    {
        // gc alloc debug only
        //if(obj==null)return; // gc alloc debug only
        int id = obj.GetInstanceID(); //obj.GetInstanceID();
        if (!rockPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        rockPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            rockPool_notActiveObjQueue_Enqueue(id);
    }

    public void rockPool_Return(GameObject obj, int id, bool force = false, bool enqueue = true)
    {
        //if(obj==null)return; // gc alloc debug only
        if (!rockPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        rockPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            rockPool_notActiveObjQueue_Enqueue(id);
    }

    public bool rockPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(rockPool_prefab.name);
    }

    public void rockPool_Clear()
    {
        rockPool_notActiveObjQueue_Clear();
        foreach (var obj in rockPool_idToObjDict_GenerateKeysArray())
        {
            rockPool_itemOperator_SetActive(rockPool_idToObjDict_GetValue(obj), false);
            rockPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject sandPool_prefab;
    int[][] sandPool_idToObjDict__keys;
    GameObject[][] sandPool_idToObjDict__values;
    int sandPool_idToObjDict__size;
    public int sandPool_idToObjDict_Count => sandPool_idToObjDict__size;

    public int[] sandPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[sandPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < sandPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = sandPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int sandPool_idToObjDict_bucketCount = 2;
    public int sandPool_idToObjDict_KeyLength => sandPool_idToObjDict__keys.Length;

    public void sandPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / sandPool_idToObjDict_bucketCount;
        sandPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            sandPool_idToObjDict__keys[i] = new int[sandPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < sandPool_idToObjDict_bucketCount; i++)
        {
            sandPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        sandPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            sandPool_idToObjDict__values[i] = new GameObject[sandPool_idToObjDict_bucketCount];
        }
    }

    public bool sandPool_idToObjDict_HasItem(int key)
    {
        var index = sandPool_idToObjDict_Hash(key);
        var hashKeys = sandPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int sandPool_idToObjDict_Hash(int key)
    {
        var len = sandPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool sandPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = sandPool_idToObjDict_Hash(key);
        var hashKeys = sandPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    sandPool_idToObjDict__keys[index][i] = key;
                    sandPool_idToObjDict__values[index][i] = value;
                    sandPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    sandPool_idToObjDict__keys[index][i] = key;
                    sandPool_idToObjDict__values[index][i] = value;
                    sandPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        sandPool_idToObjDict_ExpandList(index);
        sandPool_idToObjDict__keys[index][preLen] = key;
        sandPool_idToObjDict__values[index][preLen] = value;
        sandPool_idToObjDict__size++;
        return true;
    }

    const int sandPool_idToObjDict_expand = 10;
    void sandPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = sandPool_idToObjDict__keys[index];
        var hashValues = sandPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + sandPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        sandPool_idToObjDict__keys[index] = newKeys;
        sandPool_idToObjDict__values[index] = newValues;
    }

    public bool sandPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = sandPool_idToObjDict_Hash(key);
        var hashKeys = sandPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    sandPool_idToObjDict__keys[index][i] = key;
                    sandPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    sandPool_idToObjDict__keys[index][i] = key;
                    sandPool_idToObjDict__values[index][i] = value;
                    sandPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    sandPool_idToObjDict__keys[index][i] = key;
                    sandPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    sandPool_idToObjDict__keys[index][i] = key;
                    sandPool_idToObjDict__values[index][i] = value;
                    sandPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        sandPool_idToObjDict_ExpandList(index);
        sandPool_idToObjDict__keys[index][preLen] = key;
        sandPool_idToObjDict__values[index][preLen] = value;
        sandPool_idToObjDict__size++;
        return true;
    }

    public void sandPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = sandPool_idToObjDict_Hash(key);
        var hashKeys = sandPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    sandPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    sandPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject sandPool_idToObjDict_GetValue(int key)
    {
        int index = sandPool_idToObjDict_Hash(key);
        var hashKeys = sandPool_idToObjDict__keys[index];
        var hashValues = sandPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject sandPool_idToObjDict_TryGetValue(int key)
    {
        int index = sandPool_idToObjDict_Hash(key);
        var hashKeys = sandPool_idToObjDict__keys[index];
        var hashValues = sandPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void sandPool_idToObjDict_Remove(int key)
    {
        int index = sandPool_idToObjDict_Hash(key);
        var hashKeys = sandPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    sandPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    sandPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int sandPool_Capacity = 100000;
    public bool sandPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        sandPool_itemOperator_col.enabled = active;
        sandPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    [SerializeField]
    int sandPool_itemOperator_capacity = 300000;
    void sandPool_itemOperator_Start()
    {
        sandPool_itemOperator_idToColDict_SetCapacity(sandPool_itemOperator_capacity);
        sandPool_itemOperator_idToMeshDict_SetCapacity(sandPool_itemOperator_capacity);
    }

    int[][] sandPool_itemOperator_idToColDict__keys;
    BoxCollider[][] sandPool_itemOperator_idToColDict__values;
    int sandPool_itemOperator_idToColDict__size;
    public int sandPool_itemOperator_idToColDict_Count => sandPool_itemOperator_idToColDict__size;

    public int[] sandPool_itemOperator_idToColDict_GenerateKeysArray()
    {
        int[] keys = new int[sandPool_itemOperator_idToColDict__size];
        int index = 0;
        for (int i = 0; i < sandPool_itemOperator_idToColDict__keys.Length; i++)
        {
            var hashKeys = sandPool_itemOperator_idToColDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int sandPool_itemOperator_idToColDict_bucketCount = 2;
    public int sandPool_itemOperator_idToColDict_KeyLength => sandPool_itemOperator_idToColDict__keys.Length;

    public void sandPool_itemOperator_idToColDict_SetCapacity(int capacity)
    {
        int len = sandPool_itemOperator_capacity / sandPool_itemOperator_idToColDict_bucketCount;
        sandPool_itemOperator_idToColDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            sandPool_itemOperator_idToColDict__keys[i] = new int[sandPool_itemOperator_idToColDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < sandPool_itemOperator_idToColDict_bucketCount; i++)
        {
            sandPool_itemOperator_idToColDict__keys[0][i] = int.MaxValue;
        }

        sandPool_itemOperator_idToColDict__values = new BoxCollider[len][];
        for (int i = 0; i < len; i++)
        {
            sandPool_itemOperator_idToColDict__values[i] = new BoxCollider[sandPool_itemOperator_idToColDict_bucketCount];
        }
    }

    public bool sandPool_itemOperator_idToColDict_HasItem(int key)
    {
        var index = sandPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = sandPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int sandPool_itemOperator_idToColDict_Hash(int key)
    {
        var len = sandPool_itemOperator_idToColDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool sandPool_itemOperator_idToColDict_Add(int key, BoxCollider value)
    {
        int index = sandPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = sandPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBoxColliderDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    sandPool_itemOperator_idToColDict__keys[index][i] = key;
                    sandPool_itemOperator_idToColDict__values[index][i] = value;
                    sandPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBoxColliderDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    sandPool_itemOperator_idToColDict__keys[index][i] = key;
                    sandPool_itemOperator_idToColDict__values[index][i] = value;
                    sandPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoxColliderDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        sandPool_itemOperator_idToColDict_ExpandList(index);
        sandPool_itemOperator_idToColDict__keys[index][preLen] = key;
        sandPool_itemOperator_idToColDict__values[index][preLen] = value;
        sandPool_itemOperator_idToColDict__size++;
        return true;
    }

    const int sandPool_itemOperator_idToColDict_expand = 10;
    void sandPool_itemOperator_idToColDict_ExpandList(int index)
    {
        var hashKeys = sandPool_itemOperator_idToColDict__keys[index];
        var hashValues = sandPool_itemOperator_idToColDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + sandPool_itemOperator_idToColDict_expand;
        var newKeys = new int[len];
        var newValues = new BoxCollider[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        sandPool_itemOperator_idToColDict__keys[index] = newKeys;
        sandPool_itemOperator_idToColDict__values[index] = newValues;
    }

    public bool sandPool_itemOperator_idToColDict_AddOrSetValue(int key, BoxCollider value)
    {
        int index = sandPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = sandPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    sandPool_itemOperator_idToColDict__keys[index][i] = key;
                    sandPool_itemOperator_idToColDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    sandPool_itemOperator_idToColDict__keys[index][i] = key;
                    sandPool_itemOperator_idToColDict__values[index][i] = value;
                    sandPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    sandPool_itemOperator_idToColDict__keys[index][i] = key;
                    sandPool_itemOperator_idToColDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    sandPool_itemOperator_idToColDict__keys[index][i] = key;
                    sandPool_itemOperator_idToColDict__values[index][i] = value;
                    sandPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoxColliderDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        sandPool_itemOperator_idToColDict_ExpandList(index);
        sandPool_itemOperator_idToColDict__keys[index][preLen] = key;
        sandPool_itemOperator_idToColDict__values[index][preLen] = value;
        sandPool_itemOperator_idToColDict__size++;
        return true;
    }

    public void sandPool_itemOperator_idToColDict_SetValue(int key, BoxCollider value)
    {
        int index = sandPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = sandPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    sandPool_itemOperator_idToColDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    sandPool_itemOperator_idToColDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public BoxCollider sandPool_itemOperator_idToColDict_GetValue(int key)
    {
        int index = sandPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = sandPool_itemOperator_idToColDict__keys[index];
        var hashValues = sandPool_itemOperator_idToColDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void sandPool_itemOperator_idToColDict_Remove(int key)
    {
        int index = sandPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = sandPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    sandPool_itemOperator_idToColDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    sandPool_itemOperator_idToColDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    int[][] sandPool_itemOperator_idToMeshDict__keys;
    MeshRenderer[][] sandPool_itemOperator_idToMeshDict__values;
    int sandPool_itemOperator_idToMeshDict__size;
    public int sandPool_itemOperator_idToMeshDict_Count => sandPool_itemOperator_idToMeshDict__size;

    public int[] sandPool_itemOperator_idToMeshDict_GenerateKeysArray()
    {
        int[] keys = new int[sandPool_itemOperator_idToMeshDict__size];
        int index = 0;
        for (int i = 0; i < sandPool_itemOperator_idToMeshDict__keys.Length; i++)
        {
            var hashKeys = sandPool_itemOperator_idToMeshDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int sandPool_itemOperator_idToMeshDict_bucketCount = 2;
    public int sandPool_itemOperator_idToMeshDict_KeyLength => sandPool_itemOperator_idToMeshDict__keys.Length;

    public void sandPool_itemOperator_idToMeshDict_SetCapacity(int capacity)
    {
        int len = sandPool_itemOperator_capacity / sandPool_itemOperator_idToMeshDict_bucketCount;
        sandPool_itemOperator_idToMeshDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            sandPool_itemOperator_idToMeshDict__keys[i] = new int[sandPool_itemOperator_idToMeshDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < sandPool_itemOperator_idToMeshDict_bucketCount; i++)
        {
            sandPool_itemOperator_idToMeshDict__keys[0][i] = int.MaxValue;
        }

        sandPool_itemOperator_idToMeshDict__values = new MeshRenderer[len][];
        for (int i = 0; i < len; i++)
        {
            sandPool_itemOperator_idToMeshDict__values[i] = new MeshRenderer[sandPool_itemOperator_idToMeshDict_bucketCount];
        }
    }

    public bool sandPool_itemOperator_idToMeshDict_HasItem(int key)
    {
        var index = sandPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = sandPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int sandPool_itemOperator_idToMeshDict_Hash(int key)
    {
        var len = sandPool_itemOperator_idToMeshDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool sandPool_itemOperator_idToMeshDict_Add(int key, MeshRenderer value)
    {
        int index = sandPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = sandPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyMeshRendererDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    sandPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    sandPool_itemOperator_idToMeshDict__values[index][i] = value;
                    sandPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyMeshRendererDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    sandPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    sandPool_itemOperator_idToMeshDict__values[index][i] = value;
                    sandPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyMeshRendererDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        sandPool_itemOperator_idToMeshDict_ExpandList(index);
        sandPool_itemOperator_idToMeshDict__keys[index][preLen] = key;
        sandPool_itemOperator_idToMeshDict__values[index][preLen] = value;
        sandPool_itemOperator_idToMeshDict__size++;
        return true;
    }

    const int sandPool_itemOperator_idToMeshDict_expand = 10;
    void sandPool_itemOperator_idToMeshDict_ExpandList(int index)
    {
        var hashKeys = sandPool_itemOperator_idToMeshDict__keys[index];
        var hashValues = sandPool_itemOperator_idToMeshDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + sandPool_itemOperator_idToMeshDict_expand;
        var newKeys = new int[len];
        var newValues = new MeshRenderer[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        sandPool_itemOperator_idToMeshDict__keys[index] = newKeys;
        sandPool_itemOperator_idToMeshDict__values[index] = newValues;
    }

    public bool sandPool_itemOperator_idToMeshDict_AddOrSetValue(int key, MeshRenderer value)
    {
        int index = sandPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = sandPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    sandPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    sandPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    sandPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    sandPool_itemOperator_idToMeshDict__values[index][i] = value;
                    sandPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    sandPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    sandPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    sandPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    sandPool_itemOperator_idToMeshDict__values[index][i] = value;
                    sandPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyMeshRendererDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        sandPool_itemOperator_idToMeshDict_ExpandList(index);
        sandPool_itemOperator_idToMeshDict__keys[index][preLen] = key;
        sandPool_itemOperator_idToMeshDict__values[index][preLen] = value;
        sandPool_itemOperator_idToMeshDict__size++;
        return true;
    }

    public void sandPool_itemOperator_idToMeshDict_SetValue(int key, MeshRenderer value)
    {
        int index = sandPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = sandPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    sandPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    sandPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public MeshRenderer sandPool_itemOperator_idToMeshDict_GetValue(int key)
    {
        int index = sandPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = sandPool_itemOperator_idToMeshDict__keys[index];
        var hashValues = sandPool_itemOperator_idToMeshDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void sandPool_itemOperator_idToMeshDict_Remove(int key)
    {
        int index = sandPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = sandPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    sandPool_itemOperator_idToMeshDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    sandPool_itemOperator_idToMeshDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    BoxCollider sandPool_itemOperator_col;
    MeshRenderer sandPool_itemOperator_mesh;
    public bool sandPool_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        if (sandPool_itemOperator_idToColDict_HasItem(instanceID))
        {
            sandPool_itemOperator_col = sandPool_itemOperator_idToColDict_GetValue(instanceID);
        }
        else
        {
            sandPool_itemOperator_col = obj.GetComponent<BoxCollider>();
            sandPool_itemOperator_idToColDict_Add(instanceID, sandPool_itemOperator_col);
        }

        if (sandPool_itemOperator_idToMeshDict_HasItem(instanceID))
        {
            sandPool_itemOperator_mesh = sandPool_itemOperator_idToMeshDict_GetValue(instanceID);
        }
        else
        {
            sandPool_itemOperator_mesh = obj.GetComponent<MeshRenderer>();
            sandPool_itemOperator_idToMeshDict_Add(instanceID, sandPool_itemOperator_mesh);
        }

        sandPool_itemOperator_col.enabled = active;
        sandPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool sandPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (sandPool_itemOperator_col == null || sandPool_itemOperator_mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return sandPool_itemOperator_col.enabled && sandPool_itemOperator_mesh.enabled;
    }

    int sandPool_poolSize;
    private int[] sandPool_notActiveObjQueue__array;
    private int sandPool_notActiveObjQueue__head; // First valid element in the queue.
    private int sandPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int sandPool_notActiveObjQueue__size; // Number of elements.
    private int sandPool_notActiveObjQueue__version;
    private const int sandPool_notActiveObjQueue_MinimumGrow = 100000;
    public int sandPool_notActiveObjQueue_Count => sandPool_notActiveObjQueue__size;
    public int sandPool_notActiveObjQueue_Version => sandPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int sandPool_notActiveObjQueue_GetCount() => sandPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int sandPool_notActiveObjQueue_GetVersion() => sandPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void sandPool_notActiveObjQueue_Clear()
    {
        if (sandPool_notActiveObjQueue__size != 0)
        {
            if (sandPool_notActiveObjQueue__head < sandPool_notActiveObjQueue__tail)
            {
                Array.Clear(sandPool_notActiveObjQueue__array, sandPool_notActiveObjQueue__head, sandPool_notActiveObjQueue__size);
            }
            else
            {
                Array.Clear(sandPool_notActiveObjQueue__array, sandPool_notActiveObjQueue__head, sandPool_notActiveObjQueue__array.Length - sandPool_notActiveObjQueue__head);
                Array.Clear(sandPool_notActiveObjQueue__array, 0, sandPool_notActiveObjQueue__tail);
            }

            sandPool_notActiveObjQueue__size = 0;
        }

        sandPool_notActiveObjQueue__head = 0;
        sandPool_notActiveObjQueue__tail = 0;
        sandPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void sandPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < sandPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = sandPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = sandPool_notActiveObjQueue__array.Length - sandPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(sandPool_notActiveObjQueue__array, sandPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(sandPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void sandPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (sandPool_notActiveObjQueue__array == null)
        {
            sandPool_notActiveObjQueue_SetCapacity(sandPool_notActiveObjQueue_MinimumGrow);
        }
        else if (sandPool_notActiveObjQueue__size == sandPool_notActiveObjQueue__array.Length)
        {
            sandPool_notActiveObjQueue_SetCapacity(sandPool_notActiveObjQueue__array.Length + sandPool_notActiveObjQueue_MinimumGrow);
        }

        sandPool_notActiveObjQueue__array[sandPool_notActiveObjQueue__tail] = obj;
        sandPool_notActiveObjQueue__tail = (sandPool_notActiveObjQueue__tail + 1) % sandPool_notActiveObjQueue__array.Length;
        sandPool_notActiveObjQueue__size++;
        sandPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int sandPool_notActiveObjQueue_Dequeue()
    {
        if (sandPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = sandPool_notActiveObjQueue__array[sandPool_notActiveObjQueue__head];
        sandPool_notActiveObjQueue__array[sandPool_notActiveObjQueue__head] = int.MaxValue;
        sandPool_notActiveObjQueue__head = (sandPool_notActiveObjQueue__head + 1) % sandPool_notActiveObjQueue__array.Length;
        sandPool_notActiveObjQueue__size--;
        sandPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int sandPool_notActiveObjQueue_Peek()
    {
        if (sandPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return sandPool_notActiveObjQueue__array[sandPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] sandPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[sandPool_notActiveObjQueue__size];
        if (sandPool_notActiveObjQueue__size == 0)
        {
        }
        else if (sandPool_notActiveObjQueue__head < sandPool_notActiveObjQueue__tail)
        {
            Array.Copy(sandPool_notActiveObjQueue__array, sandPool_notActiveObjQueue__head, arr, 0, sandPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = sandPool_notActiveObjQueue__array.Length - sandPool_notActiveObjQueue__head;
            Array.Copy(sandPool_notActiveObjQueue__array, sandPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(sandPool_notActiveObjQueue__array, 0, arr, toHead, sandPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void sandPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (sandPool_notActiveObjQueue__size == 0)
        {
        }
        else if (sandPool_notActiveObjQueue__head < sandPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(sandPool_notActiveObjQueue__array, sandPool_notActiveObjQueue__head, newArray, 0, sandPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = sandPool_notActiveObjQueue__array.Length - sandPool_notActiveObjQueue__head;
            Array.Copy(sandPool_notActiveObjQueue__array, sandPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(sandPool_notActiveObjQueue__array, 0, newArray, toHead, sandPool_notActiveObjQueue__tail);
        }

        sandPool_notActiveObjQueue__array = newArray;
        sandPool_notActiveObjQueue__head = 0;
        sandPool_notActiveObjQueue__tail = sandPool_notActiveObjQueue__size == capacity ? 0 : sandPool_notActiveObjQueue__size;
        sandPool_notActiveObjQueue__version++;
    }

    [SerializeField]
    Transform sandPool_parent;
    void sandPool_Start()
    {
        sandPool_itemOperator_Start();
        sandPool_prefabName = sandPool_prefab.name;
        sandPool_idToObjDict_SetCapacity(sandPool_Capacity);
        sandPool_notActiveObjQueue_SetCapacity(sandPool_Capacity);
    }

    public bool sandPool_PeekIsInstantiated()
    {
        return sandPool_isInstantiated;
    }

    bool sandPool_isInstantiated = false;
    public void sandPool_Store(Transform p = null)
    {
        if (sandPool_idToObjDict_Count > sandPool_idToObjDict_KeyLength)
            return;
        sandPool_isInstantiated = true;
        GameObject instance;
        int id;
        sandPool_instance = GameObject.Instantiate(sandPool_prefab);
        //gc alloc debug only
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        //id = GetInstanceID(instance);/*instance.GetInstanceID();*///.GetHashCode();
        id = sandPool_instance.GetInstanceID();
        sandPool_itemOperator_SetActive(sandPool_instance, id, false);
        sandPool_idToObjDict_Add(id, sandPool_instance);
        sandPool_notActiveObjQueue_Enqueue(id);
    }

    string sandPool_prefabName;
    GameObject sandPool_instance;
    // falseで出してmeshcombinerで切り替える
    int sandPool_uniqueId = 0;
    public GameObject sandPool_TryToSpawn()
    {
        int id;
        sandPool_isInstantiated = true;
        if (sandPool_notActiveObjQueue_Count > 0)
        {
            sandPool_isInstantiated = false;
            id = sandPool_notActiveObjQueue_Dequeue();
            if (sandPool_idToObjDict_HasItem(id))
            {
                var obj = sandPool_idToObjDict_GetValue(id);
                //itemOperator.SetActive(obj,id,true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        sandPool_instance = GameObject.Instantiate(sandPool_prefab);
        //gc alloc
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        id = sandPool_instance.GetInstanceID();
        sandPool_idToObjDict_Add(id, sandPool_instance); // gc alloc
        //itemOperator.SetActive(instance,id,true);
        //}while(!idToObjDict.Add(id,instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return sandPool_instance;
    }

    public GameObject sandPool_TryToSpawn(int id)
    {
        sandPool_isInstantiated = false;
        if (sandPool_idToObjDict_HasItem(id))
        {
            var obj = sandPool_idToObjDict_GetValue(id);
            sandPool_itemOperator_SetActive(obj, id, false);
            return obj;
        }
        else
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return null;
        }
    }

    public void sandPool_Return(GameObject obj, bool force = false, bool enqueue = true)
    {
        // gc alloc debug only
        //if(obj==null)return; // gc alloc debug only
        int id = obj.GetInstanceID(); //obj.GetInstanceID();
        if (!sandPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        sandPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            sandPool_notActiveObjQueue_Enqueue(id);
    }

    public void sandPool_Return(GameObject obj, int id, bool force = false, bool enqueue = true)
    {
        //if(obj==null)return; // gc alloc debug only
        if (!sandPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        sandPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            sandPool_notActiveObjQueue_Enqueue(id);
    }

    public bool sandPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(sandPool_prefab.name);
    }

    public void sandPool_Clear()
    {
        sandPool_notActiveObjQueue_Clear();
        foreach (var obj in sandPool_idToObjDict_GenerateKeysArray())
        {
            sandPool_itemOperator_SetActive(sandPool_idToObjDict_GetValue(obj), false);
            sandPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject waterPool_prefab;
    int[][] waterPool_idToObjDict__keys;
    GameObject[][] waterPool_idToObjDict__values;
    int waterPool_idToObjDict__size;
    public int waterPool_idToObjDict_Count => waterPool_idToObjDict__size;

    public int[] waterPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[waterPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < waterPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = waterPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int waterPool_idToObjDict_bucketCount = 2;
    public int waterPool_idToObjDict_KeyLength => waterPool_idToObjDict__keys.Length;

    public void waterPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / waterPool_idToObjDict_bucketCount;
        waterPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            waterPool_idToObjDict__keys[i] = new int[waterPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < waterPool_idToObjDict_bucketCount; i++)
        {
            waterPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        waterPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            waterPool_idToObjDict__values[i] = new GameObject[waterPool_idToObjDict_bucketCount];
        }
    }

    public bool waterPool_idToObjDict_HasItem(int key)
    {
        var index = waterPool_idToObjDict_Hash(key);
        var hashKeys = waterPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int waterPool_idToObjDict_Hash(int key)
    {
        var len = waterPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool waterPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = waterPool_idToObjDict_Hash(key);
        var hashKeys = waterPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    waterPool_idToObjDict__keys[index][i] = key;
                    waterPool_idToObjDict__values[index][i] = value;
                    waterPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    waterPool_idToObjDict__keys[index][i] = key;
                    waterPool_idToObjDict__values[index][i] = value;
                    waterPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        waterPool_idToObjDict_ExpandList(index);
        waterPool_idToObjDict__keys[index][preLen] = key;
        waterPool_idToObjDict__values[index][preLen] = value;
        waterPool_idToObjDict__size++;
        return true;
    }

    const int waterPool_idToObjDict_expand = 10;
    void waterPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = waterPool_idToObjDict__keys[index];
        var hashValues = waterPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + waterPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        waterPool_idToObjDict__keys[index] = newKeys;
        waterPool_idToObjDict__values[index] = newValues;
    }

    public bool waterPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = waterPool_idToObjDict_Hash(key);
        var hashKeys = waterPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    waterPool_idToObjDict__keys[index][i] = key;
                    waterPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    waterPool_idToObjDict__keys[index][i] = key;
                    waterPool_idToObjDict__values[index][i] = value;
                    waterPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    waterPool_idToObjDict__keys[index][i] = key;
                    waterPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    waterPool_idToObjDict__keys[index][i] = key;
                    waterPool_idToObjDict__values[index][i] = value;
                    waterPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        waterPool_idToObjDict_ExpandList(index);
        waterPool_idToObjDict__keys[index][preLen] = key;
        waterPool_idToObjDict__values[index][preLen] = value;
        waterPool_idToObjDict__size++;
        return true;
    }

    public void waterPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = waterPool_idToObjDict_Hash(key);
        var hashKeys = waterPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    waterPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    waterPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject waterPool_idToObjDict_GetValue(int key)
    {
        int index = waterPool_idToObjDict_Hash(key);
        var hashKeys = waterPool_idToObjDict__keys[index];
        var hashValues = waterPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject waterPool_idToObjDict_TryGetValue(int key)
    {
        int index = waterPool_idToObjDict_Hash(key);
        var hashKeys = waterPool_idToObjDict__keys[index];
        var hashValues = waterPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void waterPool_idToObjDict_Remove(int key)
    {
        int index = waterPool_idToObjDict_Hash(key);
        var hashKeys = waterPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    waterPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    waterPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int waterPool_Capacity = 100000;
    public bool waterPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        waterPool_itemOperator_col.enabled = active;
        waterPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    [SerializeField]
    int waterPool_itemOperator_capacity = 300000;
    void waterPool_itemOperator_Start()
    {
        waterPool_itemOperator_idToColDict_SetCapacity(waterPool_itemOperator_capacity);
        waterPool_itemOperator_idToMeshDict_SetCapacity(waterPool_itemOperator_capacity);
    }

    int[][] waterPool_itemOperator_idToColDict__keys;
    BoxCollider[][] waterPool_itemOperator_idToColDict__values;
    int waterPool_itemOperator_idToColDict__size;
    public int waterPool_itemOperator_idToColDict_Count => waterPool_itemOperator_idToColDict__size;

    public int[] waterPool_itemOperator_idToColDict_GenerateKeysArray()
    {
        int[] keys = new int[waterPool_itemOperator_idToColDict__size];
        int index = 0;
        for (int i = 0; i < waterPool_itemOperator_idToColDict__keys.Length; i++)
        {
            var hashKeys = waterPool_itemOperator_idToColDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int waterPool_itemOperator_idToColDict_bucketCount = 2;
    public int waterPool_itemOperator_idToColDict_KeyLength => waterPool_itemOperator_idToColDict__keys.Length;

    public void waterPool_itemOperator_idToColDict_SetCapacity(int capacity)
    {
        int len = waterPool_itemOperator_capacity / waterPool_itemOperator_idToColDict_bucketCount;
        waterPool_itemOperator_idToColDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            waterPool_itemOperator_idToColDict__keys[i] = new int[waterPool_itemOperator_idToColDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < waterPool_itemOperator_idToColDict_bucketCount; i++)
        {
            waterPool_itemOperator_idToColDict__keys[0][i] = int.MaxValue;
        }

        waterPool_itemOperator_idToColDict__values = new BoxCollider[len][];
        for (int i = 0; i < len; i++)
        {
            waterPool_itemOperator_idToColDict__values[i] = new BoxCollider[waterPool_itemOperator_idToColDict_bucketCount];
        }
    }

    public bool waterPool_itemOperator_idToColDict_HasItem(int key)
    {
        var index = waterPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = waterPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int waterPool_itemOperator_idToColDict_Hash(int key)
    {
        var len = waterPool_itemOperator_idToColDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool waterPool_itemOperator_idToColDict_Add(int key, BoxCollider value)
    {
        int index = waterPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = waterPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBoxColliderDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    waterPool_itemOperator_idToColDict__keys[index][i] = key;
                    waterPool_itemOperator_idToColDict__values[index][i] = value;
                    waterPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBoxColliderDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    waterPool_itemOperator_idToColDict__keys[index][i] = key;
                    waterPool_itemOperator_idToColDict__values[index][i] = value;
                    waterPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoxColliderDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        waterPool_itemOperator_idToColDict_ExpandList(index);
        waterPool_itemOperator_idToColDict__keys[index][preLen] = key;
        waterPool_itemOperator_idToColDict__values[index][preLen] = value;
        waterPool_itemOperator_idToColDict__size++;
        return true;
    }

    const int waterPool_itemOperator_idToColDict_expand = 10;
    void waterPool_itemOperator_idToColDict_ExpandList(int index)
    {
        var hashKeys = waterPool_itemOperator_idToColDict__keys[index];
        var hashValues = waterPool_itemOperator_idToColDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + waterPool_itemOperator_idToColDict_expand;
        var newKeys = new int[len];
        var newValues = new BoxCollider[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        waterPool_itemOperator_idToColDict__keys[index] = newKeys;
        waterPool_itemOperator_idToColDict__values[index] = newValues;
    }

    public bool waterPool_itemOperator_idToColDict_AddOrSetValue(int key, BoxCollider value)
    {
        int index = waterPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = waterPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    waterPool_itemOperator_idToColDict__keys[index][i] = key;
                    waterPool_itemOperator_idToColDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    waterPool_itemOperator_idToColDict__keys[index][i] = key;
                    waterPool_itemOperator_idToColDict__values[index][i] = value;
                    waterPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    waterPool_itemOperator_idToColDict__keys[index][i] = key;
                    waterPool_itemOperator_idToColDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    waterPool_itemOperator_idToColDict__keys[index][i] = key;
                    waterPool_itemOperator_idToColDict__values[index][i] = value;
                    waterPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoxColliderDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        waterPool_itemOperator_idToColDict_ExpandList(index);
        waterPool_itemOperator_idToColDict__keys[index][preLen] = key;
        waterPool_itemOperator_idToColDict__values[index][preLen] = value;
        waterPool_itemOperator_idToColDict__size++;
        return true;
    }

    public void waterPool_itemOperator_idToColDict_SetValue(int key, BoxCollider value)
    {
        int index = waterPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = waterPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    waterPool_itemOperator_idToColDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    waterPool_itemOperator_idToColDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public BoxCollider waterPool_itemOperator_idToColDict_GetValue(int key)
    {
        int index = waterPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = waterPool_itemOperator_idToColDict__keys[index];
        var hashValues = waterPool_itemOperator_idToColDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void waterPool_itemOperator_idToColDict_Remove(int key)
    {
        int index = waterPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = waterPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    waterPool_itemOperator_idToColDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    waterPool_itemOperator_idToColDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    int[][] waterPool_itemOperator_idToMeshDict__keys;
    MeshRenderer[][] waterPool_itemOperator_idToMeshDict__values;
    int waterPool_itemOperator_idToMeshDict__size;
    public int waterPool_itemOperator_idToMeshDict_Count => waterPool_itemOperator_idToMeshDict__size;

    public int[] waterPool_itemOperator_idToMeshDict_GenerateKeysArray()
    {
        int[] keys = new int[waterPool_itemOperator_idToMeshDict__size];
        int index = 0;
        for (int i = 0; i < waterPool_itemOperator_idToMeshDict__keys.Length; i++)
        {
            var hashKeys = waterPool_itemOperator_idToMeshDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int waterPool_itemOperator_idToMeshDict_bucketCount = 2;
    public int waterPool_itemOperator_idToMeshDict_KeyLength => waterPool_itemOperator_idToMeshDict__keys.Length;

    public void waterPool_itemOperator_idToMeshDict_SetCapacity(int capacity)
    {
        int len = waterPool_itemOperator_capacity / waterPool_itemOperator_idToMeshDict_bucketCount;
        waterPool_itemOperator_idToMeshDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            waterPool_itemOperator_idToMeshDict__keys[i] = new int[waterPool_itemOperator_idToMeshDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < waterPool_itemOperator_idToMeshDict_bucketCount; i++)
        {
            waterPool_itemOperator_idToMeshDict__keys[0][i] = int.MaxValue;
        }

        waterPool_itemOperator_idToMeshDict__values = new MeshRenderer[len][];
        for (int i = 0; i < len; i++)
        {
            waterPool_itemOperator_idToMeshDict__values[i] = new MeshRenderer[waterPool_itemOperator_idToMeshDict_bucketCount];
        }
    }

    public bool waterPool_itemOperator_idToMeshDict_HasItem(int key)
    {
        var index = waterPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = waterPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int waterPool_itemOperator_idToMeshDict_Hash(int key)
    {
        var len = waterPool_itemOperator_idToMeshDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool waterPool_itemOperator_idToMeshDict_Add(int key, MeshRenderer value)
    {
        int index = waterPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = waterPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyMeshRendererDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    waterPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    waterPool_itemOperator_idToMeshDict__values[index][i] = value;
                    waterPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyMeshRendererDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    waterPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    waterPool_itemOperator_idToMeshDict__values[index][i] = value;
                    waterPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyMeshRendererDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        waterPool_itemOperator_idToMeshDict_ExpandList(index);
        waterPool_itemOperator_idToMeshDict__keys[index][preLen] = key;
        waterPool_itemOperator_idToMeshDict__values[index][preLen] = value;
        waterPool_itemOperator_idToMeshDict__size++;
        return true;
    }

    const int waterPool_itemOperator_idToMeshDict_expand = 10;
    void waterPool_itemOperator_idToMeshDict_ExpandList(int index)
    {
        var hashKeys = waterPool_itemOperator_idToMeshDict__keys[index];
        var hashValues = waterPool_itemOperator_idToMeshDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + waterPool_itemOperator_idToMeshDict_expand;
        var newKeys = new int[len];
        var newValues = new MeshRenderer[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        waterPool_itemOperator_idToMeshDict__keys[index] = newKeys;
        waterPool_itemOperator_idToMeshDict__values[index] = newValues;
    }

    public bool waterPool_itemOperator_idToMeshDict_AddOrSetValue(int key, MeshRenderer value)
    {
        int index = waterPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = waterPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    waterPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    waterPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    waterPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    waterPool_itemOperator_idToMeshDict__values[index][i] = value;
                    waterPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    waterPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    waterPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    waterPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    waterPool_itemOperator_idToMeshDict__values[index][i] = value;
                    waterPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyMeshRendererDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        waterPool_itemOperator_idToMeshDict_ExpandList(index);
        waterPool_itemOperator_idToMeshDict__keys[index][preLen] = key;
        waterPool_itemOperator_idToMeshDict__values[index][preLen] = value;
        waterPool_itemOperator_idToMeshDict__size++;
        return true;
    }

    public void waterPool_itemOperator_idToMeshDict_SetValue(int key, MeshRenderer value)
    {
        int index = waterPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = waterPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    waterPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    waterPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public MeshRenderer waterPool_itemOperator_idToMeshDict_GetValue(int key)
    {
        int index = waterPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = waterPool_itemOperator_idToMeshDict__keys[index];
        var hashValues = waterPool_itemOperator_idToMeshDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void waterPool_itemOperator_idToMeshDict_Remove(int key)
    {
        int index = waterPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = waterPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    waterPool_itemOperator_idToMeshDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    waterPool_itemOperator_idToMeshDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    BoxCollider waterPool_itemOperator_col;
    MeshRenderer waterPool_itemOperator_mesh;
    public bool waterPool_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        if (waterPool_itemOperator_idToColDict_HasItem(instanceID))
        {
            waterPool_itemOperator_col = waterPool_itemOperator_idToColDict_GetValue(instanceID);
        }
        else
        {
            waterPool_itemOperator_col = obj.GetComponent<BoxCollider>();
            waterPool_itemOperator_idToColDict_Add(instanceID, waterPool_itemOperator_col);
        }

        if (waterPool_itemOperator_idToMeshDict_HasItem(instanceID))
        {
            waterPool_itemOperator_mesh = waterPool_itemOperator_idToMeshDict_GetValue(instanceID);
        }
        else
        {
            waterPool_itemOperator_mesh = obj.GetComponent<MeshRenderer>();
            waterPool_itemOperator_idToMeshDict_Add(instanceID, waterPool_itemOperator_mesh);
        }

        waterPool_itemOperator_col.enabled = active;
        waterPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool waterPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (waterPool_itemOperator_col == null || waterPool_itemOperator_mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return waterPool_itemOperator_col.enabled && waterPool_itemOperator_mesh.enabled;
    }

    int waterPool_poolSize;
    private int[] waterPool_notActiveObjQueue__array;
    private int waterPool_notActiveObjQueue__head; // First valid element in the queue.
    private int waterPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int waterPool_notActiveObjQueue__size; // Number of elements.
    private int waterPool_notActiveObjQueue__version;
    private const int waterPool_notActiveObjQueue_MinimumGrow = 100000;
    public int waterPool_notActiveObjQueue_Count => waterPool_notActiveObjQueue__size;
    public int waterPool_notActiveObjQueue_Version => waterPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int waterPool_notActiveObjQueue_GetCount() => waterPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int waterPool_notActiveObjQueue_GetVersion() => waterPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void waterPool_notActiveObjQueue_Clear()
    {
        if (waterPool_notActiveObjQueue__size != 0)
        {
            if (waterPool_notActiveObjQueue__head < waterPool_notActiveObjQueue__tail)
            {
                Array.Clear(waterPool_notActiveObjQueue__array, waterPool_notActiveObjQueue__head, waterPool_notActiveObjQueue__size);
            }
            else
            {
                Array.Clear(waterPool_notActiveObjQueue__array, waterPool_notActiveObjQueue__head, waterPool_notActiveObjQueue__array.Length - waterPool_notActiveObjQueue__head);
                Array.Clear(waterPool_notActiveObjQueue__array, 0, waterPool_notActiveObjQueue__tail);
            }

            waterPool_notActiveObjQueue__size = 0;
        }

        waterPool_notActiveObjQueue__head = 0;
        waterPool_notActiveObjQueue__tail = 0;
        waterPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void waterPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < waterPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = waterPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = waterPool_notActiveObjQueue__array.Length - waterPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(waterPool_notActiveObjQueue__array, waterPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(waterPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void waterPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (waterPool_notActiveObjQueue__array == null)
        {
            waterPool_notActiveObjQueue_SetCapacity(waterPool_notActiveObjQueue_MinimumGrow);
        }
        else if (waterPool_notActiveObjQueue__size == waterPool_notActiveObjQueue__array.Length)
        {
            waterPool_notActiveObjQueue_SetCapacity(waterPool_notActiveObjQueue__array.Length + waterPool_notActiveObjQueue_MinimumGrow);
        }

        waterPool_notActiveObjQueue__array[waterPool_notActiveObjQueue__tail] = obj;
        waterPool_notActiveObjQueue__tail = (waterPool_notActiveObjQueue__tail + 1) % waterPool_notActiveObjQueue__array.Length;
        waterPool_notActiveObjQueue__size++;
        waterPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int waterPool_notActiveObjQueue_Dequeue()
    {
        if (waterPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = waterPool_notActiveObjQueue__array[waterPool_notActiveObjQueue__head];
        waterPool_notActiveObjQueue__array[waterPool_notActiveObjQueue__head] = int.MaxValue;
        waterPool_notActiveObjQueue__head = (waterPool_notActiveObjQueue__head + 1) % waterPool_notActiveObjQueue__array.Length;
        waterPool_notActiveObjQueue__size--;
        waterPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int waterPool_notActiveObjQueue_Peek()
    {
        if (waterPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return waterPool_notActiveObjQueue__array[waterPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] waterPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[waterPool_notActiveObjQueue__size];
        if (waterPool_notActiveObjQueue__size == 0)
        {
        }
        else if (waterPool_notActiveObjQueue__head < waterPool_notActiveObjQueue__tail)
        {
            Array.Copy(waterPool_notActiveObjQueue__array, waterPool_notActiveObjQueue__head, arr, 0, waterPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = waterPool_notActiveObjQueue__array.Length - waterPool_notActiveObjQueue__head;
            Array.Copy(waterPool_notActiveObjQueue__array, waterPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(waterPool_notActiveObjQueue__array, 0, arr, toHead, waterPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void waterPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (waterPool_notActiveObjQueue__size == 0)
        {
        }
        else if (waterPool_notActiveObjQueue__head < waterPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(waterPool_notActiveObjQueue__array, waterPool_notActiveObjQueue__head, newArray, 0, waterPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = waterPool_notActiveObjQueue__array.Length - waterPool_notActiveObjQueue__head;
            Array.Copy(waterPool_notActiveObjQueue__array, waterPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(waterPool_notActiveObjQueue__array, 0, newArray, toHead, waterPool_notActiveObjQueue__tail);
        }

        waterPool_notActiveObjQueue__array = newArray;
        waterPool_notActiveObjQueue__head = 0;
        waterPool_notActiveObjQueue__tail = waterPool_notActiveObjQueue__size == capacity ? 0 : waterPool_notActiveObjQueue__size;
        waterPool_notActiveObjQueue__version++;
    }

    [SerializeField]
    Transform waterPool_parent;
    void waterPool_Start()
    {
        waterPool_itemOperator_Start();
        waterPool_prefabName = waterPool_prefab.name;
        waterPool_idToObjDict_SetCapacity(waterPool_Capacity);
        waterPool_notActiveObjQueue_SetCapacity(waterPool_Capacity);
    }

    public bool waterPool_PeekIsInstantiated()
    {
        return waterPool_isInstantiated;
    }

    bool waterPool_isInstantiated = false;
    public void waterPool_Store(Transform p = null)
    {
        if (waterPool_idToObjDict_Count > waterPool_idToObjDict_KeyLength)
            return;
        waterPool_isInstantiated = true;
        GameObject instance;
        int id;
        waterPool_instance = GameObject.Instantiate(waterPool_prefab);
        //gc alloc debug only
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        //id = GetInstanceID(instance);/*instance.GetInstanceID();*///.GetHashCode();
        id = waterPool_instance.GetInstanceID();
        waterPool_itemOperator_SetActive(waterPool_instance, id, false);
        waterPool_idToObjDict_Add(id, waterPool_instance);
        waterPool_notActiveObjQueue_Enqueue(id);
    }

    string waterPool_prefabName;
    GameObject waterPool_instance;
    // falseで出してmeshcombinerで切り替える
    int waterPool_uniqueId = 0;
    public GameObject waterPool_TryToSpawn()
    {
        int id;
        waterPool_isInstantiated = true;
        if (waterPool_notActiveObjQueue_Count > 0)
        {
            waterPool_isInstantiated = false;
            id = waterPool_notActiveObjQueue_Dequeue();
            if (waterPool_idToObjDict_HasItem(id))
            {
                var obj = waterPool_idToObjDict_GetValue(id);
                //itemOperator.SetActive(obj,id,true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        waterPool_instance = GameObject.Instantiate(waterPool_prefab);
        //gc alloc
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        id = waterPool_instance.GetInstanceID();
        waterPool_idToObjDict_Add(id, waterPool_instance); // gc alloc
        //itemOperator.SetActive(instance,id,true);
        //}while(!idToObjDict.Add(id,instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return waterPool_instance;
    }

    public GameObject waterPool_TryToSpawn(int id)
    {
        waterPool_isInstantiated = false;
        if (waterPool_idToObjDict_HasItem(id))
        {
            var obj = waterPool_idToObjDict_GetValue(id);
            waterPool_itemOperator_SetActive(obj, id, false);
            return obj;
        }
        else
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return null;
        }
    }

    public void waterPool_Return(GameObject obj, bool force = false, bool enqueue = true)
    {
        // gc alloc debug only
        //if(obj==null)return; // gc alloc debug only
        int id = obj.GetInstanceID(); //obj.GetInstanceID();
        if (!waterPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        waterPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            waterPool_notActiveObjQueue_Enqueue(id);
    }

    public void waterPool_Return(GameObject obj, int id, bool force = false, bool enqueue = true)
    {
        //if(obj==null)return; // gc alloc debug only
        if (!waterPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        waterPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            waterPool_notActiveObjQueue_Enqueue(id);
    }

    public bool waterPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(waterPool_prefab.name);
    }

    public void waterPool_Clear()
    {
        waterPool_notActiveObjQueue_Clear();
        foreach (var obj in waterPool_idToObjDict_GenerateKeysArray())
        {
            waterPool_itemOperator_SetActive(waterPool_idToObjDict_GetValue(obj), false);
            waterPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    [SerializeField]
    GameObject darkPool_prefab;
    int[][] darkPool_idToObjDict__keys;
    GameObject[][] darkPool_idToObjDict__values;
    int darkPool_idToObjDict__size;
    public int darkPool_idToObjDict_Count => darkPool_idToObjDict__size;

    public int[] darkPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[darkPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < darkPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = darkPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int darkPool_idToObjDict_bucketCount = 2;
    public int darkPool_idToObjDict_KeyLength => darkPool_idToObjDict__keys.Length;

    public void darkPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / darkPool_idToObjDict_bucketCount;
        darkPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            darkPool_idToObjDict__keys[i] = new int[darkPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < darkPool_idToObjDict_bucketCount; i++)
        {
            darkPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        darkPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            darkPool_idToObjDict__values[i] = new GameObject[darkPool_idToObjDict_bucketCount];
        }
    }

    public bool darkPool_idToObjDict_HasItem(int key)
    {
        var index = darkPool_idToObjDict_Hash(key);
        var hashKeys = darkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int darkPool_idToObjDict_Hash(int key)
    {
        var len = darkPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool darkPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = darkPool_idToObjDict_Hash(key);
        var hashKeys = darkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    darkPool_idToObjDict__keys[index][i] = key;
                    darkPool_idToObjDict__values[index][i] = value;
                    darkPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    darkPool_idToObjDict__keys[index][i] = key;
                    darkPool_idToObjDict__values[index][i] = value;
                    darkPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        darkPool_idToObjDict_ExpandList(index);
        darkPool_idToObjDict__keys[index][preLen] = key;
        darkPool_idToObjDict__values[index][preLen] = value;
        darkPool_idToObjDict__size++;
        return true;
    }

    const int darkPool_idToObjDict_expand = 10;
    void darkPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = darkPool_idToObjDict__keys[index];
        var hashValues = darkPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + darkPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        darkPool_idToObjDict__keys[index] = newKeys;
        darkPool_idToObjDict__values[index] = newValues;
    }

    public bool darkPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = darkPool_idToObjDict_Hash(key);
        var hashKeys = darkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    darkPool_idToObjDict__keys[index][i] = key;
                    darkPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    darkPool_idToObjDict__keys[index][i] = key;
                    darkPool_idToObjDict__values[index][i] = value;
                    darkPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    darkPool_idToObjDict__keys[index][i] = key;
                    darkPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    darkPool_idToObjDict__keys[index][i] = key;
                    darkPool_idToObjDict__values[index][i] = value;
                    darkPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        darkPool_idToObjDict_ExpandList(index);
        darkPool_idToObjDict__keys[index][preLen] = key;
        darkPool_idToObjDict__values[index][preLen] = value;
        darkPool_idToObjDict__size++;
        return true;
    }

    public void darkPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = darkPool_idToObjDict_Hash(key);
        var hashKeys = darkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    darkPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    darkPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject darkPool_idToObjDict_GetValue(int key)
    {
        int index = darkPool_idToObjDict_Hash(key);
        var hashKeys = darkPool_idToObjDict__keys[index];
        var hashValues = darkPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject darkPool_idToObjDict_TryGetValue(int key)
    {
        int index = darkPool_idToObjDict_Hash(key);
        var hashKeys = darkPool_idToObjDict__keys[index];
        var hashValues = darkPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void darkPool_idToObjDict_Remove(int key)
    {
        int index = darkPool_idToObjDict_Hash(key);
        var hashKeys = darkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    darkPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    darkPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int darkPool_Capacity = 100000;
    public bool darkPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        darkPool_itemOperator_col.enabled = active;
        darkPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    [SerializeField]
    int darkPool_itemOperator_capacity = 300000;
    void darkPool_itemOperator_Start()
    {
        darkPool_itemOperator_idToColDict_SetCapacity(darkPool_itemOperator_capacity);
        darkPool_itemOperator_idToMeshDict_SetCapacity(darkPool_itemOperator_capacity);
    }

    int[][] darkPool_itemOperator_idToColDict__keys;
    BoxCollider[][] darkPool_itemOperator_idToColDict__values;
    int darkPool_itemOperator_idToColDict__size;
    public int darkPool_itemOperator_idToColDict_Count => darkPool_itemOperator_idToColDict__size;

    public int[] darkPool_itemOperator_idToColDict_GenerateKeysArray()
    {
        int[] keys = new int[darkPool_itemOperator_idToColDict__size];
        int index = 0;
        for (int i = 0; i < darkPool_itemOperator_idToColDict__keys.Length; i++)
        {
            var hashKeys = darkPool_itemOperator_idToColDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int darkPool_itemOperator_idToColDict_bucketCount = 2;
    public int darkPool_itemOperator_idToColDict_KeyLength => darkPool_itemOperator_idToColDict__keys.Length;

    public void darkPool_itemOperator_idToColDict_SetCapacity(int capacity)
    {
        int len = darkPool_itemOperator_capacity / darkPool_itemOperator_idToColDict_bucketCount;
        darkPool_itemOperator_idToColDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            darkPool_itemOperator_idToColDict__keys[i] = new int[darkPool_itemOperator_idToColDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < darkPool_itemOperator_idToColDict_bucketCount; i++)
        {
            darkPool_itemOperator_idToColDict__keys[0][i] = int.MaxValue;
        }

        darkPool_itemOperator_idToColDict__values = new BoxCollider[len][];
        for (int i = 0; i < len; i++)
        {
            darkPool_itemOperator_idToColDict__values[i] = new BoxCollider[darkPool_itemOperator_idToColDict_bucketCount];
        }
    }

    public bool darkPool_itemOperator_idToColDict_HasItem(int key)
    {
        var index = darkPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = darkPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int darkPool_itemOperator_idToColDict_Hash(int key)
    {
        var len = darkPool_itemOperator_idToColDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool darkPool_itemOperator_idToColDict_Add(int key, BoxCollider value)
    {
        int index = darkPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = darkPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBoxColliderDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    darkPool_itemOperator_idToColDict__keys[index][i] = key;
                    darkPool_itemOperator_idToColDict__values[index][i] = value;
                    darkPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBoxColliderDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    darkPool_itemOperator_idToColDict__keys[index][i] = key;
                    darkPool_itemOperator_idToColDict__values[index][i] = value;
                    darkPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoxColliderDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        darkPool_itemOperator_idToColDict_ExpandList(index);
        darkPool_itemOperator_idToColDict__keys[index][preLen] = key;
        darkPool_itemOperator_idToColDict__values[index][preLen] = value;
        darkPool_itemOperator_idToColDict__size++;
        return true;
    }

    const int darkPool_itemOperator_idToColDict_expand = 10;
    void darkPool_itemOperator_idToColDict_ExpandList(int index)
    {
        var hashKeys = darkPool_itemOperator_idToColDict__keys[index];
        var hashValues = darkPool_itemOperator_idToColDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + darkPool_itemOperator_idToColDict_expand;
        var newKeys = new int[len];
        var newValues = new BoxCollider[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        darkPool_itemOperator_idToColDict__keys[index] = newKeys;
        darkPool_itemOperator_idToColDict__values[index] = newValues;
    }

    public bool darkPool_itemOperator_idToColDict_AddOrSetValue(int key, BoxCollider value)
    {
        int index = darkPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = darkPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    darkPool_itemOperator_idToColDict__keys[index][i] = key;
                    darkPool_itemOperator_idToColDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    darkPool_itemOperator_idToColDict__keys[index][i] = key;
                    darkPool_itemOperator_idToColDict__values[index][i] = value;
                    darkPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    darkPool_itemOperator_idToColDict__keys[index][i] = key;
                    darkPool_itemOperator_idToColDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    darkPool_itemOperator_idToColDict__keys[index][i] = key;
                    darkPool_itemOperator_idToColDict__values[index][i] = value;
                    darkPool_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoxColliderDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        darkPool_itemOperator_idToColDict_ExpandList(index);
        darkPool_itemOperator_idToColDict__keys[index][preLen] = key;
        darkPool_itemOperator_idToColDict__values[index][preLen] = value;
        darkPool_itemOperator_idToColDict__size++;
        return true;
    }

    public void darkPool_itemOperator_idToColDict_SetValue(int key, BoxCollider value)
    {
        int index = darkPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = darkPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    darkPool_itemOperator_idToColDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    darkPool_itemOperator_idToColDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public BoxCollider darkPool_itemOperator_idToColDict_GetValue(int key)
    {
        int index = darkPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = darkPool_itemOperator_idToColDict__keys[index];
        var hashValues = darkPool_itemOperator_idToColDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void darkPool_itemOperator_idToColDict_Remove(int key)
    {
        int index = darkPool_itemOperator_idToColDict_Hash(key);
        var hashKeys = darkPool_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    darkPool_itemOperator_idToColDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    darkPool_itemOperator_idToColDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    int[][] darkPool_itemOperator_idToMeshDict__keys;
    MeshRenderer[][] darkPool_itemOperator_idToMeshDict__values;
    int darkPool_itemOperator_idToMeshDict__size;
    public int darkPool_itemOperator_idToMeshDict_Count => darkPool_itemOperator_idToMeshDict__size;

    public int[] darkPool_itemOperator_idToMeshDict_GenerateKeysArray()
    {
        int[] keys = new int[darkPool_itemOperator_idToMeshDict__size];
        int index = 0;
        for (int i = 0; i < darkPool_itemOperator_idToMeshDict__keys.Length; i++)
        {
            var hashKeys = darkPool_itemOperator_idToMeshDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int darkPool_itemOperator_idToMeshDict_bucketCount = 2;
    public int darkPool_itemOperator_idToMeshDict_KeyLength => darkPool_itemOperator_idToMeshDict__keys.Length;

    public void darkPool_itemOperator_idToMeshDict_SetCapacity(int capacity)
    {
        int len = darkPool_itemOperator_capacity / darkPool_itemOperator_idToMeshDict_bucketCount;
        darkPool_itemOperator_idToMeshDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            darkPool_itemOperator_idToMeshDict__keys[i] = new int[darkPool_itemOperator_idToMeshDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < darkPool_itemOperator_idToMeshDict_bucketCount; i++)
        {
            darkPool_itemOperator_idToMeshDict__keys[0][i] = int.MaxValue;
        }

        darkPool_itemOperator_idToMeshDict__values = new MeshRenderer[len][];
        for (int i = 0; i < len; i++)
        {
            darkPool_itemOperator_idToMeshDict__values[i] = new MeshRenderer[darkPool_itemOperator_idToMeshDict_bucketCount];
        }
    }

    public bool darkPool_itemOperator_idToMeshDict_HasItem(int key)
    {
        var index = darkPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = darkPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int darkPool_itemOperator_idToMeshDict_Hash(int key)
    {
        var len = darkPool_itemOperator_idToMeshDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool darkPool_itemOperator_idToMeshDict_Add(int key, MeshRenderer value)
    {
        int index = darkPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = darkPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyMeshRendererDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    darkPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    darkPool_itemOperator_idToMeshDict__values[index][i] = value;
                    darkPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyMeshRendererDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    darkPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    darkPool_itemOperator_idToMeshDict__values[index][i] = value;
                    darkPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyMeshRendererDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        darkPool_itemOperator_idToMeshDict_ExpandList(index);
        darkPool_itemOperator_idToMeshDict__keys[index][preLen] = key;
        darkPool_itemOperator_idToMeshDict__values[index][preLen] = value;
        darkPool_itemOperator_idToMeshDict__size++;
        return true;
    }

    const int darkPool_itemOperator_idToMeshDict_expand = 10;
    void darkPool_itemOperator_idToMeshDict_ExpandList(int index)
    {
        var hashKeys = darkPool_itemOperator_idToMeshDict__keys[index];
        var hashValues = darkPool_itemOperator_idToMeshDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + darkPool_itemOperator_idToMeshDict_expand;
        var newKeys = new int[len];
        var newValues = new MeshRenderer[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        darkPool_itemOperator_idToMeshDict__keys[index] = newKeys;
        darkPool_itemOperator_idToMeshDict__values[index] = newValues;
    }

    public bool darkPool_itemOperator_idToMeshDict_AddOrSetValue(int key, MeshRenderer value)
    {
        int index = darkPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = darkPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    darkPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    darkPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    darkPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    darkPool_itemOperator_idToMeshDict__values[index][i] = value;
                    darkPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    darkPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    darkPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    darkPool_itemOperator_idToMeshDict__keys[index][i] = key;
                    darkPool_itemOperator_idToMeshDict__values[index][i] = value;
                    darkPool_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyMeshRendererDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        darkPool_itemOperator_idToMeshDict_ExpandList(index);
        darkPool_itemOperator_idToMeshDict__keys[index][preLen] = key;
        darkPool_itemOperator_idToMeshDict__values[index][preLen] = value;
        darkPool_itemOperator_idToMeshDict__size++;
        return true;
    }

    public void darkPool_itemOperator_idToMeshDict_SetValue(int key, MeshRenderer value)
    {
        int index = darkPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = darkPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    darkPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    darkPool_itemOperator_idToMeshDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public MeshRenderer darkPool_itemOperator_idToMeshDict_GetValue(int key)
    {
        int index = darkPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = darkPool_itemOperator_idToMeshDict__keys[index];
        var hashValues = darkPool_itemOperator_idToMeshDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void darkPool_itemOperator_idToMeshDict_Remove(int key)
    {
        int index = darkPool_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = darkPool_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    darkPool_itemOperator_idToMeshDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    darkPool_itemOperator_idToMeshDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    BoxCollider darkPool_itemOperator_col;
    MeshRenderer darkPool_itemOperator_mesh;
    public bool darkPool_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        if (darkPool_itemOperator_idToColDict_HasItem(instanceID))
        {
            darkPool_itemOperator_col = darkPool_itemOperator_idToColDict_GetValue(instanceID);
        }
        else
        {
            darkPool_itemOperator_col = obj.GetComponent<BoxCollider>();
            darkPool_itemOperator_idToColDict_Add(instanceID, darkPool_itemOperator_col);
        }

        if (darkPool_itemOperator_idToMeshDict_HasItem(instanceID))
        {
            darkPool_itemOperator_mesh = darkPool_itemOperator_idToMeshDict_GetValue(instanceID);
        }
        else
        {
            darkPool_itemOperator_mesh = obj.GetComponent<MeshRenderer>();
            darkPool_itemOperator_idToMeshDict_Add(instanceID, darkPool_itemOperator_mesh);
        }

        darkPool_itemOperator_col.enabled = active;
        darkPool_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool darkPool_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (darkPool_itemOperator_col == null || darkPool_itemOperator_mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return darkPool_itemOperator_col.enabled && darkPool_itemOperator_mesh.enabled;
    }

    int darkPool_poolSize;
    private int[] darkPool_notActiveObjQueue__array;
    private int darkPool_notActiveObjQueue__head; // First valid element in the queue.
    private int darkPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int darkPool_notActiveObjQueue__size; // Number of elements.
    private int darkPool_notActiveObjQueue__version;
    private const int darkPool_notActiveObjQueue_MinimumGrow = 100000;
    public int darkPool_notActiveObjQueue_Count => darkPool_notActiveObjQueue__size;
    public int darkPool_notActiveObjQueue_Version => darkPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int darkPool_notActiveObjQueue_GetCount() => darkPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int darkPool_notActiveObjQueue_GetVersion() => darkPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void darkPool_notActiveObjQueue_Clear()
    {
        if (darkPool_notActiveObjQueue__size != 0)
        {
            if (darkPool_notActiveObjQueue__head < darkPool_notActiveObjQueue__tail)
            {
                Array.Clear(darkPool_notActiveObjQueue__array, darkPool_notActiveObjQueue__head, darkPool_notActiveObjQueue__size);
            }
            else
            {
                Array.Clear(darkPool_notActiveObjQueue__array, darkPool_notActiveObjQueue__head, darkPool_notActiveObjQueue__array.Length - darkPool_notActiveObjQueue__head);
                Array.Clear(darkPool_notActiveObjQueue__array, 0, darkPool_notActiveObjQueue__tail);
            }

            darkPool_notActiveObjQueue__size = 0;
        }

        darkPool_notActiveObjQueue__head = 0;
        darkPool_notActiveObjQueue__tail = 0;
        darkPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void darkPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < darkPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = darkPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = darkPool_notActiveObjQueue__array.Length - darkPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(darkPool_notActiveObjQueue__array, darkPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(darkPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void darkPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (darkPool_notActiveObjQueue__array == null)
        {
            darkPool_notActiveObjQueue_SetCapacity(darkPool_notActiveObjQueue_MinimumGrow);
        }
        else if (darkPool_notActiveObjQueue__size == darkPool_notActiveObjQueue__array.Length)
        {
            darkPool_notActiveObjQueue_SetCapacity(darkPool_notActiveObjQueue__array.Length + darkPool_notActiveObjQueue_MinimumGrow);
        }

        darkPool_notActiveObjQueue__array[darkPool_notActiveObjQueue__tail] = obj;
        darkPool_notActiveObjQueue__tail = (darkPool_notActiveObjQueue__tail + 1) % darkPool_notActiveObjQueue__array.Length;
        darkPool_notActiveObjQueue__size++;
        darkPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int darkPool_notActiveObjQueue_Dequeue()
    {
        if (darkPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = darkPool_notActiveObjQueue__array[darkPool_notActiveObjQueue__head];
        darkPool_notActiveObjQueue__array[darkPool_notActiveObjQueue__head] = int.MaxValue;
        darkPool_notActiveObjQueue__head = (darkPool_notActiveObjQueue__head + 1) % darkPool_notActiveObjQueue__array.Length;
        darkPool_notActiveObjQueue__size--;
        darkPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int darkPool_notActiveObjQueue_Peek()
    {
        if (darkPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return darkPool_notActiveObjQueue__array[darkPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] darkPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[darkPool_notActiveObjQueue__size];
        if (darkPool_notActiveObjQueue__size == 0)
        {
        }
        else if (darkPool_notActiveObjQueue__head < darkPool_notActiveObjQueue__tail)
        {
            Array.Copy(darkPool_notActiveObjQueue__array, darkPool_notActiveObjQueue__head, arr, 0, darkPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = darkPool_notActiveObjQueue__array.Length - darkPool_notActiveObjQueue__head;
            Array.Copy(darkPool_notActiveObjQueue__array, darkPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(darkPool_notActiveObjQueue__array, 0, arr, toHead, darkPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void darkPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (darkPool_notActiveObjQueue__size == 0)
        {
        }
        else if (darkPool_notActiveObjQueue__head < darkPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(darkPool_notActiveObjQueue__array, darkPool_notActiveObjQueue__head, newArray, 0, darkPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = darkPool_notActiveObjQueue__array.Length - darkPool_notActiveObjQueue__head;
            Array.Copy(darkPool_notActiveObjQueue__array, darkPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(darkPool_notActiveObjQueue__array, 0, newArray, toHead, darkPool_notActiveObjQueue__tail);
        }

        darkPool_notActiveObjQueue__array = newArray;
        darkPool_notActiveObjQueue__head = 0;
        darkPool_notActiveObjQueue__tail = darkPool_notActiveObjQueue__size == capacity ? 0 : darkPool_notActiveObjQueue__size;
        darkPool_notActiveObjQueue__version++;
    }

    [SerializeField]
    Transform darkPool_parent;
    void darkPool_Start()
    {
        darkPool_itemOperator_Start();
        darkPool_prefabName = darkPool_prefab.name;
        darkPool_idToObjDict_SetCapacity(darkPool_Capacity);
        darkPool_notActiveObjQueue_SetCapacity(darkPool_Capacity);
    }

    public bool darkPool_PeekIsInstantiated()
    {
        return darkPool_isInstantiated;
    }

    bool darkPool_isInstantiated = false;
    public void darkPool_Store(Transform p = null)
    {
        if (darkPool_idToObjDict_Count > darkPool_idToObjDict_KeyLength)
            return;
        darkPool_isInstantiated = true;
        GameObject instance;
        int id;
        darkPool_instance = GameObject.Instantiate(darkPool_prefab);
        //gc alloc debug only
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        //id = GetInstanceID(instance);/*instance.GetInstanceID();*///.GetHashCode();
        id = darkPool_instance.GetInstanceID();
        darkPool_itemOperator_SetActive(darkPool_instance, id, false);
        darkPool_idToObjDict_Add(id, darkPool_instance);
        darkPool_notActiveObjQueue_Enqueue(id);
    }

    string darkPool_prefabName;
    GameObject darkPool_instance;
    // falseで出してmeshcombinerで切り替える
    int darkPool_uniqueId = 0;
    public GameObject darkPool_TryToSpawn()
    {
        int id;
        darkPool_isInstantiated = true;
        if (darkPool_notActiveObjQueue_Count > 0)
        {
            darkPool_isInstantiated = false;
            id = darkPool_notActiveObjQueue_Dequeue();
            if (darkPool_idToObjDict_HasItem(id))
            {
                var obj = darkPool_idToObjDict_GetValue(id);
                //itemOperator.SetActive(obj,id,true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        darkPool_instance = GameObject.Instantiate(darkPool_prefab);
        //gc alloc
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        id = darkPool_instance.GetInstanceID();
        darkPool_idToObjDict_Add(id, darkPool_instance); // gc alloc
        //itemOperator.SetActive(instance,id,true);
        //}while(!idToObjDict.Add(id,instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return darkPool_instance;
    }

    public GameObject darkPool_TryToSpawn(int id)
    {
        darkPool_isInstantiated = false;
        if (darkPool_idToObjDict_HasItem(id))
        {
            var obj = darkPool_idToObjDict_GetValue(id);
            darkPool_itemOperator_SetActive(obj, id, false);
            return obj;
        }
        else
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return null;
        }
    }

    public void darkPool_Return(GameObject obj, bool force = false, bool enqueue = true)
    {
        // gc alloc debug only
        //if(obj==null)return; // gc alloc debug only
        int id = obj.GetInstanceID(); //obj.GetInstanceID();
        if (!darkPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        darkPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            darkPool_notActiveObjQueue_Enqueue(id);
    }

    public void darkPool_Return(GameObject obj, int id, bool force = false, bool enqueue = true)
    {
        //if(obj==null)return; // gc alloc debug only
        if (!darkPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        darkPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            darkPool_notActiveObjQueue_Enqueue(id);
    }

    public bool darkPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(darkPool_prefab.name);
    }

    public void darkPool_Clear()
    {
        darkPool_notActiveObjQueue_Clear();
        foreach (var obj in darkPool_idToObjDict_GenerateKeysArray())
        {
            darkPool_itemOperator_SetActive(darkPool_idToObjDict_GetValue(obj), false);
            darkPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    public int settings_chunkSize = 3;
    public int settings_chunkSizeY = 3;
    public int settings_batchCount = 1000;
    public int settings_chunkWidth = 100;
    public int settings_chunkDepth = 100;
    public int settings_fieldHeight = 3;
    public float settings_scale = 0.015f;
    public float settings_scaleT = 0.003f;
    public float settings_scaleH = 0.003f;
    public float settings_cellAnimationTime = 1f;
    public float settings_TileScale = 1.5f;
    public float settings_chunkLoadRange = 6f;
    public float settings_chunkUnLoadRange = 12f;
    public float settings_chunkDetailRange = 1f;
    public float settings_generateAdditionalInterval = 5f;
    public float settings_searchAdditionalInterval = 3f;
    public float settings_removeBatchCount = 100;
    public float settings_removeInterval = 0.1f;
    public float settings_waterPercentage = 0.2f;
    public int settings_operationBatchCount = 1;
    public int settings_searchBatchCount = 30;
    public bool settings_removeOn = true;
    public bool settings_searchOn = true;
    Biome[][] biomeMap = new Biome[][]
    {
        new Biome[]
        {
            Biome.Dirt,
            Biome.Dirt,
            Biome.Dark,
            Biome.Dark,
            Biome.Rock
        },
        new Biome[]
        {
            Biome.Dirt,
            Biome.Dirt,
            Biome.Dark,
            Biome.Grass,
            Biome.Rock
        },
        new Biome[]
        {
            Biome.Tundra,
            Biome.Dark,
            Biome.Grass,
            Biome.Rock,
            Biome.Sand
        },
        new Biome[]
        {
            Biome.Tundra,
            Biome.Grass,
            Biome.Rock,
            Biome.Desert,
            Biome.Sand
        },
        new Biome[]
        {
            Biome.Tundra,
            Biome.Grass,
            Biome.Desert,
            Biome.Desert,
            Biome.Sand
        },
    };
    bool BiomePeekIsInstantiated(Biome biome)
    {
        switch (biome)
        {
            case Biome.Grass:
                return grassPool_PeekIsInstantiated();
            case Biome.Tundra:
                return tundraPool_PeekIsInstantiated();
            case Biome.Desert:
                return desertPool_PeekIsInstantiated();
            case Biome.Rock:
                return rockPool_PeekIsInstantiated();
            case Biome.Sand:
                return sandPool_PeekIsInstantiated();
            case Biome.Water:
                return waterPool_PeekIsInstantiated();
            case Biome.Dirt:
                return dirtPool_PeekIsInstantiated();
            case Biome.Dark:
                return darkPool_PeekIsInstantiated();
            default:
                Debug.LogError("Invalid biome: " + biome);
                return false;
        }
    }

    GameObject BiomeTryToSpawn(Biome biome)
    {
        switch (biome)
        {
            case Biome.Grass:
                return grassPool_TryToSpawn();
            case Biome.Tundra:
                return tundraPool_TryToSpawn();
            case Biome.Desert:
                return desertPool_TryToSpawn();
            case Biome.Rock:
                return rockPool_TryToSpawn();
            case Biome.Sand:
                return sandPool_TryToSpawn();
            case Biome.Water:
                return waterPool_TryToSpawn();
            case Biome.Dirt:
                return dirtPool_TryToSpawn();
            case Biome.Dark:
                return darkPool_TryToSpawn();
            default:
                Debug.LogError("Invalid biome: " + biome);
                return null;
        }
    }

    void BiomeReturn(Biome biome, GameObject cell, int id)
    {
        switch (biome)
        {
            case Biome.Grass:
                grassPool_Return(cell, id);
                return;
            case Biome.Tundra:
                tundraPool_Return(cell, id);
                return;
            case Biome.Desert:
                desertPool_Return(cell, id);
                return;
            case Biome.Rock:
                rockPool_Return(cell, id);
                return;
            case Biome.Sand:
                sandPool_Return(cell, id);
                return;
            case Biome.Water:
                waterPool_Return(cell, id);
                return;
            case Biome.Dirt:
                dirtPool_Return(cell, id);
                return;
            case Biome.Dark:
                darkPool_Return(cell, id);
                return;
            default:
                Debug.LogError("Invalid biome: " + biome);
                return;
        }
    }

    void BiomeStore(int biomeIndex)
    {
        switch (biomeIndex)
        {
            case (int)Biome.Grass:
                grassPool_Store();
                return;
            case (int)Biome.Tundra:
                tundraPool_Store();
                return;
            case (int)Biome.Desert:
                desertPool_Store();
                return;
            case (int)Biome.Rock:
                rockPool_Store();
                return;
            case (int)Biome.Sand:
                sandPool_Store();
                return;
            case (int)Biome.Water:
                waterPool_Store();
                return;
            case (int)Biome.Dirt:
                dirtPool_Store();
                return;
            case (int)Biome.Dark:
                darkPool_Store();
                return;
            default:
                Debug.LogError("Invalid biome: " + biomeIndex);
                return;
        }
    }

    bool BiomePeekIsInstantiated(int biomeIndex)
    {
        switch (biomeIndex)
        {
            case (int)Biome.Grass:
                return grassPool_PeekIsInstantiated();
            case (int)Biome.Tundra:
                return tundraPool_PeekIsInstantiated();
            case (int)Biome.Desert:
                return desertPool_PeekIsInstantiated();
            case (int)Biome.Rock:
                return rockPool_PeekIsInstantiated();
            case (int)Biome.Sand:
                return sandPool_PeekIsInstantiated();
            case (int)Biome.Water:
                return waterPool_PeekIsInstantiated();
            case (int)Biome.Dirt:
                return dirtPool_PeekIsInstantiated();
            case (int)Biome.Dark:
                return darkPool_PeekIsInstantiated();
            default:
                Debug.LogError("Invalid biome: " + biomeIndex);
                return false;
        }
    }

    int chunkSize => settings_chunkSize;

    int chunkSizeY => settings_chunkSizeY;

    int chunkWidth => settings_chunkWidth;

    int chunkDepth => settings_chunkDepth;

    int fieldHeight => settings_fieldHeight;

    int xStartChunkIndex, zStartChunkIndex;
    int xEndChunkIndex, zEndChunkIndex;
    int xSearchStartChunkIndex, zSearchStartChunkIndex;
    int xSearchEndChunkIndex, zSearchEndChunkIndex;
    int xQuickSearchStartChunkIndex, zQuickSearchStartChunkIndex;
    int xQuickSearchEndChunkIndex, zQuickSearchEndChunkIndex;
    int batchCount => settings_batchCount;

    float chunkLoadRange => settings_chunkLoadRange;

    float generateAdditionalInterval => settings_generateAdditionalInterval * 2.5f / Networking.LocalPlayer.GetWalkSpeed();

    float cellAnimationTime => settings_cellAnimationTime;

    float removeBatchCount => settings_removeBatchCount;

    float removeInterval => settings_removeInterval;

    float waterPercentage => settings_waterPercentage;

    float chunkUnLoadRange => settings_chunkUnLoadRange;

    float chunkDetailRange => settings_chunkDetailRange;

    float operationBatchCount => settings_operationBatchCount;

    [SerializeField]
    int chunkCapacity = 15000;
    public override void OnDeserialization()
    {
        isSynced = true;
    }

    bool isSynced = false;
    void Assert(bool b)
    {
        if (!b)
        {
            Debug.LogError("Assertion failed!");
        }
    }

    int[] detailChunkCellInstanceIds;
    int[][] detailOperationDictionary__keys;
    bool[][] detailOperationDictionary__values;
    int detailOperationDictionary__size;
    public int detailOperationDictionary_Count => detailOperationDictionary__size;

    public int[] detailOperationDictionary_GenerateKeysArray()
    {
        int[] keys = new int[detailOperationDictionary__size];
        int index = 0;
        for (int i = 0; i < detailOperationDictionary__keys.Length; i++)
        {
            var hashKeys = detailOperationDictionary__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int detailOperationDictionary_bucketCount = 2;
    public void detailOperationDictionary_SetCapacity(int capacity)
    {
        int len = capacity / detailOperationDictionary_bucketCount;
        detailOperationDictionary__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            detailOperationDictionary__keys[i] = new int[detailOperationDictionary_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < detailOperationDictionary_bucketCount; i++)
        {
            detailOperationDictionary__keys[0][i] = int.MaxValue;
        }

        detailOperationDictionary__values = new bool[len][];
        for (int i = 0; i < len; i++)
        {
            detailOperationDictionary__values[i] = new bool[detailOperationDictionary_bucketCount];
        }
    }

    public bool detailOperationDictionary_HasItem(int key)
    {
        var index = detailOperationDictionary_Hash(key);
        var hashKeys = detailOperationDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int detailOperationDictionary_Hash(int key)
    {
        var len = detailOperationDictionary__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool detailOperationDictionary_Add(int key, bool value)
    {
        int index = detailOperationDictionary_Hash(key);
        var hashKeys = detailOperationDictionary__keys[index];
        if (key == int.MaxValue)
        {
            Debug.LogError("not allowed key value");
        }

        if (index == 0)
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    detailOperationDictionary__keys[index][i] = key;
                    detailOperationDictionary__values[index][i] = value;
                    detailOperationDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    detailOperationDictionary__keys[index][i] = key;
                    detailOperationDictionary__values[index][i] = value;
                    detailOperationDictionary__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoolDictionary Add: Dictionary is full");
        var preLen = hashKeys.Length;
        detailOperationDictionary_ExpandList(index);
        detailOperationDictionary__keys[index][preLen] = key;
        detailOperationDictionary__values[index][preLen] = value;
        detailOperationDictionary__size++;
        return true;
    }

    const int detailOperationDictionary_expand = 10;
    void detailOperationDictionary_ExpandList(int index)
    {
        var hashKeys = detailOperationDictionary__keys[index];
        var hashValues = detailOperationDictionary__values[index];
        var len = detailOperationDictionary__keys[index].Length + detailOperationDictionary_expand;
        var newKeys = new int[len];
        var newValues = new bool[len];
        for (int i = 0; i < detailOperationDictionary__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = detailOperationDictionary__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        detailOperationDictionary__keys[index] = newKeys;
        detailOperationDictionary__values[index] = newValues;
    }

    public bool detailOperationDictionary_AddOrSetValue(int key, bool value)
    {
        int index = detailOperationDictionary_Hash(key);
        var hashKeys = detailOperationDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    detailOperationDictionary__keys[index][i] = key;
                    detailOperationDictionary__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    detailOperationDictionary__keys[index][i] = key;
                    detailOperationDictionary__values[index][i] = value;
                    detailOperationDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    detailOperationDictionary__keys[index][i] = key;
                    detailOperationDictionary__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    detailOperationDictionary__keys[index][i] = key;
                    detailOperationDictionary__values[index][i] = value;
                    detailOperationDictionary__size++;
                    return true;
                }
            }
        }

        //Debug.LogError("InkEyBoolDictionary AddOrSetValue: Dictionary is full");
        //return false;
        var preLen = hashKeys.Length;
        detailOperationDictionary_ExpandList(index);
        detailOperationDictionary__keys[index][preLen] = key;
        detailOperationDictionary__values[index][preLen] = value;
        detailOperationDictionary__size++;
        return true;
    }

    public void detailOperationDictionary_SetValue(int key, bool value)
    {
        int index = detailOperationDictionary_Hash(key);
        var hashKeys = detailOperationDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    detailOperationDictionary__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    detailOperationDictionary__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public bool detailOperationDictionary_GetValueOrDefault(int key, bool defaultValue)
    {
        int index = detailOperationDictionary_Hash(key);
        var hashKeys = detailOperationDictionary__keys[index];
        var hashValues = detailOperationDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return defaultValue;
    }

    public bool detailOperationDictionary_GetValue(int key)
    {
        int index = detailOperationDictionary_Hash(key);
        var hashKeys = detailOperationDictionary__keys[index];
        var hashValues = detailOperationDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void detailOperationDictionary_TryRemoveBatch(int[] keys, bool[] result)
    {
        for (int i = 0; i < keys.Length; i++)
        {
            result[i] = detailOperationDictionary_TryRemove(keys[i]);
        }
    }

    public bool detailOperationDictionary_TryRemove(int key)
    {
        int index = detailOperationDictionary_Hash(key);
        var hashKeys = detailOperationDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    detailOperationDictionary__size--;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    detailOperationDictionary__size--;
                    return true;
                }
            }
        }

        return false;
    }

    public void detailOperationDictionary_Remove(int key)
    {
        if (!detailOperationDictionary_TryRemove(key))
            Debug.LogError("Key not found");
    }

    int[][] unloadOperationDictionary__keys;
    bool[][] unloadOperationDictionary__values;
    int unloadOperationDictionary__size;
    public int unloadOperationDictionary_Count => unloadOperationDictionary__size;

    public int[] unloadOperationDictionary_GenerateKeysArray()
    {
        int[] keys = new int[unloadOperationDictionary__size];
        int index = 0;
        for (int i = 0; i < unloadOperationDictionary__keys.Length; i++)
        {
            var hashKeys = unloadOperationDictionary__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int unloadOperationDictionary_bucketCount = 2;
    public void unloadOperationDictionary_SetCapacity(int capacity)
    {
        int len = capacity / unloadOperationDictionary_bucketCount;
        unloadOperationDictionary__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            unloadOperationDictionary__keys[i] = new int[unloadOperationDictionary_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < unloadOperationDictionary_bucketCount; i++)
        {
            unloadOperationDictionary__keys[0][i] = int.MaxValue;
        }

        unloadOperationDictionary__values = new bool[len][];
        for (int i = 0; i < len; i++)
        {
            unloadOperationDictionary__values[i] = new bool[unloadOperationDictionary_bucketCount];
        }
    }

    public bool unloadOperationDictionary_HasItem(int key)
    {
        var index = unloadOperationDictionary_Hash(key);
        var hashKeys = unloadOperationDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int unloadOperationDictionary_Hash(int key)
    {
        var len = unloadOperationDictionary__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool unloadOperationDictionary_Add(int key, bool value)
    {
        int index = unloadOperationDictionary_Hash(key);
        var hashKeys = unloadOperationDictionary__keys[index];
        if (key == int.MaxValue)
        {
            Debug.LogError("not allowed key value");
        }

        if (index == 0)
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    unloadOperationDictionary__keys[index][i] = key;
                    unloadOperationDictionary__values[index][i] = value;
                    unloadOperationDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    unloadOperationDictionary__keys[index][i] = key;
                    unloadOperationDictionary__values[index][i] = value;
                    unloadOperationDictionary__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoolDictionary Add: Dictionary is full");
        var preLen = hashKeys.Length;
        unloadOperationDictionary_ExpandList(index);
        unloadOperationDictionary__keys[index][preLen] = key;
        unloadOperationDictionary__values[index][preLen] = value;
        unloadOperationDictionary__size++;
        return true;
    }

    const int unloadOperationDictionary_expand = 10;
    void unloadOperationDictionary_ExpandList(int index)
    {
        var hashKeys = unloadOperationDictionary__keys[index];
        var hashValues = unloadOperationDictionary__values[index];
        var len = unloadOperationDictionary__keys[index].Length + unloadOperationDictionary_expand;
        var newKeys = new int[len];
        var newValues = new bool[len];
        for (int i = 0; i < unloadOperationDictionary__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = unloadOperationDictionary__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        unloadOperationDictionary__keys[index] = newKeys;
        unloadOperationDictionary__values[index] = newValues;
    }

    public bool unloadOperationDictionary_AddOrSetValue(int key, bool value)
    {
        int index = unloadOperationDictionary_Hash(key);
        var hashKeys = unloadOperationDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    unloadOperationDictionary__keys[index][i] = key;
                    unloadOperationDictionary__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    unloadOperationDictionary__keys[index][i] = key;
                    unloadOperationDictionary__values[index][i] = value;
                    unloadOperationDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    unloadOperationDictionary__keys[index][i] = key;
                    unloadOperationDictionary__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    unloadOperationDictionary__keys[index][i] = key;
                    unloadOperationDictionary__values[index][i] = value;
                    unloadOperationDictionary__size++;
                    return true;
                }
            }
        }

        //Debug.LogError("InkEyBoolDictionary AddOrSetValue: Dictionary is full");
        //return false;
        var preLen = hashKeys.Length;
        unloadOperationDictionary_ExpandList(index);
        unloadOperationDictionary__keys[index][preLen] = key;
        unloadOperationDictionary__values[index][preLen] = value;
        unloadOperationDictionary__size++;
        return true;
    }

    public void unloadOperationDictionary_SetValue(int key, bool value)
    {
        int index = unloadOperationDictionary_Hash(key);
        var hashKeys = unloadOperationDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    unloadOperationDictionary__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    unloadOperationDictionary__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public bool unloadOperationDictionary_GetValueOrDefault(int key, bool defaultValue)
    {
        int index = unloadOperationDictionary_Hash(key);
        var hashKeys = unloadOperationDictionary__keys[index];
        var hashValues = unloadOperationDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return defaultValue;
    }

    public bool unloadOperationDictionary_GetValue(int key)
    {
        int index = unloadOperationDictionary_Hash(key);
        var hashKeys = unloadOperationDictionary__keys[index];
        var hashValues = unloadOperationDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void unloadOperationDictionary_TryRemoveBatch(int[] keys, bool[] result)
    {
        for (int i = 0; i < keys.Length; i++)
        {
            result[i] = unloadOperationDictionary_TryRemove(keys[i]);
        }
    }

    public bool unloadOperationDictionary_TryRemove(int key)
    {
        int index = unloadOperationDictionary_Hash(key);
        var hashKeys = unloadOperationDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    unloadOperationDictionary__size--;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    unloadOperationDictionary__size--;
                    return true;
                }
            }
        }

        return false;
    }

    public void unloadOperationDictionary_Remove(int key)
    {
        if (!unloadOperationDictionary_TryRemove(key))
            Debug.LogError("Key not found");
    }

    int[][] chunkIndexToInstanceIdDictionary__keys;
    int[][] chunkIndexToInstanceIdDictionary__values;
    int chunkIndexToInstanceIdDictionary__size;
    public int chunkIndexToInstanceIdDictionary_Count => chunkIndexToInstanceIdDictionary__size;

    const int chunkIndexToInstanceIdDictionary_bucketCount = 2;
    public void chunkIndexToInstanceIdDictionary_SetCapacity(int capacity)
    {
        int len = capacity / chunkIndexToInstanceIdDictionary_bucketCount;
        chunkIndexToInstanceIdDictionary__keys = new int[len][];
        for (int i = 0; i < chunkIndexToInstanceIdDictionary__keys.Length; i++)
        {
            chunkIndexToInstanceIdDictionary__keys[i] = new int[chunkIndexToInstanceIdDictionary_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < chunkIndexToInstanceIdDictionary_bucketCount; i++)
        {
            chunkIndexToInstanceIdDictionary__keys[0][i] = int.MaxValue;
        }

        chunkIndexToInstanceIdDictionary__values = new int[len][];
        for (int i = 0; i < chunkIndexToInstanceIdDictionary__values.Length; i++)
        {
            chunkIndexToInstanceIdDictionary__values[i] = new int[chunkIndexToInstanceIdDictionary_bucketCount];
        }
    }

    public bool chunkIndexToInstanceIdDictionary_HasItem(int key)
    {
        var index = chunkIndexToInstanceIdDictionary_Hash(key);
        var hashKeys = chunkIndexToInstanceIdDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int chunkIndexToInstanceIdDictionary_Hash(int key)
    {
        var len = chunkIndexToInstanceIdDictionary__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public int[] chunkIndexToInstanceIdDictionary_GenerateKeysArray()
    {
        int[] keys = new int[chunkIndexToInstanceIdDictionary__size];
        int index = 0;
        for (int i = 0; i < chunkIndexToInstanceIdDictionary__keys.Length; i++)
        {
            var hashKeys = chunkIndexToInstanceIdDictionary__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    public bool chunkIndexToInstanceIdDictionary_Add(int key, int value)
    {
        int index = chunkIndexToInstanceIdDictionary_Hash(key);
        var hashKeys = chunkIndexToInstanceIdDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyintArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkIndexToInstanceIdDictionary__keys[index][i] = key;
                    chunkIndexToInstanceIdDictionary__values[index][i] = value;
                    chunkIndexToInstanceIdDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyintArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    chunkIndexToInstanceIdDictionary__keys[index][i] = key;
                    chunkIndexToInstanceIdDictionary__values[index][i] = value;
                    chunkIndexToInstanceIdDictionary__size++;
                    return true;
                }
            }
        }

        chunkIndexToInstanceIdDictionary_ExpandList(index);
        var preLen = hashKeys.Length;
        chunkIndexToInstanceIdDictionary__keys[index][preLen] = key;
        chunkIndexToInstanceIdDictionary__values[index][preLen] = value;
        chunkIndexToInstanceIdDictionary__size++;
        return true;
    }

    const int chunkIndexToInstanceIdDictionary_expand = 10;
    void chunkIndexToInstanceIdDictionary_ExpandList(int index)
    {
        var hashKeys = chunkIndexToInstanceIdDictionary__keys[index];
        var hashValues = chunkIndexToInstanceIdDictionary__values[index];
        var len = chunkIndexToInstanceIdDictionary__keys[index].Length + chunkIndexToInstanceIdDictionary_expand;
        var newKeys = new int[len];
        var newValues = new int[len];
        for (int i = 0; i < chunkIndexToInstanceIdDictionary__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = chunkIndexToInstanceIdDictionary__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        chunkIndexToInstanceIdDictionary__keys[index] = newKeys;
        chunkIndexToInstanceIdDictionary__values[index] = newValues;
    }

    public void chunkIndexToInstanceIdDictionary_AddOrSetValue(int key, int value)
    {
        int index = chunkIndexToInstanceIdDictionary_Hash(key);
        var hashKeys = chunkIndexToInstanceIdDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkIndexToInstanceIdDictionary__keys[index][i] = key;
                    chunkIndexToInstanceIdDictionary__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkIndexToInstanceIdDictionary__keys[index][i] = key;
                    chunkIndexToInstanceIdDictionary__values[index][i] = value;
                    chunkIndexToInstanceIdDictionary__size++;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkIndexToInstanceIdDictionary__keys[index][i] = key;
                    chunkIndexToInstanceIdDictionary__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == default)
                {
                    chunkIndexToInstanceIdDictionary__keys[index][i] = key;
                    chunkIndexToInstanceIdDictionary__values[index][i] = value;
                    chunkIndexToInstanceIdDictionary__size++;
                    return;
                }
            }
        }

        var preLen = hashKeys.Length;
        chunkIndexToInstanceIdDictionary_ExpandList(index);
        chunkIndexToInstanceIdDictionary__keys[index][preLen] = key;
        chunkIndexToInstanceIdDictionary__values[index][preLen] = value;
        chunkIndexToInstanceIdDictionary__size++;
    }

    public void chunkIndexToInstanceIdDictionary_SetValue(int key, int value)
    {
        int index = chunkIndexToInstanceIdDictionary_Hash(key);
        var hashKeys = chunkIndexToInstanceIdDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkIndexToInstanceIdDictionary__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkIndexToInstanceIdDictionary__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public int chunkIndexToInstanceIdDictionary_GetValue(int key)
    {
        int index = chunkIndexToInstanceIdDictionary_Hash(key);
        var hashKeys = chunkIndexToInstanceIdDictionary__keys[index];
        var hashValues = chunkIndexToInstanceIdDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public int chunkIndexToInstanceIdDictionary_GetValueOrDefault(int key, int defaultValue)
    {
        int index = chunkIndexToInstanceIdDictionary_Hash(key);
        var hashKeys = chunkIndexToInstanceIdDictionary__keys[index];
        var hashValues = chunkIndexToInstanceIdDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return defaultValue;
    }

    public void chunkIndexToInstanceIdDictionary_Remove(int key)
    {
        int index = chunkIndexToInstanceIdDictionary_Hash(key);
        var hashKeys = chunkIndexToInstanceIdDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    chunkIndexToInstanceIdDictionary__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    chunkIndexToInstanceIdDictionary__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    void Start()
    {
        chunkPool_Start();
        meshCombiner_Start();
        darkPool_Start();
        waterPool_Start();
        sandPool_Start();
        rockPool_Start();
        dirtPool_Start();
        desertPool_Start();
        tundraPool_Start();
        grassPool_Start();
        outlineDict_SetCapacity(chunkCapacity);
        removedChunkIndexDict_SetCapacity(chunkCapacity);
        loadedChunkIndexDict_SetCapacity(chunkCapacity);
        chunkToCellsDict_SetCapacity(chunkCapacity);
        detailChunkIndexDict_SetCapacity(chunkCapacity);
        instanceIDToGlobalCellIndexDictionary_SetCapacity(100000);
        undetailQueue_SetCapacity(chunkCapacity);
        detailQueue_SetCapacity(chunkCapacity);
        priorityDetailQueue_SetCapacity(chunkCapacity);
        unloadQueue_SetCapacity(chunkCapacity);
        detailOperationDictionary_SetCapacity(100000);
        unloadOperationDictionary_SetCapacity(100000);
        chunkIndexToCellBiomesDictionary_SetCapacity(chunkCapacity);
        chunkToCellInstanceIdsDictionary_SetCapacity(chunkCapacity);
        permanentBreakCellDictionary_SetCapacity(chunkCapacity);
        chunkIndexToInstanceIdDictionary_SetCapacity(chunkCapacity);
        brokenArr = new bool[chunkSize * chunkSize * chunkSizeY];
        _seedX = UnityEngine.Random.value * (float)Int16.MaxValue;
        _seedZ = UnityEngine.Random.value * (float)Int16.MaxValue;
        _seedTX = UnityEngine.Random.value * (float)Int16.MaxValue;
        _seedTZ = UnityEngine.Random.value * (float)Int16.MaxValue;
        _seedHX = UnityEngine.Random.value * (float)Int16.MaxValue;
        _seedHZ = UnityEngine.Random.value * (float)Int16.MaxValue;
        isSynced = true;
        RequestSerialization();
        /*chunkWidth=settings.chunkWidth;
        chunkDepth=settings.chunkDepth;
        chunkSize=settings.chunkSize;
        batchCount=settings.batchCount;
        generateInterval=settings.generateInterval;
        chunkLoadRange=settings.chunkLoadRange;
        generateAdditionalInterval=settings.generateAdditionalInterval *2.5f / Networking.LocalPlayer.GetWalkSpeed();
        cellAnimationTime=settings.cellAnimationTime;*/
        meshFilters = new MeshFilter[chunkSize * chunkSize * chunkSizeY];
        detailChunkCellInstanceIds = new int[chunkSize * chunkSize * chunkSizeY];
        XSTARTINDEX = -chunkWidth / 2;
        XENDINDEX = chunkWidth - 1 - chunkWidth / 2;
        ZSTARTINDEX = 0;
        ZENDINDEX = chunkDepth;
    }

    int[][] chunkToCellInstanceIdsDictionary__keys;
    int[][][] chunkToCellInstanceIdsDictionary__values;
    int chunkToCellInstanceIdsDictionary__size;
    public int chunkToCellInstanceIdsDictionary_Count => chunkToCellInstanceIdsDictionary__size;

    const int chunkToCellInstanceIdsDictionary_bucketCount = 2;
    public void chunkToCellInstanceIdsDictionary_SetCapacity(int capacity)
    {
        int len = capacity / chunkToCellInstanceIdsDictionary_bucketCount;
        chunkToCellInstanceIdsDictionary__keys = new int[len][];
        for (int i = 0; i < chunkToCellInstanceIdsDictionary__keys.Length; i++)
        {
            chunkToCellInstanceIdsDictionary__keys[i] = new int[chunkToCellInstanceIdsDictionary_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < chunkToCellInstanceIdsDictionary_bucketCount; i++)
        {
            chunkToCellInstanceIdsDictionary__keys[0][i] = int.MaxValue;
        }

        chunkToCellInstanceIdsDictionary__values = new int[len][][];
        for (int i = 0; i < chunkToCellInstanceIdsDictionary__values.Length; i++)
        {
            chunkToCellInstanceIdsDictionary__values[i] = new int[chunkToCellInstanceIdsDictionary_bucketCount][];
        }
    }

    public bool chunkToCellInstanceIdsDictionary_HasItem(int key)
    {
        var index = chunkToCellInstanceIdsDictionary_Hash(key);
        var hashKeys = chunkToCellInstanceIdsDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int chunkToCellInstanceIdsDictionary_Hash(int key)
    {
        var len = chunkToCellInstanceIdsDictionary__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public int[] chunkToCellInstanceIdsDictionary_GenerateKeysArray()
    {
        int[] keys = new int[chunkToCellInstanceIdsDictionary__size];
        int index = 0;
        for (int i = 0; i < chunkToCellInstanceIdsDictionary__keys.Length; i++)
        {
            var hashKeys = chunkToCellInstanceIdsDictionary__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    public bool chunkToCellInstanceIdsDictionary_Add(int key, int[] value)
    {
        int index = chunkToCellInstanceIdsDictionary_Hash(key);
        var hashKeys = chunkToCellInstanceIdsDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyintArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkToCellInstanceIdsDictionary__keys[index][i] = key;
                    chunkToCellInstanceIdsDictionary__values[index][i] = value;
                    chunkToCellInstanceIdsDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyintArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    chunkToCellInstanceIdsDictionary__keys[index][i] = key;
                    chunkToCellInstanceIdsDictionary__values[index][i] = value;
                    chunkToCellInstanceIdsDictionary__size++;
                    return true;
                }
            }
        }

        chunkToCellInstanceIdsDictionary_ExpandList(index);
        var preLen = hashKeys.Length;
        chunkToCellInstanceIdsDictionary__keys[index][preLen] = key;
        chunkToCellInstanceIdsDictionary__values[index][preLen] = value;
        chunkToCellInstanceIdsDictionary__size++;
        return true;
    }

    const int chunkToCellInstanceIdsDictionary_expand = 10;
    void chunkToCellInstanceIdsDictionary_ExpandList(int index)
    {
        var hashKeys = chunkToCellInstanceIdsDictionary__keys[index];
        var hashValues = chunkToCellInstanceIdsDictionary__values[index];
        var len = chunkToCellInstanceIdsDictionary__keys[index].Length + chunkToCellInstanceIdsDictionary_expand;
        var newKeys = new int[len];
        var newValues = new int[len][];
        for (int i = 0; i < chunkToCellInstanceIdsDictionary__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = chunkToCellInstanceIdsDictionary__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        chunkToCellInstanceIdsDictionary__keys[index] = newKeys;
        chunkToCellInstanceIdsDictionary__values[index] = newValues;
    }

    public void chunkToCellInstanceIdsDictionary_AddOrSetValue(int key, int[] value)
    {
        int index = chunkToCellInstanceIdsDictionary_Hash(key);
        var hashKeys = chunkToCellInstanceIdsDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkToCellInstanceIdsDictionary__keys[index][i] = key;
                    chunkToCellInstanceIdsDictionary__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkToCellInstanceIdsDictionary__keys[index][i] = key;
                    chunkToCellInstanceIdsDictionary__values[index][i] = value;
                    chunkToCellInstanceIdsDictionary__size++;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkToCellInstanceIdsDictionary__keys[index][i] = key;
                    chunkToCellInstanceIdsDictionary__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == default)
                {
                    chunkToCellInstanceIdsDictionary__keys[index][i] = key;
                    chunkToCellInstanceIdsDictionary__values[index][i] = value;
                    chunkToCellInstanceIdsDictionary__size++;
                    return;
                }
            }
        }

        var preLen = hashKeys.Length;
        chunkToCellInstanceIdsDictionary_ExpandList(index);
        chunkToCellInstanceIdsDictionary__keys[index][preLen] = key;
        chunkToCellInstanceIdsDictionary__values[index][preLen] = value;
        chunkToCellInstanceIdsDictionary__size++;
    }

    public void chunkToCellInstanceIdsDictionary_SetValue(int key, int[] value)
    {
        int index = chunkToCellInstanceIdsDictionary_Hash(key);
        var hashKeys = chunkToCellInstanceIdsDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkToCellInstanceIdsDictionary__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkToCellInstanceIdsDictionary__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public int[] chunkToCellInstanceIdsDictionary_GetValue(int key)
    {
        int index = chunkToCellInstanceIdsDictionary_Hash(key);
        var hashKeys = chunkToCellInstanceIdsDictionary__keys[index];
        var hashValues = chunkToCellInstanceIdsDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void chunkToCellInstanceIdsDictionary_Remove(int key)
    {
        int index = chunkToCellInstanceIdsDictionary_Hash(key);
        var hashKeys = chunkToCellInstanceIdsDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    chunkToCellInstanceIdsDictionary__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    chunkToCellInstanceIdsDictionary__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    int XSTARTINDEX, XENDINDEX, ZSTARTINDEX, ZENDINDEX;
    public override void GenerateInit()
    {
        if (!isSynced)
            return;
        if (isGenerating)
            return;
        isGenerating = true;
        playerPos = Networking.LocalPlayer.GetPosition() / (chunkSize * TileScale);
        CalcPosCorrection();
        zStartChunkIndex = GetInRangeStartZChunkIndex(playerPos + posCorrection, chunkLoadRange);
        zEndChunkIndex = GetInRangeEndZChunkIndex(playerPos + posCorrection, chunkLoadRange);
        xStartChunkIndex = GetInRangeStartXChunkIndex(playerPos + posCorrection, zStartChunkIndex, chunkLoadRange);
        xEndChunkIndex = GetInRangeEndXChunkIndex(playerPos + posCorrection, zStartChunkIndex, chunkLoadRange);
        //GenerateInitCellInterval();
        chunkXIndex = 0;
        chunkZIndex = 0;
        chunkYIndex = 0;
        SearchAdditional();
    //RemoveChunkInterval();
    }

    float searchAdditionalInterval => settings_searchAdditionalInterval;

    Vector3 posCorrection = Vector3.zero;
    Vector3 GetPlayerPosition()
    {
        return Networking.LocalPlayer.GetPosition() / (chunkSize * TileScale);
    }

    void CalcPosCorrection()
    {
        playerRot = Networking.LocalPlayer.GetTrackingData(VRCPlayerApi.TrackingDataType.Head).rotation;
        // 極座標へ変換
        float r = 2.5f; // 半径は通常1とするか、必要に応じて変更
        var rad = Mathf.PI / 2 - playerRot.eulerAngles.y * Mathf.Deg2Rad;
        posCorrection.x = Mathf.Cos(rad) * r;
        posCorrection.z = Mathf.Sin(rad) * r;
    //Debug.Log("posCorrection: "+posCorrection);
    }

    void GenerateAdditional()
    {
        if (isGenerating)
            return;
        prePlayerPos = playerPos;
        playerPos = GetPlayerPosition(); //Networking.LocalPlayer.GetPosition() / (chunkSize*TileScale);
        CalcPosCorrection();
        //Debug.Log("GenerateAdditional");
        //Debug.Log("player pos: "+playerPos);
        zStartChunkIndex = GetInRangeStartZChunkIndex(playerPos + posCorrection, chunkLoadRange);
        zEndChunkIndex = GetInRangeEndZChunkIndex(playerPos + posCorrection, chunkLoadRange);
        xStartChunkIndex = GetInRangeStartXChunkIndex(playerPos + posCorrection, zStartChunkIndex, chunkLoadRange); //-1;
        xEndChunkIndex = GetInRangeEndXChunkIndex(playerPos + posCorrection, zStartChunkIndex, chunkLoadRange); //-1;
        //exceptXStartChunkIndex=GetInRangeStartXChunkIndex(prePlayerPos+posCorrection,zStartChunkIndex,chunkLoadRange);
        //exceptXEndChunkIndex=GetInRangeEndXChunkIndex(prePlayerPos+posCorrection,zStartChunkIndex,chunkLoadRange);
        isGenerating = true;
    //GenerateCellInterval();
    }

    void SearchAdditional()
    {
        if (searchOn)
        {
            if (isSearching)
            {
                Debug.LogWarning("already searching");
            }

            zSearchStartChunkIndex = GetInRangeStartZChunkIndex(playerPos, chunkUnLoadRange + searchMargin);
            ;
            zSearchEndChunkIndex = GetInRangeEndZChunkIndex(playerPos, chunkUnLoadRange + searchMargin);
            ;
            xSearchStartChunkIndex = GetInRangeStartXChunkIndex(playerPos, zSearchStartChunkIndex, chunkUnLoadRange + searchMargin);
            xSearchEndChunkIndex = GetInRangeEndXChunkIndex(playerPos, zSearchStartChunkIndex, chunkUnLoadRange + searchMargin);
            isSearching = true;
            researchFlag = false;
        }
    }

    Vector3 playerPos;
    Quaternion playerRot;
    Vector3 prePlayerPos;
    int GetInRangeStartXChunkIndex(Vector3 pos, float z, float range)
    {
        float diff = range * range - (pos.z - z) * (pos.z - z);
        if (diff <= 0)
            return chunkWidth / 2;
        return Math.Max(XSTARTINDEX, (int)(pos.x - Mathf.Sqrt(diff)));
    }

    int GetInRangeEndXChunkIndex(Vector3 pos, float z, float range)
    {
        float diff = Math.Max(0, range * range - (pos.z - z) * (pos.z - z));
        if (diff == 0)
            return -chunkWidth / 2;
        return Math.Min(XENDINDEX, (int)(pos.x + Mathf.Sqrt(diff)));
    }

    int GetInRangeStartZChunkIndex(Vector3 pos, float range)
    {
        return Math.Max(ZSTARTINDEX, (int)(pos.z - range));
    }

    int GetInRangeEndZChunkIndex(Vector3 pos, float range)
    {
        return Math.Min(ZENDINDEX, (int)(pos.z + range));
    }

    bool IsInDetailRange(Vector3 pPos, int x, int z)
    {
        return ((pPos.x - x) * (pPos.x - x) + (pPos.z - z) * (pPos.z - z)) < chunkDetailRange * chunkDetailRange;
    }

    int exceptXStartChunkIndex;
    int exceptXEndChunkIndex;
    int exceptZStartChunkIndex;
    int exceptZEndChunkIndex;
    bool isGenerating = false;
    int[][] outlineDict__keys;
    GameObject[][] outlineDict__values;
    int outlineDict__size;
    public int outlineDict_Count => outlineDict__size;

    public int[] outlineDict_GenerateKeysArray()
    {
        int[] keys = new int[outlineDict__size];
        int index = 0;
        for (int i = 0; i < outlineDict__keys.Length; i++)
        {
            var hashKeys = outlineDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int outlineDict_bucketCount = 2;
    public int outlineDict_KeyLength => outlineDict__keys.Length;

    public void outlineDict_SetCapacity(int capacity)
    {
        int len = capacity / outlineDict_bucketCount;
        outlineDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            outlineDict__keys[i] = new int[outlineDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < outlineDict_bucketCount; i++)
        {
            outlineDict__keys[0][i] = int.MaxValue;
        }

        outlineDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            outlineDict__values[i] = new GameObject[outlineDict_bucketCount];
        }
    }

    public bool outlineDict_HasItem(int key)
    {
        var index = outlineDict_Hash(key);
        var hashKeys = outlineDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int outlineDict_Hash(int key)
    {
        var len = outlineDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool outlineDict_Add(int key, GameObject value)
    {
        int index = outlineDict_Hash(key);
        var hashKeys = outlineDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    outlineDict__keys[index][i] = key;
                    outlineDict__values[index][i] = value;
                    outlineDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    outlineDict__keys[index][i] = key;
                    outlineDict__values[index][i] = value;
                    outlineDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        outlineDict_ExpandList(index);
        outlineDict__keys[index][preLen] = key;
        outlineDict__values[index][preLen] = value;
        outlineDict__size++;
        return true;
    }

    const int outlineDict_expand = 10;
    void outlineDict_ExpandList(int index)
    {
        var hashKeys = outlineDict__keys[index];
        var hashValues = outlineDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + outlineDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        outlineDict__keys[index] = newKeys;
        outlineDict__values[index] = newValues;
    }

    public bool outlineDict_AddOrSetValue(int key, GameObject value)
    {
        int index = outlineDict_Hash(key);
        var hashKeys = outlineDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    outlineDict__keys[index][i] = key;
                    outlineDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    outlineDict__keys[index][i] = key;
                    outlineDict__values[index][i] = value;
                    outlineDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    outlineDict__keys[index][i] = key;
                    outlineDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    outlineDict__keys[index][i] = key;
                    outlineDict__values[index][i] = value;
                    outlineDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        outlineDict_ExpandList(index);
        outlineDict__keys[index][preLen] = key;
        outlineDict__values[index][preLen] = value;
        outlineDict__size++;
        return true;
    }

    public void outlineDict_SetValue(int key, GameObject value)
    {
        int index = outlineDict_Hash(key);
        var hashKeys = outlineDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    outlineDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    outlineDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject outlineDict_GetValue(int key)
    {
        int index = outlineDict_Hash(key);
        var hashKeys = outlineDict__keys[index];
        var hashValues = outlineDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject outlineDict_TryGetValue(int key)
    {
        int index = outlineDict_Hash(key);
        var hashKeys = outlineDict__keys[index];
        var hashValues = outlineDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void outlineDict_Remove(int key)
    {
        int index = outlineDict_Hash(key);
        var hashKeys = outlineDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    outlineDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    outlineDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    int[][] removedChunkIndexDict__keys;
    bool[][] removedChunkIndexDict__values;
    int removedChunkIndexDict__size;
    public int removedChunkIndexDict_Count => removedChunkIndexDict__size;

    public int[] removedChunkIndexDict_GenerateKeysArray()
    {
        int[] keys = new int[removedChunkIndexDict__size];
        int index = 0;
        for (int i = 0; i < removedChunkIndexDict__keys.Length; i++)
        {
            var hashKeys = removedChunkIndexDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int removedChunkIndexDict_bucketCount = 2;
    public void removedChunkIndexDict_SetCapacity(int capacity)
    {
        int len = capacity / removedChunkIndexDict_bucketCount;
        removedChunkIndexDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            removedChunkIndexDict__keys[i] = new int[removedChunkIndexDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < removedChunkIndexDict_bucketCount; i++)
        {
            removedChunkIndexDict__keys[0][i] = int.MaxValue;
        }

        removedChunkIndexDict__values = new bool[len][];
        for (int i = 0; i < len; i++)
        {
            removedChunkIndexDict__values[i] = new bool[removedChunkIndexDict_bucketCount];
        }
    }

    public bool removedChunkIndexDict_HasItem(int key)
    {
        var index = removedChunkIndexDict_Hash(key);
        var hashKeys = removedChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int removedChunkIndexDict_Hash(int key)
    {
        var len = removedChunkIndexDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool removedChunkIndexDict_Add(int key, bool value)
    {
        int index = removedChunkIndexDict_Hash(key);
        var hashKeys = removedChunkIndexDict__keys[index];
        if (key == int.MaxValue)
        {
            Debug.LogError("not allowed key value");
        }

        if (index == 0)
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    removedChunkIndexDict__keys[index][i] = key;
                    removedChunkIndexDict__values[index][i] = value;
                    removedChunkIndexDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    removedChunkIndexDict__keys[index][i] = key;
                    removedChunkIndexDict__values[index][i] = value;
                    removedChunkIndexDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoolDictionary Add: Dictionary is full");
        var preLen = hashKeys.Length;
        removedChunkIndexDict_ExpandList(index);
        removedChunkIndexDict__keys[index][preLen] = key;
        removedChunkIndexDict__values[index][preLen] = value;
        removedChunkIndexDict__size++;
        return true;
    }

    const int removedChunkIndexDict_expand = 10;
    void removedChunkIndexDict_ExpandList(int index)
    {
        var hashKeys = removedChunkIndexDict__keys[index];
        var hashValues = removedChunkIndexDict__values[index];
        var len = removedChunkIndexDict__keys[index].Length + removedChunkIndexDict_expand;
        var newKeys = new int[len];
        var newValues = new bool[len];
        for (int i = 0; i < removedChunkIndexDict__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = removedChunkIndexDict__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        removedChunkIndexDict__keys[index] = newKeys;
        removedChunkIndexDict__values[index] = newValues;
    }

    public bool removedChunkIndexDict_AddOrSetValue(int key, bool value)
    {
        int index = removedChunkIndexDict_Hash(key);
        var hashKeys = removedChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    removedChunkIndexDict__keys[index][i] = key;
                    removedChunkIndexDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    removedChunkIndexDict__keys[index][i] = key;
                    removedChunkIndexDict__values[index][i] = value;
                    removedChunkIndexDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    removedChunkIndexDict__keys[index][i] = key;
                    removedChunkIndexDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    removedChunkIndexDict__keys[index][i] = key;
                    removedChunkIndexDict__values[index][i] = value;
                    removedChunkIndexDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogError("InkEyBoolDictionary AddOrSetValue: Dictionary is full");
        //return false;
        var preLen = hashKeys.Length;
        removedChunkIndexDict_ExpandList(index);
        removedChunkIndexDict__keys[index][preLen] = key;
        removedChunkIndexDict__values[index][preLen] = value;
        removedChunkIndexDict__size++;
        return true;
    }

    public void removedChunkIndexDict_SetValue(int key, bool value)
    {
        int index = removedChunkIndexDict_Hash(key);
        var hashKeys = removedChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    removedChunkIndexDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    removedChunkIndexDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public bool removedChunkIndexDict_GetValueOrDefault(int key, bool defaultValue)
    {
        int index = removedChunkIndexDict_Hash(key);
        var hashKeys = removedChunkIndexDict__keys[index];
        var hashValues = removedChunkIndexDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return defaultValue;
    }

    public bool removedChunkIndexDict_GetValue(int key)
    {
        int index = removedChunkIndexDict_Hash(key);
        var hashKeys = removedChunkIndexDict__keys[index];
        var hashValues = removedChunkIndexDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void removedChunkIndexDict_TryRemoveBatch(int[] keys, bool[] result)
    {
        for (int i = 0; i < keys.Length; i++)
        {
            result[i] = removedChunkIndexDict_TryRemove(keys[i]);
        }
    }

    public bool removedChunkIndexDict_TryRemove(int key)
    {
        int index = removedChunkIndexDict_Hash(key);
        var hashKeys = removedChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    removedChunkIndexDict__size--;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    removedChunkIndexDict__size--;
                    return true;
                }
            }
        }

        return false;
    }

    public void removedChunkIndexDict_Remove(int key)
    {
        if (!removedChunkIndexDict_TryRemove(key))
            Debug.LogError("Key not found");
    }

    int[][] loadedChunkIndexDict__keys;
    bool[][] loadedChunkIndexDict__values;
    int loadedChunkIndexDict__size;
    public int loadedChunkIndexDict_Count => loadedChunkIndexDict__size;

    public int[] loadedChunkIndexDict_GenerateKeysArray()
    {
        int[] keys = new int[loadedChunkIndexDict__size];
        int index = 0;
        for (int i = 0; i < loadedChunkIndexDict__keys.Length; i++)
        {
            var hashKeys = loadedChunkIndexDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int loadedChunkIndexDict_bucketCount = 2;
    public void loadedChunkIndexDict_SetCapacity(int capacity)
    {
        int len = capacity / loadedChunkIndexDict_bucketCount;
        loadedChunkIndexDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            loadedChunkIndexDict__keys[i] = new int[loadedChunkIndexDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < loadedChunkIndexDict_bucketCount; i++)
        {
            loadedChunkIndexDict__keys[0][i] = int.MaxValue;
        }

        loadedChunkIndexDict__values = new bool[len][];
        for (int i = 0; i < len; i++)
        {
            loadedChunkIndexDict__values[i] = new bool[loadedChunkIndexDict_bucketCount];
        }
    }

    public bool loadedChunkIndexDict_HasItem(int key)
    {
        var index = loadedChunkIndexDict_Hash(key);
        var hashKeys = loadedChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int loadedChunkIndexDict_Hash(int key)
    {
        var len = loadedChunkIndexDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool loadedChunkIndexDict_Add(int key, bool value)
    {
        int index = loadedChunkIndexDict_Hash(key);
        var hashKeys = loadedChunkIndexDict__keys[index];
        if (key == int.MaxValue)
        {
            Debug.LogError("not allowed key value");
        }

        if (index == 0)
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    loadedChunkIndexDict__keys[index][i] = key;
                    loadedChunkIndexDict__values[index][i] = value;
                    loadedChunkIndexDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    loadedChunkIndexDict__keys[index][i] = key;
                    loadedChunkIndexDict__values[index][i] = value;
                    loadedChunkIndexDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoolDictionary Add: Dictionary is full");
        var preLen = hashKeys.Length;
        loadedChunkIndexDict_ExpandList(index);
        loadedChunkIndexDict__keys[index][preLen] = key;
        loadedChunkIndexDict__values[index][preLen] = value;
        loadedChunkIndexDict__size++;
        return true;
    }

    const int loadedChunkIndexDict_expand = 10;
    void loadedChunkIndexDict_ExpandList(int index)
    {
        var hashKeys = loadedChunkIndexDict__keys[index];
        var hashValues = loadedChunkIndexDict__values[index];
        var len = loadedChunkIndexDict__keys[index].Length + loadedChunkIndexDict_expand;
        var newKeys = new int[len];
        var newValues = new bool[len];
        for (int i = 0; i < loadedChunkIndexDict__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = loadedChunkIndexDict__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        loadedChunkIndexDict__keys[index] = newKeys;
        loadedChunkIndexDict__values[index] = newValues;
    }

    public bool loadedChunkIndexDict_AddOrSetValue(int key, bool value)
    {
        int index = loadedChunkIndexDict_Hash(key);
        var hashKeys = loadedChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    loadedChunkIndexDict__keys[index][i] = key;
                    loadedChunkIndexDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    loadedChunkIndexDict__keys[index][i] = key;
                    loadedChunkIndexDict__values[index][i] = value;
                    loadedChunkIndexDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    loadedChunkIndexDict__keys[index][i] = key;
                    loadedChunkIndexDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    loadedChunkIndexDict__keys[index][i] = key;
                    loadedChunkIndexDict__values[index][i] = value;
                    loadedChunkIndexDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogError("InkEyBoolDictionary AddOrSetValue: Dictionary is full");
        //return false;
        var preLen = hashKeys.Length;
        loadedChunkIndexDict_ExpandList(index);
        loadedChunkIndexDict__keys[index][preLen] = key;
        loadedChunkIndexDict__values[index][preLen] = value;
        loadedChunkIndexDict__size++;
        return true;
    }

    public void loadedChunkIndexDict_SetValue(int key, bool value)
    {
        int index = loadedChunkIndexDict_Hash(key);
        var hashKeys = loadedChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    loadedChunkIndexDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    loadedChunkIndexDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public bool loadedChunkIndexDict_GetValueOrDefault(int key, bool defaultValue)
    {
        int index = loadedChunkIndexDict_Hash(key);
        var hashKeys = loadedChunkIndexDict__keys[index];
        var hashValues = loadedChunkIndexDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return defaultValue;
    }

    public bool loadedChunkIndexDict_GetValue(int key)
    {
        int index = loadedChunkIndexDict_Hash(key);
        var hashKeys = loadedChunkIndexDict__keys[index];
        var hashValues = loadedChunkIndexDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void loadedChunkIndexDict_TryRemoveBatch(int[] keys, bool[] result)
    {
        for (int i = 0; i < keys.Length; i++)
        {
            result[i] = loadedChunkIndexDict_TryRemove(keys[i]);
        }
    }

    public bool loadedChunkIndexDict_TryRemove(int key)
    {
        int index = loadedChunkIndexDict_Hash(key);
        var hashKeys = loadedChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    loadedChunkIndexDict__size--;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    loadedChunkIndexDict__size--;
                    return true;
                }
            }
        }

        return false;
    }

    public void loadedChunkIndexDict_Remove(int key)
    {
        if (!loadedChunkIndexDict_TryRemove(key))
            Debug.LogError("Key not found");
    }

    float generateAdditionalDelta = -1f;
    float searchAdditionalDelta = -1f;
    [SerializeField]
    int isInstantiatedCost = 10;
    [SerializeField]
    int poolCost = 4;
    [SerializeField]
    int unloadCost = 6;
    int storeCount = 0;
    int storeMax = 3;
    int biomeIndex = 0;
    UdonSavingObjectPool storeBiomePool;
    void StoreCell()
    {
        BiomeStore(biomeIndex);
        isInstantiated = BiomePeekIsInstantiated(biomeIndex); //storeBiomePool.PeekIsInstantiated();
        biomeIndex++;
        biomeIndex %= (int)Biome.Dark;
    }

    int costIndex;
    GenerateChunkMode mode;
    bool researchFlag = false;
    public void RequestResearch()
    {
        researchFlag = true;
        QuickSearch();
    }

    [SerializeField]
    bool detailFlag = false;
    [SerializeField]
    bool undetailFlag = false;
    [SerializeField]
    bool unloadFlag = false;
    void QuickSearch()
    {
        if (searchOn)
        {
            var ppos = GetPlayerPosition();
            zQuickSearchStartChunkIndex = GetInRangeStartZChunkIndex(ppos, quickSearchRange);
            zQuickSearchEndChunkIndex = GetInRangeEndZChunkIndex(ppos, quickSearchRange);
            xQuickSearchStartChunkIndex = GetInRangeStartXChunkIndex(ppos, zQuickSearchStartChunkIndex, quickSearchRange);
            xQuickSearchEndChunkIndex = GetInRangeEndXChunkIndex(ppos, zQuickSearchStartChunkIndex, quickSearchRange);
            while (true)
            {
                var x = xQuickSearchStartChunkIndex;
                var z = zQuickSearchStartChunkIndex;
                var chunkIndex = ToChunkIndex(x, z);
                if (loadedChunkIndexDict_GetValueOrDefault(chunkIndex, false))
                {
                    var diffx = x - ppos.x;
                    var diffz = z - ppos.z;
                    var distance = diffx * diffx + diffz * diffz;
                    if (distance <= chunkDetailRange * chunkDetailRange)
                    {
                        if (!detailChunkIndexDict_GetValueOrDefault(chunkIndex, false))
                        {
                            detailOperationDictionary_AddOrSetValue(chunkIndex, true);
                            unloadOperationDictionary_AddOrSetValue(chunkIndex, false);
                            priorityDetailQueue_Enqueue(chunkIndex);
                        }
                    //DetailChunk((int)x,(int)z);
                    }
                }

                xQuickSearchStartChunkIndex++;
                if (xQuickSearchStartChunkIndex > xQuickSearchEndChunkIndex)
                {
                    zQuickSearchStartChunkIndex++;
                    xQuickSearchStartChunkIndex = GetInRangeStartXChunkIndex(ppos, zQuickSearchStartChunkIndex, quickSearchRange);
                    xQuickSearchEndChunkIndex = GetInRangeEndXChunkIndex(ppos, zQuickSearchStartChunkIndex, quickSearchRange);
                    if (zQuickSearchStartChunkIndex >= zQuickSearchEndChunkIndex)
                    {
                        break;
                    }
                }
            }
        }
    }

    void Update()
    {
        if (isGenerating)
        {
            //if(isUnLoading)return;
            for (costIndex = 0; costIndex < batchCount * isInstantiatedCost;)
            {
                //delay=generateInterval * count / batchCount;
                mode = GenerateChunk();
                if (isInstantiated)
                {
                    costIndex += isInstantiatedCost;
                    isInstantiated = false;
                }
                else if (mode == GenerateChunkMode.Pass)
                {
                    storeCount++;
                    if (storeCount == storeMax)
                    {
                        StoreCell();
                        storeCount = 0;
                    }

                    if (isInstantiated)
                    {
                        costIndex += isInstantiatedCost;
                        isInstantiated = false;
                    }
                    else
                    {
                        costIndex++;
                    }
                }
                else
                {
                    costIndex += poolCost;
                }

                if (mode == GenerateChunkMode.Complete || mode == GenerateChunkMode.Pass)
                {
                    chunkXIndex = 0;
                    chunkZIndex = 0;
                    chunkYIndex = 0;
                    xStartChunkIndex++;
                    if (xStartChunkIndex > xEndChunkIndex)
                    {
                        zStartChunkIndex++;
                        xStartChunkIndex = GetInRangeStartXChunkIndex(playerPos + posCorrection, zStartChunkIndex, chunkLoadRange);
                        xEndChunkIndex = GetInRangeEndXChunkIndex(playerPos + posCorrection, zStartChunkIndex, chunkLoadRange);
                        if (zStartChunkIndex >= zEndChunkIndex)
                        {
                            isGenerating = false;
                            //GenerateAdditional();
                            if (generateAdditionalInterval == 0)
                            {
                                GenerateAdditional();
                            }
                            else
                            {
                                generateAdditionalDelta = generateAdditionalInterval;
                            }

                            //SendCustomEventDelayedSeconds(nameof(GenerateAdditional),generateAdditionalInterval);
                            break;
                        }
                    }
                }

                if (mode == GenerateChunkMode.Complete)
                {
                    break;
                }
            }
        }
        else
        {
            if (generateAdditionalDelta >= 0)
            {
                generateAdditionalDelta -= Time.deltaTime;
                if (generateAdditionalDelta < 0)
                {
                    GenerateAdditional();
                }
            }
        }

        if (isSearching)
        {
            //if(isUnLoading)return;
            for (costIndex = 0; costIndex < searchBatchCount; costIndex++)
            {
                var x = xSearchStartChunkIndex;
                var z = zSearchStartChunkIndex;
                var chunkIndex = ToChunkIndex(x, z);
                if (loadedChunkIndexDict_GetValueOrDefault(chunkIndex, false))
                {
                    var diffx = x - playerPos.x;
                    var diffz = z - playerPos.z;
                    var distance = diffx * diffx + diffz * diffz;
                    if (distance >= chunkUnLoadRange * chunkUnLoadRange)
                    {
                        if (!unloadOperationDictionary_GetValueOrDefault(chunkIndex, false))
                        {
                            unloadOperationDictionary_AddOrSetValue(chunkIndex, true);
                            unloadQueue_Enqueue(chunkIndex);
                        }
                    //UnLoadChunk((int)x,(int)z,true);
                    }
                    else if (distance >= chunkDetailRange * chunkDetailRange)
                    {
                        if (detailOperationDictionary_GetValueOrDefault(chunkIndex, false))
                        {
                            detailOperationDictionary_AddOrSetValue(chunkIndex, false);
                            unloadOperationDictionary_AddOrSetValue(chunkIndex, false);
                            undetailQueue_Enqueue(chunkIndex);
                        }
                    //UnDetailChunk((int)x,(int)z);
                    }
                    else
                    {
                        if (!detailOperationDictionary_GetValueOrDefault(chunkIndex, false))
                        {
                            detailOperationDictionary_AddOrSetValue(chunkIndex, true);
                            unloadOperationDictionary_AddOrSetValue(chunkIndex, false);
                            detailQueue_Enqueue(chunkIndex);
                        }
                    //DetailChunk((int)x,(int)z);
                    }
                }

                xSearchStartChunkIndex++;
                if (xSearchStartChunkIndex > xSearchEndChunkIndex)
                {
                    zSearchStartChunkIndex++;
                    xSearchStartChunkIndex = GetInRangeStartXChunkIndex(playerPos, zSearchStartChunkIndex, chunkUnLoadRange + searchMargin);
                    xSearchEndChunkIndex = GetInRangeEndXChunkIndex(playerPos, zSearchStartChunkIndex, chunkUnLoadRange + searchMargin);
                    if (zSearchStartChunkIndex >= zSearchEndChunkIndex)
                    {
                        isSearching = false;
                        break;
                    }
                }
            //if(taskFlag)break;
            }
        }
        else
        {
            if (searchAdditionalDelta >= 0)
            {
                searchAdditionalDelta -= Time.deltaTime;
                if (searchAdditionalDelta < 0 || researchFlag)
                {
                    SearchAdditional();
                }
            }
            else
            {
                //if(unloadQueue.Count==0&&detailQueue.Count==0){
                searchAdditionalDelta = searchAdditionalInterval; // search処理で最後に一回だけ呼ばれる
            //;
            }
        }

        // detail
        costIndex = 0;
        if (detailFlag)
        {
            while (costIndex < operationBatchCount * 2)
            {
                if (priorityDetailQueue_Count == 0)
                    break;
                var chunkIndex = priorityDetailQueue_Dequeue();
                var shouldOperate = detailOperationDictionary_GetValueOrDefault(chunkIndex, false);
                if (shouldOperate && DetailChunk(chunkIndex))
                    costIndex++;
            }

            while (costIndex < operationBatchCount)
            {
                if (detailQueue_Count == 0)
                    break;
                var chunkIndex = detailQueue_Dequeue();
                var shouldOperate = detailOperationDictionary_GetValueOrDefault(chunkIndex, false);
                if (shouldOperate && DetailChunk(chunkIndex))
                    costIndex++;
            }
        }

        if (undetailFlag)
        {
            while (costIndex < operationBatchCount)
            {
                if (unloadQueue_Count == 0)
                    break;
                var chunkIndex = unloadQueue_Dequeue();
                var shouldOperate = unloadOperationDictionary_GetValueOrDefault(chunkIndex, false);
                if (shouldOperate && UnLoadChunk(chunkIndex, true))
                    costIndex++;
            }
        }

        if (unloadFlag)
        {
            while (costIndex < operationBatchCount)
            {
                if (undetailQueue_Count == 0)
                    break;
                var chunkIndex = undetailQueue_Dequeue();
                var shouldOperate = !detailOperationDictionary_GetValueOrDefault(chunkIndex, false);
                if (shouldOperate && UnDetailChunk(chunkIndex))
                    costIndex++;
            }
        }
    }

    float searchMargin => chunkDetailRange * 2;

    bool isSearching = false;
    int searchBatchCount => settings_searchBatchCount;

    bool searchOn => settings_searchOn;

    int ToChunkIndex(int x, int z)
    {
        return (z - ZSTARTINDEX) * chunkWidth + (x - XSTARTINDEX);
    }

    public const float AnimHeight = 10f;
    private int[] unloadQueue__array;
    private int unloadQueue__head; // First valid element in the queue.
    private int unloadQueue__tail; // Last valid element in the queue.
    private int unloadQueue__size; // Number of elements.
    private int unloadQueue__version;
    private const int unloadQueue_MinimumGrow = 100000;
    public int unloadQueue_Count => unloadQueue__size;
    public int unloadQueue_Version => unloadQueue__version;

    [Obsolete("Use Count Property.")]
    public int unloadQueue_GetCount() => unloadQueue__size;
    [Obsolete("Use Version Property.")]
    public int unloadQueue_GetVersion() => unloadQueue__version;
    // Removes all Objects from the queue.
    public void unloadQueue_Clear()
    {
        if (unloadQueue__size != 0)
        {
            if (unloadQueue__head < unloadQueue__tail)
            {
                Array.Clear(unloadQueue__array, unloadQueue__head, unloadQueue__size);
            }
            else
            {
                Array.Clear(unloadQueue__array, unloadQueue__head, unloadQueue__array.Length - unloadQueue__head);
                Array.Clear(unloadQueue__array, 0, unloadQueue__tail);
            }

            unloadQueue__size = 0;
        }

        unloadQueue__head = 0;
        unloadQueue__tail = 0;
        unloadQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void unloadQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < unloadQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = unloadQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = unloadQueue__array.Length - unloadQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(unloadQueue__array, unloadQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(unloadQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void unloadQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (unloadQueue__array == null)
        {
            unloadQueue_SetCapacity(unloadQueue_MinimumGrow);
        }
        else if (unloadQueue__size == unloadQueue__array.Length)
        {
            unloadQueue_SetCapacity(unloadQueue__array.Length + unloadQueue_MinimumGrow);
        }

        unloadQueue__array[unloadQueue__tail] = obj;
        unloadQueue__tail = (unloadQueue__tail + 1) % unloadQueue__array.Length;
        unloadQueue__size++;
        unloadQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int unloadQueue_Dequeue()
    {
        if (unloadQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = unloadQueue__array[unloadQueue__head];
        unloadQueue__array[unloadQueue__head] = int.MaxValue;
        unloadQueue__head = (unloadQueue__head + 1) % unloadQueue__array.Length;
        unloadQueue__size--;
        unloadQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int unloadQueue_Peek()
    {
        if (unloadQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return unloadQueue__array[unloadQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] unloadQueue_ToArray()
    {
        int[] arr = new int[unloadQueue__size];
        if (unloadQueue__size == 0)
        {
        }
        else if (unloadQueue__head < unloadQueue__tail)
        {
            Array.Copy(unloadQueue__array, unloadQueue__head, arr, 0, unloadQueue__size);
        }
        else
        {
            int toHead = unloadQueue__array.Length - unloadQueue__head;
            Array.Copy(unloadQueue__array, unloadQueue__head, arr, 0, toHead);
            Array.Copy(unloadQueue__array, 0, arr, toHead, unloadQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void unloadQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (unloadQueue__size == 0)
        {
        }
        else if (unloadQueue__head < unloadQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(unloadQueue__array, unloadQueue__head, newArray, 0, unloadQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = unloadQueue__array.Length - unloadQueue__head;
            Array.Copy(unloadQueue__array, unloadQueue__head, newArray, 0, toHead);
            Array.Copy(unloadQueue__array, 0, newArray, toHead, unloadQueue__tail);
        }

        unloadQueue__array = newArray;
        unloadQueue__head = 0;
        unloadQueue__tail = unloadQueue__size == capacity ? 0 : unloadQueue__size;
        unloadQueue__version++;
    }

    private int[] undetailQueue__array;
    private int undetailQueue__head; // First valid element in the queue.
    private int undetailQueue__tail; // Last valid element in the queue.
    private int undetailQueue__size; // Number of elements.
    private int undetailQueue__version;
    private const int undetailQueue_MinimumGrow = 100000;
    public int undetailQueue_Count => undetailQueue__size;
    public int undetailQueue_Version => undetailQueue__version;

    [Obsolete("Use Count Property.")]
    public int undetailQueue_GetCount() => undetailQueue__size;
    [Obsolete("Use Version Property.")]
    public int undetailQueue_GetVersion() => undetailQueue__version;
    // Removes all Objects from the queue.
    public void undetailQueue_Clear()
    {
        if (undetailQueue__size != 0)
        {
            if (undetailQueue__head < undetailQueue__tail)
            {
                Array.Clear(undetailQueue__array, undetailQueue__head, undetailQueue__size);
            }
            else
            {
                Array.Clear(undetailQueue__array, undetailQueue__head, undetailQueue__array.Length - undetailQueue__head);
                Array.Clear(undetailQueue__array, 0, undetailQueue__tail);
            }

            undetailQueue__size = 0;
        }

        undetailQueue__head = 0;
        undetailQueue__tail = 0;
        undetailQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void undetailQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < undetailQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = undetailQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = undetailQueue__array.Length - undetailQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(undetailQueue__array, undetailQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(undetailQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void undetailQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (undetailQueue__array == null)
        {
            undetailQueue_SetCapacity(undetailQueue_MinimumGrow);
        }
        else if (undetailQueue__size == undetailQueue__array.Length)
        {
            undetailQueue_SetCapacity(undetailQueue__array.Length + undetailQueue_MinimumGrow);
        }

        undetailQueue__array[undetailQueue__tail] = obj;
        undetailQueue__tail = (undetailQueue__tail + 1) % undetailQueue__array.Length;
        undetailQueue__size++;
        undetailQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int undetailQueue_Dequeue()
    {
        if (undetailQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = undetailQueue__array[undetailQueue__head];
        undetailQueue__array[undetailQueue__head] = int.MaxValue;
        undetailQueue__head = (undetailQueue__head + 1) % undetailQueue__array.Length;
        undetailQueue__size--;
        undetailQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int undetailQueue_Peek()
    {
        if (undetailQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return undetailQueue__array[undetailQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] undetailQueue_ToArray()
    {
        int[] arr = new int[undetailQueue__size];
        if (undetailQueue__size == 0)
        {
        }
        else if (undetailQueue__head < undetailQueue__tail)
        {
            Array.Copy(undetailQueue__array, undetailQueue__head, arr, 0, undetailQueue__size);
        }
        else
        {
            int toHead = undetailQueue__array.Length - undetailQueue__head;
            Array.Copy(undetailQueue__array, undetailQueue__head, arr, 0, toHead);
            Array.Copy(undetailQueue__array, 0, arr, toHead, undetailQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void undetailQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (undetailQueue__size == 0)
        {
        }
        else if (undetailQueue__head < undetailQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(undetailQueue__array, undetailQueue__head, newArray, 0, undetailQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = undetailQueue__array.Length - undetailQueue__head;
            Array.Copy(undetailQueue__array, undetailQueue__head, newArray, 0, toHead);
            Array.Copy(undetailQueue__array, 0, newArray, toHead, undetailQueue__tail);
        }

        undetailQueue__array = newArray;
        undetailQueue__head = 0;
        undetailQueue__tail = undetailQueue__size == capacity ? 0 : undetailQueue__size;
        undetailQueue__version++;
    }

    private int[] detailQueue__array;
    private int detailQueue__head; // First valid element in the queue.
    private int detailQueue__tail; // Last valid element in the queue.
    private int detailQueue__size; // Number of elements.
    private int detailQueue__version;
    private const int detailQueue_MinimumGrow = 100000;
    public int detailQueue_Count => detailQueue__size;
    public int detailQueue_Version => detailQueue__version;

    [Obsolete("Use Count Property.")]
    public int detailQueue_GetCount() => detailQueue__size;
    [Obsolete("Use Version Property.")]
    public int detailQueue_GetVersion() => detailQueue__version;
    // Removes all Objects from the queue.
    public void detailQueue_Clear()
    {
        if (detailQueue__size != 0)
        {
            if (detailQueue__head < detailQueue__tail)
            {
                Array.Clear(detailQueue__array, detailQueue__head, detailQueue__size);
            }
            else
            {
                Array.Clear(detailQueue__array, detailQueue__head, detailQueue__array.Length - detailQueue__head);
                Array.Clear(detailQueue__array, 0, detailQueue__tail);
            }

            detailQueue__size = 0;
        }

        detailQueue__head = 0;
        detailQueue__tail = 0;
        detailQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void detailQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < detailQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = detailQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = detailQueue__array.Length - detailQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(detailQueue__array, detailQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(detailQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void detailQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (detailQueue__array == null)
        {
            detailQueue_SetCapacity(detailQueue_MinimumGrow);
        }
        else if (detailQueue__size == detailQueue__array.Length)
        {
            detailQueue_SetCapacity(detailQueue__array.Length + detailQueue_MinimumGrow);
        }

        detailQueue__array[detailQueue__tail] = obj;
        detailQueue__tail = (detailQueue__tail + 1) % detailQueue__array.Length;
        detailQueue__size++;
        detailQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int detailQueue_Dequeue()
    {
        if (detailQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = detailQueue__array[detailQueue__head];
        detailQueue__array[detailQueue__head] = int.MaxValue;
        detailQueue__head = (detailQueue__head + 1) % detailQueue__array.Length;
        detailQueue__size--;
        detailQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int detailQueue_Peek()
    {
        if (detailQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return detailQueue__array[detailQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] detailQueue_ToArray()
    {
        int[] arr = new int[detailQueue__size];
        if (detailQueue__size == 0)
        {
        }
        else if (detailQueue__head < detailQueue__tail)
        {
            Array.Copy(detailQueue__array, detailQueue__head, arr, 0, detailQueue__size);
        }
        else
        {
            int toHead = detailQueue__array.Length - detailQueue__head;
            Array.Copy(detailQueue__array, detailQueue__head, arr, 0, toHead);
            Array.Copy(detailQueue__array, 0, arr, toHead, detailQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void detailQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (detailQueue__size == 0)
        {
        }
        else if (detailQueue__head < detailQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(detailQueue__array, detailQueue__head, newArray, 0, detailQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = detailQueue__array.Length - detailQueue__head;
            Array.Copy(detailQueue__array, detailQueue__head, newArray, 0, toHead);
            Array.Copy(detailQueue__array, 0, newArray, toHead, detailQueue__tail);
        }

        detailQueue__array = newArray;
        detailQueue__head = 0;
        detailQueue__tail = detailQueue__size == capacity ? 0 : detailQueue__size;
        detailQueue__version++;
    }

    private int[] priorityDetailQueue__array;
    private int priorityDetailQueue__head; // First valid element in the queue.
    private int priorityDetailQueue__tail; // Last valid element in the queue.
    private int priorityDetailQueue__size; // Number of elements.
    private int priorityDetailQueue__version;
    private const int priorityDetailQueue_MinimumGrow = 100000;
    public int priorityDetailQueue_Count => priorityDetailQueue__size;
    public int priorityDetailQueue_Version => priorityDetailQueue__version;

    [Obsolete("Use Count Property.")]
    public int priorityDetailQueue_GetCount() => priorityDetailQueue__size;
    [Obsolete("Use Version Property.")]
    public int priorityDetailQueue_GetVersion() => priorityDetailQueue__version;
    // Removes all Objects from the queue.
    public void priorityDetailQueue_Clear()
    {
        if (priorityDetailQueue__size != 0)
        {
            if (priorityDetailQueue__head < priorityDetailQueue__tail)
            {
                Array.Clear(priorityDetailQueue__array, priorityDetailQueue__head, priorityDetailQueue__size);
            }
            else
            {
                Array.Clear(priorityDetailQueue__array, priorityDetailQueue__head, priorityDetailQueue__array.Length - priorityDetailQueue__head);
                Array.Clear(priorityDetailQueue__array, 0, priorityDetailQueue__tail);
            }

            priorityDetailQueue__size = 0;
        }

        priorityDetailQueue__head = 0;
        priorityDetailQueue__tail = 0;
        priorityDetailQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void priorityDetailQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < priorityDetailQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = priorityDetailQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = priorityDetailQueue__array.Length - priorityDetailQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(priorityDetailQueue__array, priorityDetailQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(priorityDetailQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void priorityDetailQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (priorityDetailQueue__array == null)
        {
            priorityDetailQueue_SetCapacity(priorityDetailQueue_MinimumGrow);
        }
        else if (priorityDetailQueue__size == priorityDetailQueue__array.Length)
        {
            priorityDetailQueue_SetCapacity(priorityDetailQueue__array.Length + priorityDetailQueue_MinimumGrow);
        }

        priorityDetailQueue__array[priorityDetailQueue__tail] = obj;
        priorityDetailQueue__tail = (priorityDetailQueue__tail + 1) % priorityDetailQueue__array.Length;
        priorityDetailQueue__size++;
        priorityDetailQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int priorityDetailQueue_Dequeue()
    {
        if (priorityDetailQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = priorityDetailQueue__array[priorityDetailQueue__head];
        priorityDetailQueue__array[priorityDetailQueue__head] = int.MaxValue;
        priorityDetailQueue__head = (priorityDetailQueue__head + 1) % priorityDetailQueue__array.Length;
        priorityDetailQueue__size--;
        priorityDetailQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int priorityDetailQueue_Peek()
    {
        if (priorityDetailQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return priorityDetailQueue__array[priorityDetailQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] priorityDetailQueue_ToArray()
    {
        int[] arr = new int[priorityDetailQueue__size];
        if (priorityDetailQueue__size == 0)
        {
        }
        else if (priorityDetailQueue__head < priorityDetailQueue__tail)
        {
            Array.Copy(priorityDetailQueue__array, priorityDetailQueue__head, arr, 0, priorityDetailQueue__size);
        }
        else
        {
            int toHead = priorityDetailQueue__array.Length - priorityDetailQueue__head;
            Array.Copy(priorityDetailQueue__array, priorityDetailQueue__head, arr, 0, toHead);
            Array.Copy(priorityDetailQueue__array, 0, arr, toHead, priorityDetailQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void priorityDetailQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (priorityDetailQueue__size == 0)
        {
        }
        else if (priorityDetailQueue__head < priorityDetailQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(priorityDetailQueue__array, priorityDetailQueue__head, newArray, 0, priorityDetailQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = priorityDetailQueue__array.Length - priorityDetailQueue__head;
            Array.Copy(priorityDetailQueue__array, priorityDetailQueue__head, newArray, 0, toHead);
            Array.Copy(priorityDetailQueue__array, 0, newArray, toHead, priorityDetailQueue__tail);
        }

        priorityDetailQueue__array = newArray;
        priorityDetailQueue__head = 0;
        priorityDetailQueue__tail = priorityDetailQueue__size == capacity ? 0 : priorityDetailQueue__size;
        priorityDetailQueue__version++;
    }

    int[][] detailChunkIndexDict__keys;
    bool[][] detailChunkIndexDict__values;
    int detailChunkIndexDict__size;
    public int detailChunkIndexDict_Count => detailChunkIndexDict__size;

    public int[] detailChunkIndexDict_GenerateKeysArray()
    {
        int[] keys = new int[detailChunkIndexDict__size];
        int index = 0;
        for (int i = 0; i < detailChunkIndexDict__keys.Length; i++)
        {
            var hashKeys = detailChunkIndexDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int detailChunkIndexDict_bucketCount = 2;
    public void detailChunkIndexDict_SetCapacity(int capacity)
    {
        int len = capacity / detailChunkIndexDict_bucketCount;
        detailChunkIndexDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            detailChunkIndexDict__keys[i] = new int[detailChunkIndexDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < detailChunkIndexDict_bucketCount; i++)
        {
            detailChunkIndexDict__keys[0][i] = int.MaxValue;
        }

        detailChunkIndexDict__values = new bool[len][];
        for (int i = 0; i < len; i++)
        {
            detailChunkIndexDict__values[i] = new bool[detailChunkIndexDict_bucketCount];
        }
    }

    public bool detailChunkIndexDict_HasItem(int key)
    {
        var index = detailChunkIndexDict_Hash(key);
        var hashKeys = detailChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int detailChunkIndexDict_Hash(int key)
    {
        var len = detailChunkIndexDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool detailChunkIndexDict_Add(int key, bool value)
    {
        int index = detailChunkIndexDict_Hash(key);
        var hashKeys = detailChunkIndexDict__keys[index];
        if (key == int.MaxValue)
        {
            Debug.LogError("not allowed key value");
        }

        if (index == 0)
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    detailChunkIndexDict__keys[index][i] = key;
                    detailChunkIndexDict__values[index][i] = value;
                    detailChunkIndexDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    detailChunkIndexDict__keys[index][i] = key;
                    detailChunkIndexDict__values[index][i] = value;
                    detailChunkIndexDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoolDictionary Add: Dictionary is full");
        var preLen = hashKeys.Length;
        detailChunkIndexDict_ExpandList(index);
        detailChunkIndexDict__keys[index][preLen] = key;
        detailChunkIndexDict__values[index][preLen] = value;
        detailChunkIndexDict__size++;
        return true;
    }

    const int detailChunkIndexDict_expand = 10;
    void detailChunkIndexDict_ExpandList(int index)
    {
        var hashKeys = detailChunkIndexDict__keys[index];
        var hashValues = detailChunkIndexDict__values[index];
        var len = detailChunkIndexDict__keys[index].Length + detailChunkIndexDict_expand;
        var newKeys = new int[len];
        var newValues = new bool[len];
        for (int i = 0; i < detailChunkIndexDict__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = detailChunkIndexDict__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        detailChunkIndexDict__keys[index] = newKeys;
        detailChunkIndexDict__values[index] = newValues;
    }

    public bool detailChunkIndexDict_AddOrSetValue(int key, bool value)
    {
        int index = detailChunkIndexDict_Hash(key);
        var hashKeys = detailChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    detailChunkIndexDict__keys[index][i] = key;
                    detailChunkIndexDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    detailChunkIndexDict__keys[index][i] = key;
                    detailChunkIndexDict__values[index][i] = value;
                    detailChunkIndexDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    detailChunkIndexDict__keys[index][i] = key;
                    detailChunkIndexDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    detailChunkIndexDict__keys[index][i] = key;
                    detailChunkIndexDict__values[index][i] = value;
                    detailChunkIndexDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogError("InkEyBoolDictionary AddOrSetValue: Dictionary is full");
        //return false;
        var preLen = hashKeys.Length;
        detailChunkIndexDict_ExpandList(index);
        detailChunkIndexDict__keys[index][preLen] = key;
        detailChunkIndexDict__values[index][preLen] = value;
        detailChunkIndexDict__size++;
        return true;
    }

    public void detailChunkIndexDict_SetValue(int key, bool value)
    {
        int index = detailChunkIndexDict_Hash(key);
        var hashKeys = detailChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    detailChunkIndexDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    detailChunkIndexDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public bool detailChunkIndexDict_GetValueOrDefault(int key, bool defaultValue)
    {
        int index = detailChunkIndexDict_Hash(key);
        var hashKeys = detailChunkIndexDict__keys[index];
        var hashValues = detailChunkIndexDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return defaultValue;
    }

    public bool detailChunkIndexDict_GetValue(int key)
    {
        int index = detailChunkIndexDict_Hash(key);
        var hashKeys = detailChunkIndexDict__keys[index];
        var hashValues = detailChunkIndexDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void detailChunkIndexDict_TryRemoveBatch(int[] keys, bool[] result)
    {
        for (int i = 0; i < keys.Length; i++)
        {
            result[i] = detailChunkIndexDict_TryRemove(keys[i]);
        }
    }

    public bool detailChunkIndexDict_TryRemove(int key)
    {
        int index = detailChunkIndexDict_Hash(key);
        var hashKeys = detailChunkIndexDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    detailChunkIndexDict__size--;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    detailChunkIndexDict__size--;
                    return true;
                }
            }
        }

        return false;
    }

    public void detailChunkIndexDict_Remove(int key)
    {
        if (!detailChunkIndexDict_TryRemove(key))
            Debug.LogError("Key not found");
    }

    bool DetailChunk(int chunkIndex)
    {
        //int chunkIndex=ToChunkIndex(xIndex,zIndex);
        if (loadedChunkIndexDict_GetValueOrDefault(chunkIndex, false) && !detailChunkIndexDict_GetValueOrDefault(chunkIndex, false))
        {
            if (outlineDict_HasItem(chunkIndex))
            {
                //Debug.Log("DetailChunk: "+chunkIndex);
                var outline = outlineDict_GetValue(chunkIndex);
                chunkToCells = chunkToCellsDict_GetValue(chunkIndex);
                cellInstanceIds = chunkToCellInstanceIdsDictionary_GetValue(chunkIndex);
                for (int i = 0; i < chunkToCells.Length; i++)
                {
                    brokenArr[i] = permanentBreakCellDictionary_GetValueOrDefault(ToGlobalCellIndex(i, chunkIndex), false);
                }

                var outlineId = chunkIndexToInstanceIdDictionary_GetValue(chunkIndex);
                meshCombiner_SwitchCombineMesh(false, outline, outlineId, chunkToCells, cellInstanceIds, brokenArr);
                detailChunkIndexDict_AddOrSetValue(chunkIndex, true);
                return true;
            }
            else
            {
                Debug.LogWarning("DetailChunk: chunkIndexDict not has item");
            }
        }

        return false;
    }

    bool[] brokenArr;
    bool UnDetailChunk(int chunkIndex)
    {
        //int chunkIndex=ToChunkIndex(xIndex,zIndex);
        if (loadedChunkIndexDict_GetValueOrDefault(chunkIndex, false) && detailChunkIndexDict_GetValueOrDefault(chunkIndex, false))
        {
            if (outlineDict_HasItem(chunkIndex))
            {
                //Debug.Log("UnDetailChunk: "+chunkIndex);
                var outline = outlineDict_GetValue(chunkIndex);
                chunkToCells = chunkToCellsDict_GetValue(chunkIndex);
                cellInstanceIds = chunkToCellInstanceIdsDictionary_GetValue(chunkIndex);
                var outlineId = chunkIndexToInstanceIdDictionary_GetValue(chunkIndex);
                meshCombiner_SwitchCombineMesh(true, outline, outlineId, chunkToCells, cellInstanceIds, brokenArr);
                detailChunkIndexDict_AddOrSetValue(chunkIndex, false);
                return true;
            }
            else
            {
                Debug.LogWarning("UnDetailChunk: chunkIndexDict not has item");
            }
        }

        return false;
    }

    GameObject[] chunkToCells;
    int[] cellInstanceIds;
    [SerializeField]
    float quickSearchRange = 6;
    public bool UnLoadChunk(int chunkIndex, bool setOnly = false)
    {
        //int chunkIndex=ToChunkIndex(xIndex,zIndex);
        if (!loadedChunkIndexDict_GetValueOrDefault(chunkIndex, false))
        {
            //Debug.Log("UnLoadChunk: not yet loaded");
            //遅延実行の関係上このケースは起こりえる
            return false;
        }

        if (outlineDict_HasItem(chunkIndex))
        {
            //Debug.Log("UnLoadChunk:"+chunkIndex);
            if (setOnly)
            {
                loadedChunkIndexDict_SetValue(chunkIndex, false);
            }
            else
            {
                loadedChunkIndexDict_AddOrSetValue(chunkIndex, false);
            }

            //chunkIndexDict.Remove(chunkIndex);
            var chunkMesh = outlineDict_GetValue(chunkIndex);
            //var id=chunkMesh.GetInstanceID();
            //Debug.Log("unload chunkID: "+id);
            if (!chunkToCellsDict_HasItem(chunkIndex))
            {
                Debug.LogWarning("unload chunk id not exists");
            }

            chunkToCells = chunkToCellsDict_GetValue(chunkIndex);
            cellInstanceIds = chunkToCellInstanceIdsDictionary_GetValue(chunkIndex);
            var chunkId = chunkIndexToInstanceIdDictionary_GetValue(chunkIndex);
            chunkPool_Return(chunkMesh, chunkId, true, false);
            // gc alloc debug only
            /*if(chunkMesh!=null){
                var id=chunkIndexToInstanceIdDictionary.GetValue(chunkIndex);
                chunkPool.Return(chunkMesh,id,true,false);
            } else {
                Debug.LogWarning("Chunk pool is empty!");
            }*/
            var biomeTypes = chunkIndexToCellBiomesDictionary_GetValue(chunkIndex);
            for (int i = 0; i < chunkToCells.Length; i++)
            {
                var cell = chunkToCells[i];
                // gc alloc debug only
                /*if(cell!=null){
                    var id = cellInstanceIds[i];
                    UnloadCell(cell,id,biomeTypes[i]);
                } else {
                    Debug.LogError("Cell pool is empty!");
                }*/
                var id = cellInstanceIds[i];
                UnloadCell(cell, id, biomeTypes[i]);
            }

            detailChunkIndexDict_AddOrSetValue(chunkIndex, false);
            return true;
        }

        return false;
    }

    int[][] permanentBreakCellDictionary__keys;
    bool[][] permanentBreakCellDictionary__values;
    int permanentBreakCellDictionary__size;
    public int permanentBreakCellDictionary_Count => permanentBreakCellDictionary__size;

    public int[] permanentBreakCellDictionary_GenerateKeysArray()
    {
        int[] keys = new int[permanentBreakCellDictionary__size];
        int index = 0;
        for (int i = 0; i < permanentBreakCellDictionary__keys.Length; i++)
        {
            var hashKeys = permanentBreakCellDictionary__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int permanentBreakCellDictionary_bucketCount = 2;
    public void permanentBreakCellDictionary_SetCapacity(int capacity)
    {
        int len = capacity / permanentBreakCellDictionary_bucketCount;
        permanentBreakCellDictionary__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            permanentBreakCellDictionary__keys[i] = new int[permanentBreakCellDictionary_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < permanentBreakCellDictionary_bucketCount; i++)
        {
            permanentBreakCellDictionary__keys[0][i] = int.MaxValue;
        }

        permanentBreakCellDictionary__values = new bool[len][];
        for (int i = 0; i < len; i++)
        {
            permanentBreakCellDictionary__values[i] = new bool[permanentBreakCellDictionary_bucketCount];
        }
    }

    public bool permanentBreakCellDictionary_HasItem(int key)
    {
        var index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int permanentBreakCellDictionary_Hash(int key)
    {
        var len = permanentBreakCellDictionary__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool permanentBreakCellDictionary_Add(int key, bool value)
    {
        int index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        if (key == int.MaxValue)
        {
            Debug.LogError("not allowed key value");
        }

        if (index == 0)
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    permanentBreakCellDictionary__keys[index][i] = key;
                    permanentBreakCellDictionary__values[index][i] = value;
                    permanentBreakCellDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("InkEyBoolDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    permanentBreakCellDictionary__keys[index][i] = key;
                    permanentBreakCellDictionary__values[index][i] = value;
                    permanentBreakCellDictionary__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoolDictionary Add: Dictionary is full");
        var preLen = hashKeys.Length;
        permanentBreakCellDictionary_ExpandList(index);
        permanentBreakCellDictionary__keys[index][preLen] = key;
        permanentBreakCellDictionary__values[index][preLen] = value;
        permanentBreakCellDictionary__size++;
        return true;
    }

    const int permanentBreakCellDictionary_expand = 10;
    void permanentBreakCellDictionary_ExpandList(int index)
    {
        var hashKeys = permanentBreakCellDictionary__keys[index];
        var hashValues = permanentBreakCellDictionary__values[index];
        var len = permanentBreakCellDictionary__keys[index].Length + permanentBreakCellDictionary_expand;
        var newKeys = new int[len];
        var newValues = new bool[len];
        for (int i = 0; i < permanentBreakCellDictionary__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = permanentBreakCellDictionary__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        permanentBreakCellDictionary__keys[index] = newKeys;
        permanentBreakCellDictionary__values[index] = newValues;
    }

    public bool permanentBreakCellDictionary_AddOrSetValue(int key, bool value)
    {
        int index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    permanentBreakCellDictionary__keys[index][i] = key;
                    permanentBreakCellDictionary__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    permanentBreakCellDictionary__keys[index][i] = key;
                    permanentBreakCellDictionary__values[index][i] = value;
                    permanentBreakCellDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    permanentBreakCellDictionary__keys[index][i] = key;
                    permanentBreakCellDictionary__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    permanentBreakCellDictionary__keys[index][i] = key;
                    permanentBreakCellDictionary__values[index][i] = value;
                    permanentBreakCellDictionary__size++;
                    return true;
                }
            }
        }

        //Debug.LogError("InkEyBoolDictionary AddOrSetValue: Dictionary is full");
        //return false;
        var preLen = hashKeys.Length;
        permanentBreakCellDictionary_ExpandList(index);
        permanentBreakCellDictionary__keys[index][preLen] = key;
        permanentBreakCellDictionary__values[index][preLen] = value;
        permanentBreakCellDictionary__size++;
        return true;
    }

    public void permanentBreakCellDictionary_SetValue(int key, bool value)
    {
        int index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    permanentBreakCellDictionary__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    permanentBreakCellDictionary__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public bool permanentBreakCellDictionary_GetValueOrDefault(int key, bool defaultValue)
    {
        int index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        var hashValues = permanentBreakCellDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return defaultValue;
    }

    public bool permanentBreakCellDictionary_GetValue(int key)
    {
        int index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        var hashValues = permanentBreakCellDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void permanentBreakCellDictionary_TryRemoveBatch(int[] keys, bool[] result)
    {
        for (int i = 0; i < keys.Length; i++)
        {
            result[i] = permanentBreakCellDictionary_TryRemove(keys[i]);
        }
    }

    public bool permanentBreakCellDictionary_TryRemove(int key)
    {
        int index = permanentBreakCellDictionary_Hash(key);
        var hashKeys = permanentBreakCellDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    permanentBreakCellDictionary__size--;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    permanentBreakCellDictionary__size--;
                    return true;
                }
            }
        }

        return false;
    }

    public void permanentBreakCellDictionary_Remove(int key)
    {
        if (!permanentBreakCellDictionary_TryRemove(key))
            Debug.LogError("Key not found");
    }

    int[][] chunkIndexToCellBiomesDictionary__keys;
    Biome[][][] chunkIndexToCellBiomesDictionary__values;
    int chunkIndexToCellBiomesDictionary__size;
    public int chunkIndexToCellBiomesDictionary_Count => chunkIndexToCellBiomesDictionary__size;

    const int chunkIndexToCellBiomesDictionary_bucketCount = 2;
    public void chunkIndexToCellBiomesDictionary_SetCapacity(int capacity)
    {
        int len = capacity / chunkIndexToCellBiomesDictionary_bucketCount;
        chunkIndexToCellBiomesDictionary__keys = new int[len][];
        for (int i = 0; i < chunkIndexToCellBiomesDictionary__keys.Length; i++)
        {
            chunkIndexToCellBiomesDictionary__keys[i] = new int[chunkIndexToCellBiomesDictionary_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < chunkIndexToCellBiomesDictionary_bucketCount; i++)
        {
            chunkIndexToCellBiomesDictionary__keys[0][i] = int.MaxValue;
        }

        chunkIndexToCellBiomesDictionary__values = new Biome[len][][];
        for (int i = 0; i < chunkIndexToCellBiomesDictionary__values.Length; i++)
        {
            chunkIndexToCellBiomesDictionary__values[i] = new Biome[chunkIndexToCellBiomesDictionary_bucketCount][];
        }
    }

    public bool chunkIndexToCellBiomesDictionary_HasItem(int key)
    {
        var index = chunkIndexToCellBiomesDictionary_Hash(key);
        var hashKeys = chunkIndexToCellBiomesDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int chunkIndexToCellBiomesDictionary_Hash(int key)
    {
        var len = chunkIndexToCellBiomesDictionary__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public int[] chunkIndexToCellBiomesDictionary_GenerateKeysArray()
    {
        int[] keys = new int[chunkIndexToCellBiomesDictionary__size];
        int index = 0;
        for (int i = 0; i < chunkIndexToCellBiomesDictionary__keys.Length; i++)
        {
            var hashKeys = chunkIndexToCellBiomesDictionary__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    public bool chunkIndexToCellBiomesDictionary_Add(int key, Biome[] value)
    {
        int index = chunkIndexToCellBiomesDictionary_Hash(key);
        var hashKeys = chunkIndexToCellBiomesDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBiomeArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkIndexToCellBiomesDictionary__keys[index][i] = key;
                    chunkIndexToCellBiomesDictionary__values[index][i] = value;
                    chunkIndexToCellBiomesDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBiomeArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    chunkIndexToCellBiomesDictionary__keys[index][i] = key;
                    chunkIndexToCellBiomesDictionary__values[index][i] = value;
                    chunkIndexToCellBiomesDictionary__size++;
                    return true;
                }
            }
        }

        chunkIndexToCellBiomesDictionary_ExpandList(index);
        var preLen = hashKeys.Length;
        chunkIndexToCellBiomesDictionary__keys[index][preLen] = key;
        chunkIndexToCellBiomesDictionary__values[index][preLen] = value;
        chunkIndexToCellBiomesDictionary__size++;
        return true;
    }

    const int chunkIndexToCellBiomesDictionary_expand = 10;
    void chunkIndexToCellBiomesDictionary_ExpandList(int index)
    {
        var hashKeys = chunkIndexToCellBiomesDictionary__keys[index];
        var hashValues = chunkIndexToCellBiomesDictionary__values[index];
        var len = chunkIndexToCellBiomesDictionary__keys[index].Length + chunkIndexToCellBiomesDictionary_expand;
        var newKeys = new int[len];
        var newValues = new Biome[len][];
        for (int i = 0; i < chunkIndexToCellBiomesDictionary__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = chunkIndexToCellBiomesDictionary__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        chunkIndexToCellBiomesDictionary__keys[index] = newKeys;
        chunkIndexToCellBiomesDictionary__values[index] = newValues;
    }

    public void chunkIndexToCellBiomesDictionary_AddOrSetValue(int key, Biome[] value)
    {
        int index = chunkIndexToCellBiomesDictionary_Hash(key);
        var hashKeys = chunkIndexToCellBiomesDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkIndexToCellBiomesDictionary__keys[index][i] = key;
                    chunkIndexToCellBiomesDictionary__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkIndexToCellBiomesDictionary__keys[index][i] = key;
                    chunkIndexToCellBiomesDictionary__values[index][i] = value;
                    chunkIndexToCellBiomesDictionary__size++;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkIndexToCellBiomesDictionary__keys[index][i] = key;
                    chunkIndexToCellBiomesDictionary__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == default)
                {
                    chunkIndexToCellBiomesDictionary__keys[index][i] = key;
                    chunkIndexToCellBiomesDictionary__values[index][i] = value;
                    chunkIndexToCellBiomesDictionary__size++;
                    return;
                }
            }
        }

        var preLen = hashKeys.Length;
        chunkIndexToCellBiomesDictionary_ExpandList(index);
        chunkIndexToCellBiomesDictionary__keys[index][preLen] = key;
        chunkIndexToCellBiomesDictionary__values[index][preLen] = value;
        chunkIndexToCellBiomesDictionary__size++;
    }

    public void chunkIndexToCellBiomesDictionary_SetValue(int key, Biome[] value)
    {
        int index = chunkIndexToCellBiomesDictionary_Hash(key);
        var hashKeys = chunkIndexToCellBiomesDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkIndexToCellBiomesDictionary__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkIndexToCellBiomesDictionary__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public Biome[] chunkIndexToCellBiomesDictionary_GetValue(int key)
    {
        int index = chunkIndexToCellBiomesDictionary_Hash(key);
        var hashKeys = chunkIndexToCellBiomesDictionary__keys[index];
        var hashValues = chunkIndexToCellBiomesDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void chunkIndexToCellBiomesDictionary_Remove(int key)
    {
        int index = chunkIndexToCellBiomesDictionary_Hash(key);
        var hashKeys = chunkIndexToCellBiomesDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    chunkIndexToCellBiomesDictionary__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    chunkIndexToCellBiomesDictionary__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    int[][] instanceIDToGlobalCellIndexDictionary__keys;
    int[][] instanceIDToGlobalCellIndexDictionary__values;
    int instanceIDToGlobalCellIndexDictionary__size;
    public int instanceIDToGlobalCellIndexDictionary_Count => instanceIDToGlobalCellIndexDictionary__size;

    const int instanceIDToGlobalCellIndexDictionary_bucketCount = 2;
    public void instanceIDToGlobalCellIndexDictionary_SetCapacity(int capacity)
    {
        int len = capacity / instanceIDToGlobalCellIndexDictionary_bucketCount;
        instanceIDToGlobalCellIndexDictionary__keys = new int[len][];
        for (int i = 0; i < instanceIDToGlobalCellIndexDictionary__keys.Length; i++)
        {
            instanceIDToGlobalCellIndexDictionary__keys[i] = new int[instanceIDToGlobalCellIndexDictionary_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < instanceIDToGlobalCellIndexDictionary_bucketCount; i++)
        {
            instanceIDToGlobalCellIndexDictionary__keys[0][i] = int.MaxValue;
        }

        instanceIDToGlobalCellIndexDictionary__values = new int[len][];
        for (int i = 0; i < instanceIDToGlobalCellIndexDictionary__values.Length; i++)
        {
            instanceIDToGlobalCellIndexDictionary__values[i] = new int[instanceIDToGlobalCellIndexDictionary_bucketCount];
        }
    }

    public bool instanceIDToGlobalCellIndexDictionary_HasItem(int key)
    {
        var index = instanceIDToGlobalCellIndexDictionary_Hash(key);
        var hashKeys = instanceIDToGlobalCellIndexDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int instanceIDToGlobalCellIndexDictionary_Hash(int key)
    {
        var len = instanceIDToGlobalCellIndexDictionary__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public int[] instanceIDToGlobalCellIndexDictionary_GenerateKeysArray()
    {
        int[] keys = new int[instanceIDToGlobalCellIndexDictionary__size];
        int index = 0;
        for (int i = 0; i < instanceIDToGlobalCellIndexDictionary__keys.Length; i++)
        {
            var hashKeys = instanceIDToGlobalCellIndexDictionary__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    public bool instanceIDToGlobalCellIndexDictionary_Add(int key, int value)
    {
        int index = instanceIDToGlobalCellIndexDictionary_Hash(key);
        var hashKeys = instanceIDToGlobalCellIndexDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyintArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    instanceIDToGlobalCellIndexDictionary__keys[index][i] = key;
                    instanceIDToGlobalCellIndexDictionary__values[index][i] = value;
                    instanceIDToGlobalCellIndexDictionary__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyintArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    instanceIDToGlobalCellIndexDictionary__keys[index][i] = key;
                    instanceIDToGlobalCellIndexDictionary__values[index][i] = value;
                    instanceIDToGlobalCellIndexDictionary__size++;
                    return true;
                }
            }
        }

        instanceIDToGlobalCellIndexDictionary_ExpandList(index);
        var preLen = hashKeys.Length;
        instanceIDToGlobalCellIndexDictionary__keys[index][preLen] = key;
        instanceIDToGlobalCellIndexDictionary__values[index][preLen] = value;
        instanceIDToGlobalCellIndexDictionary__size++;
        return true;
    }

    const int instanceIDToGlobalCellIndexDictionary_expand = 10;
    void instanceIDToGlobalCellIndexDictionary_ExpandList(int index)
    {
        var hashKeys = instanceIDToGlobalCellIndexDictionary__keys[index];
        var hashValues = instanceIDToGlobalCellIndexDictionary__values[index];
        var len = instanceIDToGlobalCellIndexDictionary__keys[index].Length + instanceIDToGlobalCellIndexDictionary_expand;
        var newKeys = new int[len];
        var newValues = new int[len];
        for (int i = 0; i < instanceIDToGlobalCellIndexDictionary__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = instanceIDToGlobalCellIndexDictionary__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        instanceIDToGlobalCellIndexDictionary__keys[index] = newKeys;
        instanceIDToGlobalCellIndexDictionary__values[index] = newValues;
    }

    public void instanceIDToGlobalCellIndexDictionary_AddOrSetValue(int key, int value)
    {
        int index = instanceIDToGlobalCellIndexDictionary_Hash(key);
        var hashKeys = instanceIDToGlobalCellIndexDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    instanceIDToGlobalCellIndexDictionary__keys[index][i] = key;
                    instanceIDToGlobalCellIndexDictionary__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    instanceIDToGlobalCellIndexDictionary__keys[index][i] = key;
                    instanceIDToGlobalCellIndexDictionary__values[index][i] = value;
                    instanceIDToGlobalCellIndexDictionary__size++;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    instanceIDToGlobalCellIndexDictionary__keys[index][i] = key;
                    instanceIDToGlobalCellIndexDictionary__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == default)
                {
                    instanceIDToGlobalCellIndexDictionary__keys[index][i] = key;
                    instanceIDToGlobalCellIndexDictionary__values[index][i] = value;
                    instanceIDToGlobalCellIndexDictionary__size++;
                    return;
                }
            }
        }

        var preLen = hashKeys.Length;
        instanceIDToGlobalCellIndexDictionary_ExpandList(index);
        instanceIDToGlobalCellIndexDictionary__keys[index][preLen] = key;
        instanceIDToGlobalCellIndexDictionary__values[index][preLen] = value;
        instanceIDToGlobalCellIndexDictionary__size++;
    }

    public void instanceIDToGlobalCellIndexDictionary_SetValue(int key, int value)
    {
        int index = instanceIDToGlobalCellIndexDictionary_Hash(key);
        var hashKeys = instanceIDToGlobalCellIndexDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    instanceIDToGlobalCellIndexDictionary__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    instanceIDToGlobalCellIndexDictionary__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public int instanceIDToGlobalCellIndexDictionary_GetValue(int key)
    {
        int index = instanceIDToGlobalCellIndexDictionary_Hash(key);
        var hashKeys = instanceIDToGlobalCellIndexDictionary__keys[index];
        var hashValues = instanceIDToGlobalCellIndexDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public int instanceIDToGlobalCellIndexDictionary_GetValueOrDefault(int key, int defaultValue)
    {
        int index = instanceIDToGlobalCellIndexDictionary_Hash(key);
        var hashKeys = instanceIDToGlobalCellIndexDictionary__keys[index];
        var hashValues = instanceIDToGlobalCellIndexDictionary__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return defaultValue;
    }

    public void instanceIDToGlobalCellIndexDictionary_Remove(int key)
    {
        int index = instanceIDToGlobalCellIndexDictionary_Hash(key);
        var hashKeys = instanceIDToGlobalCellIndexDictionary__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    instanceIDToGlobalCellIndexDictionary__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    instanceIDToGlobalCellIndexDictionary__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public override void BreakCell(GameObject cell)
    {
        // gc alloc debug only
        /*if(cell!=null){
            var cellId=cell.GetInstanceID();
            var globalCellIndex=instanceIDToGlobalCellIndexDictionary.GetValue(cellId);
            permanentBreakCellDictionary.AddOrSetValue(globalCellIndex,true);
            //tempBreakCellDictionary.AddOrSetValue(cellId,true); // may colision this is beacause not broken cells disappaer bug haapens 
            UnloadCell(cell,cellId);
        } else {
            Debug.LogWarning("Cell pool is empty!");
        }*/
        var cellId = cell.GetInstanceID();
        var globalCellIndex = instanceIDToGlobalCellIndexDictionary_GetValue(cellId);
        permanentBreakCellDictionary_AddOrSetValue(globalCellIndex, true);
        //tempBreakCellDictionary.AddOrSetValue(cellId,true); // may colision this is beacause not broken cells disappaer bug haapens 
        UnloadCell(cell, cellId);
    }

    public override void BreakCells(GameObject[] cells, int length)
    {
        for (int i = 0; i < length; i++)
        {
            var cell = cells[i];
            var cellId = cell.GetInstanceID();
            var globalCellIndex = instanceIDToGlobalCellIndexDictionary_GetValue(cellId);
            permanentBreakCellDictionary_AddOrSetValue(globalCellIndex, true);
            //tempBreakCellDictionary.AddOrSetValue(cellId,true); // may colision this is beacause not broken cells disappaer bug haapens 
            UnloadCell(cell, cellId);
        }
    }

    void UnloadCell(GameObject cell, int id, Biome biomeType)
    {
        BiomeReturn(biomeType, cell, id);
    }

    void UnloadCell(GameObject cell, int id)
    {
        if (grassPool_IsMine(cell))
        {
            grassPool_Return(cell, id, true);
        }
        else if (sandPool_IsMine(cell))
        {
            sandPool_Return(cell, id, true);
        }
        else if (waterPool_IsMine(cell))
        {
            waterPool_Return(cell, id, true);
        }
        else if (rockPool_IsMine(cell))
        {
            rockPool_Return(cell, id, true);
        }
        else if (dirtPool_IsMine(cell))
        {
            dirtPool_Return(cell, id, true);
        }
        else if (desertPool_IsMine(cell))
        {
            desertPool_Return(cell, id, true);
        }
        else if (tundraPool_IsMine(cell))
        {
            tundraPool_Return(cell, id, true);
        }
        else if (darkPool_IsMine(cell))
        {
            darkPool_Return(cell, id, true);
        }
        else
        {
            Debug.LogWarning("Cell " + cell.name + " pool is empty! Or Make sure obj is cell type");
        }
    }

    float scale => settings_scale;

    float TileScale => settings_TileScale;

    float xValue, zValue, perlinValue, height, xTValue, zTValue, xHValue, zHValue;
    Vector3 spawnPos;
    [UdonSynced]
    float _seedX;
    [UdonSynced]
    float _seedZ;
    [UdonSynced]
    float _seedTX;
    [UdonSynced]
    float _seedTZ;
    [UdonSynced]
    float _seedHX;
    [UdonSynced]
    float _seedHZ;
    [SerializeField]
    Transform chunkParent;
    public bool meshCombiner_itemOperator_SetActive(GameObject obj, bool active)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        meshCombiner_itemOperator_col.enabled = active;
        meshCombiner_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    [SerializeField]
    int meshCombiner_itemOperator_capacity = 300000;
    void meshCombiner_itemOperator_Start()
    {
        meshCombiner_itemOperator_idToColDict_SetCapacity(meshCombiner_itemOperator_capacity);
        meshCombiner_itemOperator_idToMeshDict_SetCapacity(meshCombiner_itemOperator_capacity);
    }

    int[][] meshCombiner_itemOperator_idToColDict__keys;
    BoxCollider[][] meshCombiner_itemOperator_idToColDict__values;
    int meshCombiner_itemOperator_idToColDict__size;
    public int meshCombiner_itemOperator_idToColDict_Count => meshCombiner_itemOperator_idToColDict__size;

    public int[] meshCombiner_itemOperator_idToColDict_GenerateKeysArray()
    {
        int[] keys = new int[meshCombiner_itemOperator_idToColDict__size];
        int index = 0;
        for (int i = 0; i < meshCombiner_itemOperator_idToColDict__keys.Length; i++)
        {
            var hashKeys = meshCombiner_itemOperator_idToColDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int meshCombiner_itemOperator_idToColDict_bucketCount = 2;
    public int meshCombiner_itemOperator_idToColDict_KeyLength => meshCombiner_itemOperator_idToColDict__keys.Length;

    public void meshCombiner_itemOperator_idToColDict_SetCapacity(int capacity)
    {
        int len = meshCombiner_itemOperator_capacity / meshCombiner_itemOperator_idToColDict_bucketCount;
        meshCombiner_itemOperator_idToColDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            meshCombiner_itemOperator_idToColDict__keys[i] = new int[meshCombiner_itemOperator_idToColDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < meshCombiner_itemOperator_idToColDict_bucketCount; i++)
        {
            meshCombiner_itemOperator_idToColDict__keys[0][i] = int.MaxValue;
        }

        meshCombiner_itemOperator_idToColDict__values = new BoxCollider[len][];
        for (int i = 0; i < len; i++)
        {
            meshCombiner_itemOperator_idToColDict__values[i] = new BoxCollider[meshCombiner_itemOperator_idToColDict_bucketCount];
        }
    }

    public bool meshCombiner_itemOperator_idToColDict_HasItem(int key)
    {
        var index = meshCombiner_itemOperator_idToColDict_Hash(key);
        var hashKeys = meshCombiner_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int meshCombiner_itemOperator_idToColDict_Hash(int key)
    {
        var len = meshCombiner_itemOperator_idToColDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool meshCombiner_itemOperator_idToColDict_Add(int key, BoxCollider value)
    {
        int index = meshCombiner_itemOperator_idToColDict_Hash(key);
        var hashKeys = meshCombiner_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBoxColliderDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    meshCombiner_itemOperator_idToColDict__keys[index][i] = key;
                    meshCombiner_itemOperator_idToColDict__values[index][i] = value;
                    meshCombiner_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyBoxColliderDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    meshCombiner_itemOperator_idToColDict__keys[index][i] = key;
                    meshCombiner_itemOperator_idToColDict__values[index][i] = value;
                    meshCombiner_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoxColliderDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        meshCombiner_itemOperator_idToColDict_ExpandList(index);
        meshCombiner_itemOperator_idToColDict__keys[index][preLen] = key;
        meshCombiner_itemOperator_idToColDict__values[index][preLen] = value;
        meshCombiner_itemOperator_idToColDict__size++;
        return true;
    }

    const int meshCombiner_itemOperator_idToColDict_expand = 10;
    void meshCombiner_itemOperator_idToColDict_ExpandList(int index)
    {
        var hashKeys = meshCombiner_itemOperator_idToColDict__keys[index];
        var hashValues = meshCombiner_itemOperator_idToColDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + meshCombiner_itemOperator_idToColDict_expand;
        var newKeys = new int[len];
        var newValues = new BoxCollider[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        meshCombiner_itemOperator_idToColDict__keys[index] = newKeys;
        meshCombiner_itemOperator_idToColDict__values[index] = newValues;
    }

    public bool meshCombiner_itemOperator_idToColDict_AddOrSetValue(int key, BoxCollider value)
    {
        int index = meshCombiner_itemOperator_idToColDict_Hash(key);
        var hashKeys = meshCombiner_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    meshCombiner_itemOperator_idToColDict__keys[index][i] = key;
                    meshCombiner_itemOperator_idToColDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    meshCombiner_itemOperator_idToColDict__keys[index][i] = key;
                    meshCombiner_itemOperator_idToColDict__values[index][i] = value;
                    meshCombiner_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    meshCombiner_itemOperator_idToColDict__keys[index][i] = key;
                    meshCombiner_itemOperator_idToColDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    meshCombiner_itemOperator_idToColDict__keys[index][i] = key;
                    meshCombiner_itemOperator_idToColDict__values[index][i] = value;
                    meshCombiner_itemOperator_idToColDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyBoxColliderDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        meshCombiner_itemOperator_idToColDict_ExpandList(index);
        meshCombiner_itemOperator_idToColDict__keys[index][preLen] = key;
        meshCombiner_itemOperator_idToColDict__values[index][preLen] = value;
        meshCombiner_itemOperator_idToColDict__size++;
        return true;
    }

    public void meshCombiner_itemOperator_idToColDict_SetValue(int key, BoxCollider value)
    {
        int index = meshCombiner_itemOperator_idToColDict_Hash(key);
        var hashKeys = meshCombiner_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    meshCombiner_itemOperator_idToColDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    meshCombiner_itemOperator_idToColDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public BoxCollider meshCombiner_itemOperator_idToColDict_GetValue(int key)
    {
        int index = meshCombiner_itemOperator_idToColDict_Hash(key);
        var hashKeys = meshCombiner_itemOperator_idToColDict__keys[index];
        var hashValues = meshCombiner_itemOperator_idToColDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void meshCombiner_itemOperator_idToColDict_Remove(int key)
    {
        int index = meshCombiner_itemOperator_idToColDict_Hash(key);
        var hashKeys = meshCombiner_itemOperator_idToColDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    meshCombiner_itemOperator_idToColDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    meshCombiner_itemOperator_idToColDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    int[][] meshCombiner_itemOperator_idToMeshDict__keys;
    MeshRenderer[][] meshCombiner_itemOperator_idToMeshDict__values;
    int meshCombiner_itemOperator_idToMeshDict__size;
    public int meshCombiner_itemOperator_idToMeshDict_Count => meshCombiner_itemOperator_idToMeshDict__size;

    public int[] meshCombiner_itemOperator_idToMeshDict_GenerateKeysArray()
    {
        int[] keys = new int[meshCombiner_itemOperator_idToMeshDict__size];
        int index = 0;
        for (int i = 0; i < meshCombiner_itemOperator_idToMeshDict__keys.Length; i++)
        {
            var hashKeys = meshCombiner_itemOperator_idToMeshDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int meshCombiner_itemOperator_idToMeshDict_bucketCount = 2;
    public int meshCombiner_itemOperator_idToMeshDict_KeyLength => meshCombiner_itemOperator_idToMeshDict__keys.Length;

    public void meshCombiner_itemOperator_idToMeshDict_SetCapacity(int capacity)
    {
        int len = meshCombiner_itemOperator_capacity / meshCombiner_itemOperator_idToMeshDict_bucketCount;
        meshCombiner_itemOperator_idToMeshDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            meshCombiner_itemOperator_idToMeshDict__keys[i] = new int[meshCombiner_itemOperator_idToMeshDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < meshCombiner_itemOperator_idToMeshDict_bucketCount; i++)
        {
            meshCombiner_itemOperator_idToMeshDict__keys[0][i] = int.MaxValue;
        }

        meshCombiner_itemOperator_idToMeshDict__values = new MeshRenderer[len][];
        for (int i = 0; i < len; i++)
        {
            meshCombiner_itemOperator_idToMeshDict__values[i] = new MeshRenderer[meshCombiner_itemOperator_idToMeshDict_bucketCount];
        }
    }

    public bool meshCombiner_itemOperator_idToMeshDict_HasItem(int key)
    {
        var index = meshCombiner_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = meshCombiner_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int meshCombiner_itemOperator_idToMeshDict_Hash(int key)
    {
        var len = meshCombiner_itemOperator_idToMeshDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool meshCombiner_itemOperator_idToMeshDict_Add(int key, MeshRenderer value)
    {
        int index = meshCombiner_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = meshCombiner_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyMeshRendererDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    meshCombiner_itemOperator_idToMeshDict__keys[index][i] = key;
                    meshCombiner_itemOperator_idToMeshDict__values[index][i] = value;
                    meshCombiner_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyMeshRendererDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    meshCombiner_itemOperator_idToMeshDict__keys[index][i] = key;
                    meshCombiner_itemOperator_idToMeshDict__values[index][i] = value;
                    meshCombiner_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyMeshRendererDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        meshCombiner_itemOperator_idToMeshDict_ExpandList(index);
        meshCombiner_itemOperator_idToMeshDict__keys[index][preLen] = key;
        meshCombiner_itemOperator_idToMeshDict__values[index][preLen] = value;
        meshCombiner_itemOperator_idToMeshDict__size++;
        return true;
    }

    const int meshCombiner_itemOperator_idToMeshDict_expand = 10;
    void meshCombiner_itemOperator_idToMeshDict_ExpandList(int index)
    {
        var hashKeys = meshCombiner_itemOperator_idToMeshDict__keys[index];
        var hashValues = meshCombiner_itemOperator_idToMeshDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + meshCombiner_itemOperator_idToMeshDict_expand;
        var newKeys = new int[len];
        var newValues = new MeshRenderer[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        meshCombiner_itemOperator_idToMeshDict__keys[index] = newKeys;
        meshCombiner_itemOperator_idToMeshDict__values[index] = newValues;
    }

    public bool meshCombiner_itemOperator_idToMeshDict_AddOrSetValue(int key, MeshRenderer value)
    {
        int index = meshCombiner_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = meshCombiner_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    meshCombiner_itemOperator_idToMeshDict__keys[index][i] = key;
                    meshCombiner_itemOperator_idToMeshDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    meshCombiner_itemOperator_idToMeshDict__keys[index][i] = key;
                    meshCombiner_itemOperator_idToMeshDict__values[index][i] = value;
                    meshCombiner_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    meshCombiner_itemOperator_idToMeshDict__keys[index][i] = key;
                    meshCombiner_itemOperator_idToMeshDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    meshCombiner_itemOperator_idToMeshDict__keys[index][i] = key;
                    meshCombiner_itemOperator_idToMeshDict__values[index][i] = value;
                    meshCombiner_itemOperator_idToMeshDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyMeshRendererDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        meshCombiner_itemOperator_idToMeshDict_ExpandList(index);
        meshCombiner_itemOperator_idToMeshDict__keys[index][preLen] = key;
        meshCombiner_itemOperator_idToMeshDict__values[index][preLen] = value;
        meshCombiner_itemOperator_idToMeshDict__size++;
        return true;
    }

    public void meshCombiner_itemOperator_idToMeshDict_SetValue(int key, MeshRenderer value)
    {
        int index = meshCombiner_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = meshCombiner_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    meshCombiner_itemOperator_idToMeshDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    meshCombiner_itemOperator_idToMeshDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public MeshRenderer meshCombiner_itemOperator_idToMeshDict_GetValue(int key)
    {
        int index = meshCombiner_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = meshCombiner_itemOperator_idToMeshDict__keys[index];
        var hashValues = meshCombiner_itemOperator_idToMeshDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void meshCombiner_itemOperator_idToMeshDict_Remove(int key)
    {
        int index = meshCombiner_itemOperator_idToMeshDict_Hash(key);
        var hashKeys = meshCombiner_itemOperator_idToMeshDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    meshCombiner_itemOperator_idToMeshDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    meshCombiner_itemOperator_idToMeshDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    BoxCollider meshCombiner_itemOperator_col;
    MeshRenderer meshCombiner_itemOperator_mesh;
    public bool meshCombiner_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        if (meshCombiner_itemOperator_idToColDict_HasItem(instanceID))
        {
            meshCombiner_itemOperator_col = meshCombiner_itemOperator_idToColDict_GetValue(instanceID);
        }
        else
        {
            meshCombiner_itemOperator_col = obj.GetComponent<BoxCollider>();
            meshCombiner_itemOperator_idToColDict_Add(instanceID, meshCombiner_itemOperator_col);
        }

        if (meshCombiner_itemOperator_idToMeshDict_HasItem(instanceID))
        {
            meshCombiner_itemOperator_mesh = meshCombiner_itemOperator_idToMeshDict_GetValue(instanceID);
        }
        else
        {
            meshCombiner_itemOperator_mesh = obj.GetComponent<MeshRenderer>();
            meshCombiner_itemOperator_idToMeshDict_Add(instanceID, meshCombiner_itemOperator_mesh);
        }

        meshCombiner_itemOperator_col.enabled = active;
        meshCombiner_itemOperator_mesh.enabled = active;
        //  mesh.material.SetFloat("_UpDown",0); // コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    public bool meshCombiner_itemOperator_IsActive(GameObject obj)
    {
        BoxCollider col = obj.GetComponent<BoxCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (meshCombiner_itemOperator_col == null || meshCombiner_itemOperator_mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: BoxCollider or MeshRenderer is null!");
            return false;
        }

        return meshCombiner_itemOperator_col.enabled && meshCombiner_itemOperator_mesh.enabled;
    }

    public bool meshCombiner_chunkOperator_SetActive(GameObject obj, bool active)
    {
        MeshCollider col = obj.GetComponent<MeshCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        /*if(col==null||mesh==null){
            Debug.LogError("TilePoolItemOperator: MeshCollider or MeshRenderer is null!");
            return false;
        } gc alloc */
        col.enabled = active;
        mesh.enabled = active;
        //mesh.material.SetFloat("_UpDown",0);// コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    //[SerializeField,UnrollAttribute]IntToMeshColliderDictionary idToColDict;
    //[SerializeField,UnrollAttribute]IntToMeshRendererDictionary idToMeshDict;
    /*[SerializeField]int capacity=100000;

    void Start()
    {
        idToColDict.SetCapacity(capacity);
        idToMeshDict.SetCapacity(capacity);
    }*/
    public bool meshCombiner_chunkOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        return meshCombiner_chunkOperator_SetActive(obj, active);
    /*MeshCollider col;
        if(idToColDict.HasItem(instanceID)){
            col=idToColDict.GetValue(instanceID);
        }else{
            col = obj.GetComponent<MeshCollider>();
            idToColDict.Add(instanceID,col);
        }
        MeshRenderer mesh;
        if(idToMeshDict.HasItem(instanceID)){
            mesh=idToMeshDict.GetValue(instanceID);
        }else{
            mesh = obj.GetComponent<MeshRenderer>();
            idToMeshDict.Add(instanceID,mesh);
        }
        col.enabled=active;
        mesh.enabled=active;
        return true;*/
    }

    public bool meshCombiner_chunkOperator_IsActive(GameObject obj)
    {
        MeshCollider col = obj.GetComponent<MeshCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: MeshCollider or MeshRenderer is null!");
            return false;
        }

        return mesh.enabled;
    }

    public int meshCombiner_mapGeneratorSettings_chunkSize = 3;
    public int meshCombiner_mapGeneratorSettings_chunkSizeY = 3;
    public int meshCombiner_mapGeneratorSettings_batchCount = 1000;
    public int meshCombiner_mapGeneratorSettings_chunkWidth = 100;
    public int meshCombiner_mapGeneratorSettings_chunkDepth = 100;
    public int meshCombiner_mapGeneratorSettings_fieldHeight = 3;
    public float meshCombiner_mapGeneratorSettings_scale = 0.015f;
    public float meshCombiner_mapGeneratorSettings_scaleT = 0.003f;
    public float meshCombiner_mapGeneratorSettings_scaleH = 0.003f;
    public float meshCombiner_mapGeneratorSettings_cellAnimationTime = 1f;
    public float meshCombiner_mapGeneratorSettings_TileScale = 1.5f;
    public float meshCombiner_mapGeneratorSettings_chunkLoadRange = 6f;
    public float meshCombiner_mapGeneratorSettings_chunkUnLoadRange = 12f;
    public float meshCombiner_mapGeneratorSettings_chunkDetailRange = 1f;
    public float meshCombiner_mapGeneratorSettings_generateAdditionalInterval = 5f;
    public float meshCombiner_mapGeneratorSettings_searchAdditionalInterval = 3f;
    public float meshCombiner_mapGeneratorSettings_removeBatchCount = 100;
    public float meshCombiner_mapGeneratorSettings_removeInterval = 0.1f;
    public float meshCombiner_mapGeneratorSettings_waterPercentage = 0.2f;
    public int meshCombiner_mapGeneratorSettings_operationBatchCount = 1;
    public int meshCombiner_mapGeneratorSettings_searchBatchCount = 30;
    public bool meshCombiner_mapGeneratorSettings_removeOn = true;
    public bool meshCombiner_mapGeneratorSettings_searchOn = true;
    /*public  GameObject[] GetAllParts(int count){
        var target=allPartsCache[count];
        if(target==null){
            target=new GameObject[count];
            allPartsCache[count]=target;
        }
        return target;

    }*/
    //CombineInstance[][] combineCache ;
    //GameObject[][] allPartsCache;
    void meshCombiner_Start()
    {
        meshCombiner_itemOperator_Start();
        var size = meshCombiner_mapGeneratorSettings_chunkSize;
    //combineCache = new CombineInstance[size*size*size][];
    //allPartsCache = new GameObject[10][];
    }

    public void meshCombiner_SwitchCombineMesh(bool active, GameObject outline, int outlineId, GameObject[] cells, int[] cellIds, bool[] brokenArr)
    {
        meshCombiner_chunkOperator_SetActive(outline, outlineId, active);
        /*for(int i=1;i<outlines.Length;i++){
            itemOperator.SetActive(outlines[i],!active);
        }*/
        if (active)
        {
            for (int i = 0; i < cells.Length; i++)
            {
                meshCombiner_itemOperator_SetActive(cells[i], cellIds[i], false);
            }
        }
        else
        {
            for (int i = 0; i < cells.Length; i++)
            {
                meshCombiner_itemOperator_SetActive(cells[i], cellIds[i], !brokenArr[i]);
            }
        }
    }

    CombineInstance[] meshCombiner_combine;
    MeshFilter meshCombiner_parentMeshFilter;
    MeshCollider meshCombiner_meshCol;
    public GameObject meshCombiner_CombineMesh(GameObject fieldParent, MeshFilter[] meshFilters, int[] ids, bool isInDetailRange, bool[] brokenArr, bool hasItem)
    {
        meshCombiner_parentMeshFilter = fieldParent.GetComponent<MeshFilter>(); //CheckParentComponent<MeshFilter>(fieldParent.gameObject);
        /*if(parentMeshFilter==null ){
            Debug.LogError("Parent object has no MeshFilter !");
        }*/
        // 親オブジェクトにMeshRendererがあるかどうか確認します。
        //MeshRenderer parentMeshRenderer = fieldParent.GetComponent<MeshRenderer>();//(fieldParent.gameObject);
        /*if(parentMeshRenderer== null){
            Debug.LogError("Parent object has no  MeshRenderer!");
        }*/
        // 子オブジェクトのMeshFilterへの参照を配列として保持します。
        // ただし、親オブジェクトのメッシュもGetComponentsInChildrenに含まれるので除外します。
        //MeshFilter[] meshFilters = fieldParent.GetComponentsInChildren<MeshFilter>();
        /*Material combinedMat = meshFilters[0].GetComponent<MeshRenderer>().material;
        int combineCount=0;
        foreach(var mesh in meshFilters){
            if(mesh.GetComponent<MeshRenderer>().material.name==combinedMat.name){
                combineCount++;
            }
        }*/
        int combineCount = meshFilters.Length;
        // 結合するメッシュの配列を作成します。
        if (meshCombiner_combine == null)
            meshCombiner_combine = new CombineInstance[combineCount];
        //CombineInstance[] combine = GetCombine(combineCount);//new CombineInstance[combineCount];//
        //GameObject[] allParts = new GameObject[meshFilters.Length-combineCount+1];
        //GameObject[] allParts = new GameObject[1];
        //allParts[0]=fieldParent;
        // 結合するメッシュの情報をCombineInstanceに追加していきます。
        for (int i = 0; i < meshFilters.Length; i++)
        {
            var mesh = meshFilters[i];
            //TODO: destory block dictionaryを参照する
            if (!hasItem)
            {
                meshCombiner_combine[i].mesh = mesh.sharedMesh;
                meshCombiner_combine[i].transform = mesh.transform.localToWorldMatrix;
            }

            if (isInDetailRange)
            {
                meshCombiner_itemOperator_SetActive(mesh.gameObject, ids[i], !brokenArr[i]); // try to spawnでtrueは保証されている
            }
            else
            {
                meshCombiner_itemOperator_SetActive(mesh.gameObject, ids[i], false); // try to spawnでtrueは保証されている
            }
        /*if(mesh.GetComponent<MeshRenderer>().material.name==combinedMat.name){
                combine[index].mesh = mesh.sharedMesh;
                combine[index].transform = mesh.transform.localToWorldMatrix;
                itemOperator.SetActive(mesh.gameObject,false);
                index++;
            } else {
                //allParts[restIndex]=mesh.gameObject;
                restIndex++;
                itemOperator.SetActive(mesh.gameObject,true);
                Debug.LogWarning("MeshCombiner: MeshRenderer material is not same as parent material. ");
            }*/
        }

        if (!hasItem)
        {
            meshCombiner_parentMeshFilter.mesh = new Mesh();
            meshCombiner_parentMeshFilter.mesh.CombineMeshes(meshCombiner_combine);
            meshCombiner_meshCol = fieldParent.GetComponent<MeshCollider>();
            meshCombiner_meshCol.sharedMesh = meshCombiner_parentMeshFilter.mesh;
        }

        meshCombiner_chunkOperator_SetActive(fieldParent, !isInDetailRange);
        return fieldParent;
    }

    MeshFilter[] meshFilters;
    int[][] chunkToCellsDict__keys;
    GameObject[][][] chunkToCellsDict__values;
    int chunkToCellsDict__size;
    public int chunkToCellsDict_Count => chunkToCellsDict__size;

    const int chunkToCellsDict_bucketCount = 2;
    public void chunkToCellsDict_SetCapacity(int capacity)
    {
        int len = capacity / chunkToCellsDict_bucketCount;
        chunkToCellsDict__keys = new int[len][];
        for (int i = 0; i < chunkToCellsDict__keys.Length; i++)
        {
            chunkToCellsDict__keys[i] = new int[chunkToCellsDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < chunkToCellsDict_bucketCount; i++)
        {
            chunkToCellsDict__keys[0][i] = int.MaxValue;
        }

        chunkToCellsDict__values = new GameObject[len][][];
        for (int i = 0; i < chunkToCellsDict__values.Length; i++)
        {
            chunkToCellsDict__values[i] = new GameObject[chunkToCellsDict_bucketCount][];
        }
    }

    public bool chunkToCellsDict_HasItem(int key)
    {
        var index = chunkToCellsDict_Hash(key);
        var hashKeys = chunkToCellsDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int chunkToCellsDict_Hash(int key)
    {
        var len = chunkToCellsDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public int[] chunkToCellsDict_GenerateKeysArray()
    {
        int[] keys = new int[chunkToCellsDict__size];
        int index = 0;
        for (int i = 0; i < chunkToCellsDict__keys.Length; i++)
        {
            var hashKeys = chunkToCellsDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    public bool chunkToCellsDict_Add(int key, GameObject[] value)
    {
        int index = chunkToCellsDict_Hash(key);
        var hashKeys = chunkToCellsDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkToCellsDict__keys[index][i] = key;
                    chunkToCellsDict__values[index][i] = value;
                    chunkToCellsDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectArrDictionary: Key already exists " + key.ToString());
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    chunkToCellsDict__keys[index][i] = key;
                    chunkToCellsDict__values[index][i] = value;
                    chunkToCellsDict__size++;
                    return true;
                }
            }
        }

        chunkToCellsDict_ExpandList(index);
        var preLen = hashKeys.Length;
        chunkToCellsDict__keys[index][preLen] = key;
        chunkToCellsDict__values[index][preLen] = value;
        chunkToCellsDict__size++;
        return true;
    }

    const int chunkToCellsDict_expand = 10;
    void chunkToCellsDict_ExpandList(int index)
    {
        var hashKeys = chunkToCellsDict__keys[index];
        var hashValues = chunkToCellsDict__values[index];
        var len = chunkToCellsDict__keys[index].Length + chunkToCellsDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len][];
        for (int i = 0; i < chunkToCellsDict__keys[index].Length; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = chunkToCellsDict__keys[index].Length; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        chunkToCellsDict__keys[index] = newKeys;
        chunkToCellsDict__values[index] = newValues;
    }

    public void chunkToCellsDict_AddOrSetValue(int key, GameObject[] value)
    {
        int index = chunkToCellsDict_Hash(key);
        var hashKeys = chunkToCellsDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkToCellsDict__keys[index][i] = key;
                    chunkToCellsDict__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkToCellsDict__keys[index][i] = key;
                    chunkToCellsDict__values[index][i] = value;
                    chunkToCellsDict__size++;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkToCellsDict__keys[index][i] = key;
                    chunkToCellsDict__values[index][i] = value;
                    return;
                }

                if (hashKeys[i] == default)
                {
                    chunkToCellsDict__keys[index][i] = key;
                    chunkToCellsDict__values[index][i] = value;
                    chunkToCellsDict__size++;
                    return;
                }
            }
        }

        var preLen = hashKeys.Length;
        chunkToCellsDict_ExpandList(index);
        chunkToCellsDict__keys[index][preLen] = key;
        chunkToCellsDict__values[index][preLen] = value;
        chunkToCellsDict__size++;
    }

    public void chunkToCellsDict_SetValue(int key, GameObject[] value)
    {
        int index = chunkToCellsDict_Hash(key);
        var hashKeys = chunkToCellsDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkToCellsDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkToCellsDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject[] chunkToCellsDict_GetValue(int key)
    {
        int index = chunkToCellsDict_Hash(key);
        var hashKeys = chunkToCellsDict__keys[index];
        var hashValues = chunkToCellsDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public void chunkToCellsDict_Remove(int key)
    {
        int index = chunkToCellsDict_Hash(key);
        var hashKeys = chunkToCellsDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    chunkToCellsDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    chunkToCellsDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    GameObject chunkPool_prefab;
    int[][] chunkPool_idToObjDict__keys;
    GameObject[][] chunkPool_idToObjDict__values;
    int chunkPool_idToObjDict__size;
    public int chunkPool_idToObjDict_Count => chunkPool_idToObjDict__size;

    public int[] chunkPool_idToObjDict_GenerateKeysArray()
    {
        int[] keys = new int[chunkPool_idToObjDict__size];
        int index = 0;
        for (int i = 0; i < chunkPool_idToObjDict__keys.Length; i++)
        {
            var hashKeys = chunkPool_idToObjDict__keys[i];
            if (i == 0)
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != int.MaxValue)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
            else
            {
                for (int j = 0; j < hashKeys.Length; j++)
                {
                    if (hashKeys[j] != default)
                    {
                        keys[index] = hashKeys[j];
                        index++;
                    }
                }
            }
        }

        return keys;
    }

    const int chunkPool_idToObjDict_bucketCount = 2;
    public int chunkPool_idToObjDict_KeyLength => chunkPool_idToObjDict__keys.Length;

    public void chunkPool_idToObjDict_SetCapacity(int capacity)
    {
        int len = capacity / chunkPool_idToObjDict_bucketCount;
        chunkPool_idToObjDict__keys = new int[len][];
        for (int i = 0; i < len; i++)
        {
            chunkPool_idToObjDict__keys[i] = new int[chunkPool_idToObjDict_bucketCount];
        }

        // 0-value-key 対策
        for (int i = 0; i < chunkPool_idToObjDict_bucketCount; i++)
        {
            chunkPool_idToObjDict__keys[0][i] = int.MaxValue;
        }

        chunkPool_idToObjDict__values = new GameObject[len][];
        for (int i = 0; i < len; i++)
        {
            chunkPool_idToObjDict__values[i] = new GameObject[chunkPool_idToObjDict_bucketCount];
        }
    }

    public bool chunkPool_idToObjDict_HasItem(int key)
    {
        var index = chunkPool_idToObjDict_Hash(key);
        var hashKeys = chunkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }
        }

        for (int i = 0; i < hashKeys.Length; i++)
        {
            if (hashKeys[i] == key)
            {
                return true;
            }
        }

        return false;
    }

    private int chunkPool_idToObjDict_Hash(int key)
    {
        var len = chunkPool_idToObjDict__keys.Length;
        var mod = key % len;
        if (mod >= 0)
        {
            return mod;
        }
        else
        {
            return mod + len;
        }
    // return 0 to len-1;
    }

    public bool chunkPool_idToObjDict_Add(int key, GameObject value)
    {
        int index = chunkPool_idToObjDict_Hash(key);
        var hashKeys = chunkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkPool_idToObjDict__keys[index][i] = key;
                    chunkPool_idToObjDict__values[index][i] = value;
                    chunkPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    Debug.LogError("IntKeyGameObjectDictionary: Key already exists " + key.ToString());
                }

                if (hashKeys[i] == default)
                {
                    chunkPool_idToObjDict__keys[index][i] = key;
                    chunkPool_idToObjDict__values[index][i] = value;
                    chunkPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary Add: Dictionary is full "+value.name);
        var preLen = hashKeys.Length;
        chunkPool_idToObjDict_ExpandList(index);
        chunkPool_idToObjDict__keys[index][preLen] = key;
        chunkPool_idToObjDict__values[index][preLen] = value;
        chunkPool_idToObjDict__size++;
        return true;
    }

    const int chunkPool_idToObjDict_expand = 10;
    void chunkPool_idToObjDict_ExpandList(int index)
    {
        var hashKeys = chunkPool_idToObjDict__keys[index];
        var hashValues = chunkPool_idToObjDict__values[index];
        var preLen = hashKeys.Length;
        var len = preLen + chunkPool_idToObjDict_expand;
        var newKeys = new int[len];
        var newValues = new GameObject[len];
        for (int i = 0; i < preLen; i++)
        {
            newKeys[i] = hashKeys[i];
            newValues[i] = hashValues[i];
        }

        if (index == 0)
        {
            for (int i = preLen; i < len; i++)
            {
                newKeys[i] = int.MaxValue;
            }
        }

        chunkPool_idToObjDict__keys[index] = newKeys;
        chunkPool_idToObjDict__values[index] = newValues;
    }

    public bool chunkPool_idToObjDict_AddOrSetValue(int key, GameObject value)
    {
        int index = chunkPool_idToObjDict_Hash(key);
        var hashKeys = chunkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkPool_idToObjDict__keys[index][i] = key;
                    chunkPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == int.MaxValue)
                {
                    chunkPool_idToObjDict__keys[index][i] = key;
                    chunkPool_idToObjDict__values[index][i] = value;
                    chunkPool_idToObjDict__size++;
                    return true;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkPool_idToObjDict__keys[index][i] = key;
                    chunkPool_idToObjDict__values[index][i] = value;
                    return true;
                }

                if (hashKeys[i] == default)
                {
                    chunkPool_idToObjDict__keys[index][i] = key;
                    chunkPool_idToObjDict__values[index][i] = value;
                    chunkPool_idToObjDict__size++;
                    return true;
                }
            }
        }

        //Debug.LogWarning("InkEyGameObjectDictionary AddOrSet: Dictionary is full");
        var preLen = hashKeys.Length;
        chunkPool_idToObjDict_ExpandList(index);
        chunkPool_idToObjDict__keys[index][preLen] = key;
        chunkPool_idToObjDict__values[index][preLen] = value;
        chunkPool_idToObjDict__size++;
        return true;
    }

    public void chunkPool_idToObjDict_SetValue(int key, GameObject value)
    {
        int index = chunkPool_idToObjDict_Hash(key);
        var hashKeys = chunkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    chunkPool_idToObjDict__values[index][i] = value;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    public GameObject chunkPool_idToObjDict_GetValue(int key)
    {
        int index = chunkPool_idToObjDict_Hash(key);
        var hashKeys = chunkPool_idToObjDict__keys[index];
        var hashValues = chunkPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        Debug.LogError("Key not found");
        return default;
    }

    public GameObject chunkPool_idToObjDict_TryGetValue(int key)
    {
        int index = chunkPool_idToObjDict_Hash(key);
        var hashKeys = chunkPool_idToObjDict__keys[index];
        var hashValues = chunkPool_idToObjDict__values[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    return hashValues[i];
                }
            }
        }

        return null;
    }

    public void chunkPool_idToObjDict_Remove(int key)
    {
        int index = chunkPool_idToObjDict_Hash(key);
        var hashKeys = chunkPool_idToObjDict__keys[index];
        if (index == 0)
        {
            if (key == int.MaxValue)
            {
                Debug.LogError("not allowed key value");
            }

            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = int.MaxValue;
                    chunkPool_idToObjDict__size--;
                    return;
                }
            }
        }
        else
        {
            for (int i = 0; i < hashKeys.Length; i++)
            {
                if (hashKeys[i] == key)
                {
                    hashKeys[i] = default;
                    chunkPool_idToObjDict__size--;
                    return;
                }
            }
        }

        Debug.LogError("Key not found");
    }

    [SerializeField]
    int chunkPool_Capacity = 100000;
    public bool chunkPool_itemOperator_SetActive(GameObject obj, bool active)
    {
        MeshCollider col = obj.GetComponent<MeshCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        /*if(col==null||mesh==null){
            Debug.LogError("TilePoolItemOperator: MeshCollider or MeshRenderer is null!");
            return false;
        } gc alloc */
        col.enabled = active;
        mesh.enabled = active;
        //mesh.material.SetFloat("_UpDown",0);// コメントアウトによってshaderによる落下アニメーションは機能しなくなる
        return true;
    }

    //[SerializeField,UnrollAttribute]IntToMeshColliderDictionary idToColDict;
    //[SerializeField,UnrollAttribute]IntToMeshRendererDictionary idToMeshDict;
    /*[SerializeField]int capacity=100000;

    void Start()
    {
        idToColDict.SetCapacity(capacity);
        idToMeshDict.SetCapacity(capacity);
    }*/
    public bool chunkPool_itemOperator_SetActive(GameObject obj, int instanceID, bool active)
    {
        return chunkPool_itemOperator_SetActive(obj, active);
    /*MeshCollider col;
        if(idToColDict.HasItem(instanceID)){
            col=idToColDict.GetValue(instanceID);
        }else{
            col = obj.GetComponent<MeshCollider>();
            idToColDict.Add(instanceID,col);
        }
        MeshRenderer mesh;
        if(idToMeshDict.HasItem(instanceID)){
            mesh=idToMeshDict.GetValue(instanceID);
        }else{
            mesh = obj.GetComponent<MeshRenderer>();
            idToMeshDict.Add(instanceID,mesh);
        }
        col.enabled=active;
        mesh.enabled=active;
        return true;*/
    }

    public bool chunkPool_itemOperator_IsActive(GameObject obj)
    {
        MeshCollider col = obj.GetComponent<MeshCollider>();
        MeshRenderer mesh = obj.GetComponent<MeshRenderer>();
        if (col == null || mesh == null)
        {
            Debug.LogError("TilePoolItemOperator: MeshCollider or MeshRenderer is null!");
            return false;
        }

        return mesh.enabled;
    }

    int chunkPool_poolSize;
    private int[] chunkPool_notActiveObjQueue__array;
    private int chunkPool_notActiveObjQueue__head; // First valid element in the queue.
    private int chunkPool_notActiveObjQueue__tail; // Last valid element in the queue.
    private int chunkPool_notActiveObjQueue__size; // Number of elements.
    private int chunkPool_notActiveObjQueue__version;
    private const int chunkPool_notActiveObjQueue_MinimumGrow = 100000;
    public int chunkPool_notActiveObjQueue_Count => chunkPool_notActiveObjQueue__size;
    public int chunkPool_notActiveObjQueue_Version => chunkPool_notActiveObjQueue__version;

    [Obsolete("Use Count Property.")]
    public int chunkPool_notActiveObjQueue_GetCount() => chunkPool_notActiveObjQueue__size;
    [Obsolete("Use Version Property.")]
    public int chunkPool_notActiveObjQueue_GetVersion() => chunkPool_notActiveObjQueue__version;
    // Removes all Objects from the queue.
    public void chunkPool_notActiveObjQueue_Clear()
    {
        if (chunkPool_notActiveObjQueue__size != 0)
        {
            if (chunkPool_notActiveObjQueue__head < chunkPool_notActiveObjQueue__tail)
            {
                Array.Clear(chunkPool_notActiveObjQueue__array, chunkPool_notActiveObjQueue__head, chunkPool_notActiveObjQueue__size);
            }
            else
            {
                Array.Clear(chunkPool_notActiveObjQueue__array, chunkPool_notActiveObjQueue__head, chunkPool_notActiveObjQueue__array.Length - chunkPool_notActiveObjQueue__head);
                Array.Clear(chunkPool_notActiveObjQueue__array, 0, chunkPool_notActiveObjQueue__tail);
            }

            chunkPool_notActiveObjQueue__size = 0;
        }

        chunkPool_notActiveObjQueue__head = 0;
        chunkPool_notActiveObjQueue__tail = 0;
        chunkPool_notActiveObjQueue__version++;
    }

    // CopyTo copies a collection into an Array, starting at a particular
    // index into the array.
    public void chunkPool_notActiveObjQueue_CopyTo(Array array, int index)
    {
        if (array == null)
        {
            //throw new ArgumentNullException(nameof(array));
            return;
        }

        if (array.Rank != 1)
        {
            //throw new ArgumentException(nameof(array));
            return;
        }

        if (index < 0)
        {
            //throw new ArgumentOutOfRangeException(nameof(index));
            return;
        }

        if (array.Length - index < chunkPool_notActiveObjQueue__size)
        {
            //throw new ArgumentException();
            return;
        }

        int size = chunkPool_notActiveObjQueue__size;
        if (size == 0)
        {
            return;
        }

        int toHead = chunkPool_notActiveObjQueue__array.Length - chunkPool_notActiveObjQueue__head;
        int firstPart = toHead < size ? toHead : size;
        Array.Copy(chunkPool_notActiveObjQueue__array, chunkPool_notActiveObjQueue__head, array, index, firstPart);
        size -= firstPart;
        if (size > 0)
        {
            Array.Copy(chunkPool_notActiveObjQueue__array, 0, array, index + toHead, size);
        }
    }

    // Adds obj to the tail of the queue.
    public void chunkPool_notActiveObjQueue_Enqueue(int obj)
    {
        if (obj == int.MaxValue)
        {
            Debug.LogError("Enqueue: obj is int.MaxValue!");
            return;
        }

        if (chunkPool_notActiveObjQueue__array == null)
        {
            chunkPool_notActiveObjQueue_SetCapacity(chunkPool_notActiveObjQueue_MinimumGrow);
        }
        else if (chunkPool_notActiveObjQueue__size == chunkPool_notActiveObjQueue__array.Length)
        {
            chunkPool_notActiveObjQueue_SetCapacity(chunkPool_notActiveObjQueue__array.Length + chunkPool_notActiveObjQueue_MinimumGrow);
        }

        chunkPool_notActiveObjQueue__array[chunkPool_notActiveObjQueue__tail] = obj;
        chunkPool_notActiveObjQueue__tail = (chunkPool_notActiveObjQueue__tail + 1) % chunkPool_notActiveObjQueue__array.Length;
        chunkPool_notActiveObjQueue__size++;
        chunkPool_notActiveObjQueue__version++;
    }

    // Removes the int at the head of the queue and returns it. If the queue
    // is empty, this method returns null.
    public int chunkPool_notActiveObjQueue_Dequeue()
    {
        if (chunkPool_notActiveObjQueue__size == 0)
            Debug.LogError("Queue is empty!");
        int removed = chunkPool_notActiveObjQueue__array[chunkPool_notActiveObjQueue__head];
        chunkPool_notActiveObjQueue__array[chunkPool_notActiveObjQueue__head] = int.MaxValue;
        chunkPool_notActiveObjQueue__head = (chunkPool_notActiveObjQueue__head + 1) % chunkPool_notActiveObjQueue__array.Length;
        chunkPool_notActiveObjQueue__size--;
        chunkPool_notActiveObjQueue__version++;
        return removed;
    }

    // Returns the int at the head of the queue. The int remains in the
    // queue. If the queue is empty, this method returns null.
    public int chunkPool_notActiveObjQueue_Peek()
    {
        if (chunkPool_notActiveObjQueue__size == 0)
        {
            //throw new InvalidOperationException();
            return int.MaxValue;
        }

        return chunkPool_notActiveObjQueue__array[chunkPool_notActiveObjQueue__head];
    }

    // Iterates over the ints in the queue, returning an array of the
    // ints in the Queue, or an empty array if the queue is empty.
    // The order of elements in the array is first in to last in, the same
    // order produced by successive calls to Dequeue.
    public int[] chunkPool_notActiveObjQueue_ToArray()
    {
        int[] arr = new int[chunkPool_notActiveObjQueue__size];
        if (chunkPool_notActiveObjQueue__size == 0)
        {
        }
        else if (chunkPool_notActiveObjQueue__head < chunkPool_notActiveObjQueue__tail)
        {
            Array.Copy(chunkPool_notActiveObjQueue__array, chunkPool_notActiveObjQueue__head, arr, 0, chunkPool_notActiveObjQueue__size);
        }
        else
        {
            int toHead = chunkPool_notActiveObjQueue__array.Length - chunkPool_notActiveObjQueue__head;
            Array.Copy(chunkPool_notActiveObjQueue__array, chunkPool_notActiveObjQueue__head, arr, 0, toHead);
            Array.Copy(chunkPool_notActiveObjQueue__array, 0, arr, toHead, chunkPool_notActiveObjQueue__tail);
        }

        return arr;
    }

    // PRIVATE Grows or shrinks the buffer to hold capacity ints. Capacity
    // must be >= _size.
    public void chunkPool_notActiveObjQueue_SetCapacity(int capacity)
    {
        int[] newArray = new int[capacity];
        if (chunkPool_notActiveObjQueue__size == 0)
        {
        }
        else if (chunkPool_notActiveObjQueue__head < chunkPool_notActiveObjQueue__tail)
        {
            Debug.LogWarning("SetCapacity: _head < _tail");
            Array.Copy(chunkPool_notActiveObjQueue__array, chunkPool_notActiveObjQueue__head, newArray, 0, chunkPool_notActiveObjQueue__size);
        }
        else
        {
            Debug.LogWarning("SetCapacity: _head >= _tail");
            int toHead = chunkPool_notActiveObjQueue__array.Length - chunkPool_notActiveObjQueue__head;
            Array.Copy(chunkPool_notActiveObjQueue__array, chunkPool_notActiveObjQueue__head, newArray, 0, toHead);
            Array.Copy(chunkPool_notActiveObjQueue__array, 0, newArray, toHead, chunkPool_notActiveObjQueue__tail);
        }

        chunkPool_notActiveObjQueue__array = newArray;
        chunkPool_notActiveObjQueue__head = 0;
        chunkPool_notActiveObjQueue__tail = chunkPool_notActiveObjQueue__size == capacity ? 0 : chunkPool_notActiveObjQueue__size;
        chunkPool_notActiveObjQueue__version++;
    }

    [SerializeField]
    Transform chunkPool_parent;
    void chunkPool_Start()
    {
        chunkPool_prefabName = chunkPool_prefab.name;
        chunkPool_idToObjDict_SetCapacity(chunkPool_Capacity);
        chunkPool_notActiveObjQueue_SetCapacity(chunkPool_Capacity);
    }

    public bool chunkPool_PeekIsInstantiated()
    {
        return chunkPool_isInstantiated;
    }

    bool chunkPool_isInstantiated = false;
    public void chunkPool_Store(Transform p = null)
    {
        if (chunkPool_idToObjDict_Count > chunkPool_idToObjDict_KeyLength)
            return;
        chunkPool_isInstantiated = true;
        GameObject instance;
        int id;
        chunkPool_instance = GameObject.Instantiate(chunkPool_prefab);
        //gc alloc debug only
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        //id = GetInstanceID(instance);/*instance.GetInstanceID();*///.GetHashCode();
        id = chunkPool_instance.GetInstanceID();
        chunkPool_itemOperator_SetActive(chunkPool_instance, id, false);
        chunkPool_idToObjDict_Add(id, chunkPool_instance);
        chunkPool_notActiveObjQueue_Enqueue(id);
    }

    string chunkPool_prefabName;
    GameObject chunkPool_instance;
    // falseで出してmeshcombinerで切り替える
    int chunkPool_uniqueId = 0;
    public GameObject chunkPool_TryToSpawn()
    {
        int id;
        chunkPool_isInstantiated = true;
        if (chunkPool_notActiveObjQueue_Count > 0)
        {
            chunkPool_isInstantiated = false;
            id = chunkPool_notActiveObjQueue_Dequeue();
            if (chunkPool_idToObjDict_HasItem(id))
            {
                var obj = chunkPool_idToObjDict_GetValue(id);
                //itemOperator.SetActive(obj,id,true);
                return obj;
            }
            else
            {
                Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            }
        }

        chunkPool_instance = GameObject.Instantiate(chunkPool_prefab);
        //gc alloc
        /*if(instance==null){
            Debug.LogError("UdonObjectPool Setting Error: Prefab is null");
        }*/
        id = chunkPool_instance.GetInstanceID();
        chunkPool_idToObjDict_Add(id, chunkPool_instance); // gc alloc
        //itemOperator.SetActive(instance,id,true);
        //}while(!idToObjDict.Add(id,instance));
        //if(idToObjDict.HasItem(id))Debug.LogError("UdonObjectPool Error: InstanceID is duplicated!");
        return chunkPool_instance;
    }

    public GameObject chunkPool_TryToSpawn(int id)
    {
        chunkPool_isInstantiated = false;
        if (chunkPool_idToObjDict_HasItem(id))
        {
            var obj = chunkPool_idToObjDict_GetValue(id);
            chunkPool_itemOperator_SetActive(obj, id, false);
            return obj;
        }
        else
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return null;
        }
    }

    public void chunkPool_Return(GameObject obj, bool force = false, bool enqueue = true)
    {
        // gc alloc debug only
        //if(obj==null)return; // gc alloc debug only
        int id = obj.GetInstanceID(); //obj.GetInstanceID();
        if (!chunkPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        chunkPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            chunkPool_notActiveObjQueue_Enqueue(id);
    }

    public void chunkPool_Return(GameObject obj, int id, bool force = false, bool enqueue = true)
    {
        //if(obj==null)return; // gc alloc debug only
        if (!chunkPool_idToObjDict_HasItem(id))
        {
            Debug.LogWarning("UdonObjectPool Error: InstanceID is not found!");
            return;
        }

        chunkPool_itemOperator_SetActive(obj, id, false);
        if (enqueue)
            chunkPool_notActiveObjQueue_Enqueue(id);
    }

    public bool chunkPool_IsMine(GameObject obj)
    {
        return obj.name.Contains(chunkPool_prefab.name);
    }

    public void chunkPool_Clear()
    {
        chunkPool_notActiveObjQueue_Clear();
        foreach (var obj in chunkPool_idToObjDict_GenerateKeysArray())
        {
            chunkPool_itemOperator_SetActive(chunkPool_idToObjDict_GetValue(obj), false);
            chunkPool_notActiveObjQueue_Enqueue(obj);
        }
    }

    GameObject[] generatingCells;
    Biome[] generatingCellBiomes;
    int[] generatingCellInstanceIds;
    int chunkXIndex, chunkYIndex, chunkZIndex;
    GameObject chunkObj;
    int chunkID;
    public const string IndestructibleTag = "Ignore Raycast";
    public const string CellTag = "Cell";
    int ToLocalCellIndex(int xIndex, int yIndex, int zIndex)
    {
        return (xIndex * chunkSize + zIndex) * chunkSizeY + yIndex;
    }

    int ToGlobalCellIndex(int localCellIndex, int chunkIndex)
    {
        return localCellIndex + chunkIndex * chunkSize * chunkSize * chunkSizeY;
    }

    GenerateChunkMode GenerateChunk()
    {
        int chunkIndex = ToChunkIndex(xStartChunkIndex, zStartChunkIndex);
        if (loadedChunkIndexDict_GetValueOrDefault(chunkIndex, false))
            return GenerateChunkMode.Pass;
        bool isInit = false;
        if (chunkXIndex == 0 && chunkZIndex == 0 && chunkYIndex == 0)
        {
            //Debug.Log("GenerateChunk: "+chunkIndex);
            isInit = true;
            //gc alloc debug only
            //if(chunkObj!=null)Debug.LogError("chunkObj is not null");
            if (chunkIndexToInstanceIdDictionary_HasItem(chunkIndex))
            {
                int id = chunkIndexToInstanceIdDictionary_GetValue(chunkIndex);
                chunkObj = chunkPool_TryToSpawn(id);
            }
            else
            {
                chunkObj = chunkPool_TryToSpawn();
                chunkIndexToInstanceIdDictionary_Add(chunkIndex, chunkObj.GetInstanceID());
            }

            //Debug.Log("generate chunkID: "+chunkIndex);
            if (chunkToCellsDict_HasItem(chunkIndex))
            {
                generatingCells = chunkToCellsDict_GetValue(chunkIndex);
                generatingCellBiomes = chunkIndexToCellBiomesDictionary_GetValue(chunkIndex);
                generatingCellInstanceIds = chunkToCellInstanceIdsDictionary_GetValue(chunkIndex);
            }
            else
            {
                generatingCells = new GameObject[chunkSize * chunkSize * chunkSizeY];
                generatingCellBiomes = new Biome[chunkSize * chunkSize * chunkSizeY];
                generatingCellInstanceIds = new int[chunkSize * chunkSize * chunkSizeY];
            }
        }

        //MeshFilter[] meshFilters = new MeshFilter[chunkSize*chunkSize];
        var resCell = GenerateCell(xStartChunkIndex * chunkSize + chunkXIndex, zStartChunkIndex * chunkSize + chunkZIndex, chunkYIndex - chunkSizeY + 1, null);
        if (chunkYIndex < indestructibleLine)
        {
            resCell.layer = LayerMask.NameToLayer(IndestructibleTag);
        }
        else
        {
            resCell.layer = LayerMask.NameToLayer(CellTag);
        }

        int localIndex = ToLocalCellIndex(chunkXIndex, chunkYIndex, chunkZIndex);
        int instanceId = resCell.GetInstanceID();
        meshFilters[localIndex] = resCell.GetComponent<MeshFilter>();
        generatingCells[localIndex] = resCell;
        generatingCellInstanceIds[localIndex] = instanceId;
        generatingCellBiomes[localIndex] = currentCellBiome;
        instanceIDToGlobalCellIndexDictionary_AddOrSetValue(instanceId, ToGlobalCellIndex(localIndex, chunkIndex));
        chunkYIndex++;
        if (chunkYIndex == chunkSizeY)
        {
            chunkYIndex = 0;
            chunkZIndex++;
            //resCell.name+=IndestructibleTag; // 底は破壊不可能にする
            if (chunkZIndex == chunkSize)
            {
                chunkZIndex = 0;
                chunkXIndex++;
                if (chunkXIndex == chunkSize)
                {
                    if (!chunkToCellsDict_HasItem(chunkIndex))
                    {
                        chunkToCellsDict_Add(chunkIndex, generatingCells);
                        chunkIndexToCellBiomesDictionary_Add(chunkIndex, generatingCellBiomes);
                        chunkToCellInstanceIdsDictionary_Add(chunkIndex, generatingCellInstanceIds);
                        loadedChunkIndexDict_Add(chunkIndex, true);
                    }
                    else
                    {
                        loadedChunkIndexDict_SetValue(chunkIndex, true);
                    }

                    bool isInDetailRange = IsInDetailRange(GetPlayerPosition(), xStartChunkIndex, zStartChunkIndex);
                    if (isInDetailRange)
                    {
                        for (int i = 0; i < generatingCells.Length; i++)
                        {
                            brokenArr[i] = permanentBreakCellDictionary_GetValueOrDefault(ToGlobalCellIndex(i, chunkIndex), false);
                        }

                        detailChunkIndexDict_AddOrSetValue(chunkIndex, true);
                        detailOperationDictionary_AddOrSetValue(chunkIndex, true);
                    }

                    var hasIItem = outlineDict_HasItem(chunkIndex);
                    var outline = meshCombiner_CombineMesh(chunkObj, meshFilters, generatingCellInstanceIds, isInDetailRange, brokenArr, hasIItem);
                    if (!hasIItem)
                    {
                        outlineDict_Add(chunkIndex, outline);
                    }

                    chunkObj = null;
                    unloadOperationDictionary_AddOrSetValue(chunkIndex, false);
                    return GenerateChunkMode.Complete;
                }
            }
        }

        if (isInit)
            return GenerateChunkMode.Init;
        return GenerateChunkMode.Generating;
    }

    [SerializeField]
    int indestructibleLine = 2;
    public GameObject GenerateCell(int xIndex, int zIndex, int yIndex, Transform parent)
    {
        xValue = xIndex * scale + _seedX;
        zValue = zIndex * scale + _seedZ;
        perlinValue = fbm(xValue, zValue, 4, 0.4f); //Mathf.PerlinNoise(xValue, zValue);
        height = fieldHeight * (perlinValue - waterPercentage);
        height = Mathf.Round(height);
        spawnPos = new Vector3(xIndex, height + yIndex, zIndex) * TileScale;
        //spawnPos = new Vector3((xIndex)*TileScale,height,zIndex*TileScale);
        biomeCell = GenerateBiome(xIndex, zIndex, parent);
        biomeCell.transform.localPosition = spawnPos;
        //gc alloc
        /*if(biomeCell!=null){
            biomeCell.transform.localPosition = spawnPos;
        } else {
            Debug.LogWarning("Chunk pool is empty!");
        }*/
        return biomeCell;
    }

    GameObject biomeCell;
    float scaleT => settings_scaleT;

    float scaleH => settings_scaleH;

    bool isInstantiated = false;
    Biome currentCellBiome = 0;
    GameObject GenerateBiome(int xIndex, int zIndex, Transform parent)
    {
        xTValue = xIndex * scaleT + _seedTX;
        zTValue = zIndex * scaleT + _seedTZ;
        xHValue = xIndex * scaleH + _seedHX;
        zHValue = zIndex * scaleH + _seedHZ;
        float temperature = Mathf.PerlinNoise(xTValue, zTValue);
        float humidity = Mathf.PerlinNoise(xHValue, zHValue);
        //humidity *= Mathf.Sqrt(1-(1-temperature)*(1-temperature));
        Biome biomeType;
        if (height <= 0)
            biomeType = Biome.Water;
        else
        {
            int tempIndex = Math.Min((int)(temperature * 5), 4);
            int humIndex = Math.Min((int)(humidity * 5), 4);
            biomeType = biomeMap[tempIndex][humIndex];
        }

        var cell = BiomeTryToSpawn(biomeType);
        currentCellBiome = biomeType;
        isInstantiated = BiomePeekIsInstantiated(biomeType);
        return cell;
    }

    float fbmTotal, fbmFrequency, fbmAmplitude, fbmMaxValue;
    int fbmIndex;
    float fbm(float x, float y, int octaves, float persistence)
    {
        fbmTotal = 0;
        fbmFrequency = 1;
        fbmAmplitude = 1;
        fbmMaxValue = 0; // Used for normalizing result to 0.0 - 1.0
        for (fbmIndex = 0; fbmIndex < octaves; fbmIndex++)
        {
            fbmTotal += Mathf.PerlinNoise(x * fbmFrequency, y * fbmFrequency) * fbmAmplitude;
            fbmMaxValue += fbmAmplitude;
            fbmAmplitude *= persistence;
            fbmFrequency *= 2;
        }

        return fbmTotal / fbmMaxValue;
    }
}